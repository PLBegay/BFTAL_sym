
\chapter{Rappels mathématiques}
%\section{Lexique }

%\paragraph{}On rappelle quelques notions et notations de base.

\section{Logique}

\subsection{Raisonnement par l'absurde}
\label{abs}

\begin{definition}{Raisonnement par l'absurde}{}
Un \textbf{raisonnement par l'absurde} consiste à prouver une chose en 1) supposant son contraire et 2) montrer que ça fout tout en l'air. Plus formellement, pour prouver $P$, on suppose $\neg P$ et on montre que ça nous permet de déduire $\bot$, ce qui veut dire soit que la logique est incohérente, soit que $\neg P$ est fausse, et donc que $P$ est vraie.
\end{definition}

\begin{example}
Imaginons une situation où les rues sont sèches, et où on voudrait prouver qu'il n'a pas plu. On suppose alors l'inverse, c'est-à-dire qu'il a plu. Or, s'il a plu, les routes sont mouillées. On obtient alors que 1) les routes sont mouillées et 2) les routes ne sont pas mouillées, ce qui est un paradoxe. La seule hypothèse faite étant le fait qu'il a plu, elle doit être fausse.
\end{example}

\begin{example}
On veut prouver qu'il existe une infinité de nombres premiers. On suppose l'inverse, cad. qu'il y en a un ensemble fini $\{p_1,...,p_n\}$. Soit $n = 1 + \prod_{i \in [1 - n]} p_i = 1 + p_1 \times ... \times p_n$. $n$, comme tout nombre, admet au moins un diviseur premier. 

Or, $n$ est strictement plus grand que tout nombre premier et ne peut donc pas en être un. De plus, pour tout $i \in [1 - n]$, $\frac{n}{p_i} = p_1 \times ... \times p_{i-1} \times p_{i+1} \times ... \times p_n + \frac{1}{p_i}$. Tout nombre premier étant $\geq 2$, $\frac{1}{p_i}$ ne forme pas un entier, et donc $\frac{n}{p_i}$ non plus.

On obtient une contradiction, notre hypothèse sur la finitude des nombres premiers est donc fausse.
\end{example}



\section{Ensembles}

\subsection{Ensemble des parties}
\label{powerset}
Soit un ensemble $X$, on note $P(X)$ (parfois $2^X$) l'ensemble de ses parties (ou \textit{powerset}), cad l'ensemble des ensembles formés à partir d'éléments de $X$. 

\begin{example}
Soit $X = \{x,y,z\}$, alors - en classant les éléments par leur cardinal -

\begin{tabular}{llll}
 $P(X) = \{$ & $\emptyset$, & & \\
& $\{x\}$,&$\{y\}$,&$\{z\}$,\\
&$\{x,y\}$,& $\{x,z\}$,&$\{y,z\}$\\
& $\{x,y,z\}$ & &$~~~~~~~~\}$.
\end{tabular}
\end{example}

\begin{lemma}
$\forall X, \emptyset \in P(X) \wedge X \in P(X)$.
\end{lemma}

\begin{lemma}
$\forall X, |P(X)| = 2^{|X|}$.
\end{lemma}

\begin{proof}
Pour générer l'ensemble des sous-ensembles de $X$, on choisit de prendre ou non chaque élément de $X$. On a donc $\underbrace{2 \times 2 \times ... \times 2}_{\textrm{n fois}}$ choix, d'où les $2^{|X|}$ au total.
\end{proof}

\subsection{Opérations entre ensembles}

\begin{definition}{Produit d'ensembles}{}
\label{ensprod}
Soit deux ensembles $E_1$ et $E_2$, contenant respectivement des éléments de types $\tau_1$ et $\tau_2$. Soit également $\cdot$ une opération de type $\tau_1 \rightarrow \tau_2 \rightarrow \tau_3$, cad. une opération qui prend en argument gauche un élément de type $\tau_1$ et à droite un argument de type $\tau_2$ et renvoie un objet de type $\tau_3$, alors 

\[
E_1 \cdot E_2 = \{x \cdot y~|~x \in E_1~\wedge~y \in E_2\}
\]
\end{definition}

Dit autrement, un produit d'ensembles renvoie l'ensemble des combinaisons d'éléments de deux ensembles \textit{via} une opération fournie. Si l'opération $\cdot$ est un endormorphisme, cad. qu'elle est de type $\tau \rightarrow \tau \rightarrow \tau$, alors on peut itérer le produit de la façon suivante :

\begin{eqnarray*}
E^0 = \{1\} ~~~~~~~~~~~~~~~~ \textrm{Où $1$ est l'élément neutre de $\tau$} \\
E^{n+1} = E^n \cdot E
\end{eqnarray*}

Cette notion très générale ne doit pas être confondue avec

\begin{definition}{Produit cartésien}{}
Soit deux ensembles $E_1$ et $E_2$, ne contenant pas forcément des éléments de même type, alors

\[
E_1 \times E_2 = \{(x,y)~|~x \in E_1~\wedge~y \in E_2\}
\]
\end{definition}

Le produit cartésien, noté $\times$, renvoie l'ensemble des couples d'éléments de deux ensembles donnés. Il s'agit d'un cas particulier du produit d'ensemble, où l'opération est la "mise en couple". Cette opération ne pouvant pas être un endormorphisme, le produit cartésien ne peut être itéré.

\section{Algorithmique}

\subsection{Itératif vs. récursif, le cas des parcours d'arbre}
\label{itersif}
On va comparer les implémentations itératives et récursives d'un parcours d'arbre. On regardera, sans perte de généralité, un parcours préfixe qui effectue une opération $f$ (par exemple afficher, peu importe) sur tous les éléments de l'arbre.

Commençons par l'itératif. Puisqu'on a (littéralement des branchements, contrairement à une liste où on pourrait juste foncer tout droit, on va avoir besoin d'une mémoire. L'idée va être d'avoir une \textit{todo-list}, sous forme de pile, et d'explorer l'arbre en la suivant. On commence avec seulement la racine dans la pile et, chaque fois qu'en extrait un noeud comme dans la figure $\ref{simparbre}$, exécuter $f(x)$ et se noter qu'on doit explorer les arbre $d_1$, $d_2$ et $d_3$. Au total, on a l'algorithme de la figure \ref{treeit}.

\begin{figure}[!ht]
\centering
$\Tree[.x d_1 d_2 d_3 ]$
\caption{Exemple de noeud}
\label{simparbre}
\end{figure}

\begin{figure}[!ht]
\begin{python}
# fonction tree_it(arbre)
todo = stack()
todo.add(root(arbre))
while (todo pas vide):
    current = todo.pop()
    if current is Leaf(x):
        f(x)
    // si current est un noeud interne avec 
    // un element x et la liste de descendants descs
    elif current is Noeud(x,descs):
        f(x)
        // pour du prefixe, on doit avoir
        // d1 plus haut dans la pile que d2
        for d in reverse(descs):
             todo.add(d)

\end{python}
\caption{Parcours itératif d'arbre}
\label{treeit}
\end{figure}

Il n'est pas totalement trivial de se convaincre que cet algorithme visite bien tous les noeuds d'un arbre donné dans un ordre préfixe, notamment en comparaison de la version récursive trouvable en figure \ref{treerec}

\begin{figure}[!ht]
\begin{python}
# fonction tree_rec(arbre)
if arbre is Leaf(x):
    f(x)
elif arbre is Noeud(x,descs):
    f(x)
    for d in descs:
        tree_rec(d)
\end{python}
\caption{Parcours récursif d'arbre}
\label{treerec}
\end{figure}

La version récursive est dite \textbf{de haut-niveau}, dans le sens où elle est très proche de la définition d'un parcours d'arbre, alors que la version itérative est plus \texbf{de bas-niveau}, en ce qu'elle implémente cette définition. Dit autrement, la version récursive est plus abstraite, là où la version itérative est plus concrète, dans la mise en pratique de la définition. D'ailleurs, la figure \ref{treeit} correspond bien à l'exécution de la figure \ref{treerec}, où la pile $todo$ remplace la pile d'appels, qui gère les appels récursifs en suivant "où on en est" et ce qu'il reste à faire.

Ces deux approches ont bien sûr leurs avantages et inconvénients. La programmation de haut-niveau permet de se convaincre - voire de prouver - bien plus facilement qu'un programme réalise ce qu'il est censé faire, et est plus facilement lisible / réutilisable. Par contre, jouer soi-même avec l'implémentation de la récursion permet de gérer à la main ces mécanismes et donc potentiellement d'optimiser tout ça - bien que les compilateurs appliquent des optimisations de plus en plus puissantes, bien souvent plus sûres et malignes que ce qu'on peut imaginer. 

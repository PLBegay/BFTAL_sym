\chapter{Automates finis}
\label{automates}


%\epigraph{- "Qu'est-ce qu'un automate ?"\\- "Des ronds et des flèches m'sieur !"\\- "Rien à voir ! [...] Un automate, c'est un graphe orienté."}{[censuré]}

Les automates forment un langage de programmation un peu particulier, en ce qu'il est très visuel (chaque programme est un graphe annoté, ou plus prosaïquement des ronds et des flèches) et que tout programme a le même type : un mot en entrée, un booleen en sortie. Un automate définit donc un langage en donnant un moyen automatique de déterminer si n'importe quel mot donné en fait partie ou non\footnote{En ce sens, les automates sont des \href{https://fr.wikipedia.org/wiki/Fonction_caract\%C3\%A9ristique_(th\%C3\%A9orie_des_ensembles)}{fonctions caractéristiques}, qui sont aux ensembles ce que les videurs sont aux boîtes de nuit.}.

Les automates se divisent en de nombreuses sous-catégories, dont certaines ramifications seront explorées dans ce cours. On verra d'abord le fonctionnement général des automates finis déterministes (\ref{DFA}) et non-déterministes (\ref{NDFA}), en allant à chaque fois du général au technique. On verra ensuite des algorithmes pour transformer (\ref{transauto}) des automates. On étudiera enfin les combinaisons d'automates, et donc les propriétés de clôture des langages qu'ils définissent (\ref{cloture}).

\section{Automates finis déterministes}
\label{DFA}

On introduit les Automates finis déterministes, noté $AFD$ (ou $DFA$, pour \textit{deterministic finite automaton}\footnote{Notez qu'on parle d'\textit{automat\textbf{on}} au singulier et d'\textit{automat\textbf{a}} au pluriel}), avant d'en étudier la formalisation.


\subsection{Principe général}

Imaginez que vous développiez un jeu d'infiltration. Dans ce jeu, le comportement des méchants gardes ressemblerait sans doute à la figure \ref{garde}.

\begin{figure}[!h]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.9cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


  \node[initial,state] (A)                    {Dodo};
  \node[] (D) [right of=A] {} ;
  \node[state] (B)      [right of=D]                {Fouille};
  \node[state] (C)      [above of=B]                {Combat};

  \path %(I) edge[loop above]              node {$a,b$} (I)
(A) edge      [bend right]        node {Bruit suspect} (B)
(B) edge      [bend right]        node {Rien trouvé} (A)
(B) edge      [bend right]        node {Ennemi trouvé} (C)
(C) edge      [bend right]        node {Ennemi tué} (A);
\end{tikzpicture}
\caption{Comportement des gardes d'un jeu imaginaire}
\label{garde}
\end{figure}

Ce qu'est censé traduire ce graphe, c'est qu'un garde commence (la $\rightarrow$ sur sa gauche) dans un \textbf{état} qui est le dodo, et que différents événements (un bruit, un ennemi trouvé ou non, ou encore tué) vont le faire changer d'\textbf{état}. Un AFD fonctionne sur un principe similaire\footnote{Les AFD sont en fait des cas particuliers de Machines à états finis, \href{https://www.youtube.com/watch?v=JyF0oyarz4U}{qui sont effectivement employées dans la conception de jeux vidéo}}, mais où les transitions sont déclenchées par la lecture de lettres : un $AFD$, en partant d'un état initial, lit le mot donné en argument lettre par lettre et, à chaque lecture, change d'état en fonction de la lettre. 

\begin{example}
L'automate de la figure \ref{aaauto} contient trois états, appelés $0$, $1$ et $2$. La lecture de tout mot commence en $0$, appelé \textbf{état initial}. Si on lui passe le mot $abbaaba$ en argument, la première lettre ($a$) va nous faire passer de l'état $0$ à $1$. La deuxième lettre ($b$) nous refait passer en $0$. La troisième ($b$) nous y fait rester. Les deux lettres suivantes nous font ensuite passer en $1$ puis en $2$. Les deux dernières lectures nous font rester en $2$ (la virgule est à comprendre comme une disjonction, cad. comme un "ou").
\end{example}



\begin{figure}[!h]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.9cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


  \node[initial,state] (A)                    {$0$};
  \node[state] (B)      [right of=A]                {$1$};
  \node[accepting,state] (C)      [right of=B]                {$2$};

  \path %(I) edge[loop above]              node {$a,b$} (I)
(A) edge      [loop above]        node {$b$} (A)
(C) edge      [loop above]        node {$a,b$} (C)
(A) edge      [bend right]        node {$a$} (B)
(B) edge      [bend right]        node {$b$} (A)
(B) edge      []        node {$a$} (C);
\end{tikzpicture}
\caption{Un premier automate}
\label{aaauto}
\end{figure}

Comme dit en introduction, un automate accepte ou rejette tout mot donné. Certains états, notés par une douche couche, sont appelés états finaux (ou terminaux). Un mot est accepté par un automate si et seulement si le parcours de ce mot dans l'automate se termine sur un état final.

\begin{example}
L'automate de la figure \ref{aaauto} accepte le mot $abbaaba$, puisqu'il nous fait passer de l'état initial $0$ à $2$, qui est un état final. Il n'accepte en revanche pas les mots $bbaba$ (état $1$), $babbab$ ou $\epsilon$ (état $0$ tous les deux).
\end{example}

\begin{exercice}
Les mots $abbaba$, $ababbaab$ et $abba$ sont-ils acceptés par l'automate de la figure \ref{aaauto} ?
\end{exercice}

\begin{exercice}
Quel est le \textbf{langage reconnu}, cad. l'ensemble des mots acceptés, par l'automate de la figure \ref{aaauto} ? Donner la réponse en français et sous forme d'expression rationnelle.
\end{exercice}

\paragraph*{Remarque} Un automate ne contient pas toujours une transition pour chaque couple d'état / lettre, auquel cas il est dit \textbf{incomplet}. Si un automate ne contient pas de chemin correspondant à un mot, ce dernier est rejetté.

\begin{example}
L'automate de la figure \ref{incompauto} rejette le mot $aba$, car il n'y a pas de transition partant de l'état $1$ pour la lettre $b$.
\end{example}


\begin{figure}[!h]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.9cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


  \node[initial,state] (A)                    {$0$};
  \node[state] (B)      [right of=A]                {$1$};
  \node[accepting,state] (C)      [right of=B]                {$2$};

  \path %(I) edge[loop above]              node {$a,b$} (I)
(A) edge      [loop above]        node {$b$} (A)
(C) edge      [loop above]        node {$a,b$} (C)
(A) edge      []        node {$a$} (B)
(B) edge      []        node {$a$} (C);
\end{tikzpicture}
\caption{Un automate incomplet}
\label{incompauto}
\end{figure}


\begin{exercice}
Les mots $bbbaababbaaba$, $bbabaab$ et $baaaaaab$ sont-ils acceptés par l'automate de la figure \ref{incompauto} ?
\end{exercice}

\begin{exercice}
Quel est le langage reconnu par l'automate de la figure \ref{incompauto} ? Donner la réponse en français et sous forme d'expression rationnelle.
\end{exercice}


Il nous semble important d'insister sur le point suivant : de la même façon qu'un programme devrait la traduction d'une logique sous-jacente plutôt qu'un bidouaille fait à la va-vite, les états d'un automate ont un sens. Avant d'écrire un automate, il convient donc de réfléchir quelles sont les informations à retenir au cours de la lecture du mot. Si la bonne réponse est trouvée, le reste de l'automate devrait s'écrire seul.

\begin{example}
\label{exemplePI}
On veut écrire un automate reconnaissant le langage $L = \{w \in \Sigma^*~|~|w|_a$ pair et $|w|_b$ impair$\}$, cad. l'ensemble des mots avec un nombre pair de $a$ et impairs de $b$\footnote{On conseillera tout d'abord au lecteur ou à la lectrice de tenter lui/elle-même l'exercice, afin de mesurer la pertinence de l'approche ici présentée}.

Il n'est pas question de compter les $a$ et les $b$ comme on pourrait naïvement l'imaginer, non seulement puisqu'il faut se contenter d'un nombre fini d'états, mais aussi parce que c'est beaucoup plus d'information que nécessaire.
Les seules données qui nous intéressent sont en effet la parité du nombre de $a$ et du nombre de $b$ du mot donné : $a^2b$ comme $a^{26}b^{131}$ sont équivalents dans leur appartenance à $L$.

Le nombre de $a$ et de $b$ étant tous les deux pairs ou impairs, on a 4 possibilités. Nos états s'appeleront $PP$ (nombre de $a$ pair et nombre de $b$ pair), $PI$ ($a$ pair et $b$ impair), $IP$ et $II$. La définition de $L$ nous dit immédiatement que seul $PI$ devrait être terminal. L'état initial devrait être celui qui correspond à $\epsilon$, cad. $PP$.

Les transitions s'écrivent naturellement : en partant de $PP$, la lecture d'un $a$ change la parité du nombre de $a$ mais pas celle du nombre de $b$, et nous emmène donc vers $IP$, tandis que $b$ pointe vers $PI$, et ainsi de suite. S'il y a d'autres lettres dans l'alphabet, elles devraient faire des boucles, puisqu'elles ne changent rien aux parités qui nous intéressent.

Au final, on obtient l'automate suivant : 


\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.9cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


  \node[initial,state] (PP)                    {$PP$};
  \node[state] (IP)      [above right of=PP]                {$IP$};  \node[state] (II)      [below right of=IP]                {$II$};
  \node[accepting,state] (PI)      [below right of=PP]                {$PI$};

  \path %(I) edge[loop above]              node {$a,b$} (I)
(PP) edge      [bend right]        node {$a$} (IP)
(PP) edge      [bend right]        node {$b$} (PI)
(PI) edge      [bend right]        node {$a$} (II)
(PI) edge      [bend right]        node {$b$} (PP)
(IP) edge      [bend right]        node {$a$} (PP)
(IP) edge      [bend right]        node {$b$} (II)
(II) edge      [bend right]        node {$a$} (PI)
(II) edge      [bend right]        node {$b$} (IP);
\end{tikzpicture}
\end{example}

\begin{exercice} (**) En reprenant l'exemple \ref{exemplePI}, montrer que $\forall w, w \in L \leftrightarrow$ l'automate accepte $w$. Vous pouvez procéder par induction sur $w$, en utilisant un objectif un peu plus précis que celui fourni.
\end{exercice}

Dans la série d'exercices qui suit, on utilisera comme alphabet $\Sigma = \{a,b\}$.

\begin{exercice}
Donner un automate qui reconnaît le langage $\{w \in \Sigma^*~|~|w| \geq 3\}$. 
\end{exercice}

\begin{exercice}
Donner un automate pour les mots qui commencent par $a$.
\end{exercice}

\begin{exercice}
Donner un automate pour les mots qui finissent par $b$.
\end{exercice}

\begin{exercice}
Donner un automate pour les mots qui commencent par $a$ finissent par $b$.
\end{exercice}


\begin{exercice}
Donner un automate pour les mots de longueur paire.
\end{exercice}

\begin{exercice}
Donner un autuomate pour les mots de longueur impaire qui contiennent au moins 4 lettres.
\end{exercice}

\begin{exercice}
Donner un automate pour les mots de longueur impaire, qui contiennent au moins 4 lettres, commencent par $a$ et finissent par $b$.
\end{exercice}

\subsection{Formalisation et implémentation}

Un automate fini déterministe est un $5-uplet$ (cad. un "paquet" qui contient 5 éléments ordonnés)

\[
%A =  
\big \langle Q,\Sigma,q_0,F,\delta \big \rangle
\]

avec

\begin{itemize}
\item[] $Q$ ensemble fini d'états
\item[] $\Sigma$ l'alphabet
\item[] $q_0$ l'état initial
\item[] $F \subseteq Q$, les états terminaux
\item[] $\delta$ fonction partielle\footnote{Une fonction partielle est une fonction qui n'attribue pas forcément une image à tout argument. Dans le cas d'un automate complet, la fonction de transition est donc une fonction totale.} de $Q \times \Sigma$ dans $Q$ 
\end{itemize}

La fonction $\delta$ est alors \textit{liftée} aux mots\footnote{On dit qu'une fonction est \textit{liftée} lorsqu'on "soulève" le type d'un ou plusieurs de ses arguments, pour qu'elle s'applique par exemple à des listes ou des ensembles. Typiquement, si on a une fonction $f$ de type $\mathbb{N} \rightarrow \mathbb{N}$, alors sa version \textit{liftée} aux listes, étant donnée une liste $[a_1,...,a_n]$, renverra $[f(a_1),...,f(a_n)]$.} pour obtenir la fonction $\delta^* : (Q \times \Sigma^*) \rightarrow Q$ définie de la façon suivante :

\begin{itemize}
\item $\delta^*(q,\epsilon) = q$
\item $\delta^*(q,a.w) = \delta^*(\delta(q,a),w)$ ($a$ est une lettre et $w$ un mot, éventuellement vide)
\end{itemize}

Plus prosaïquement, la fonction $\delta^*$ applique $\delta$ sur $w$, lettre par lettre, de la gauche vers la droite. Dans ce cadre, on dit qu'un mot $w$ est \textbf{reconnu} (ou accepté) par l'automate ssi. $\delta^*(q_0,w) \in F$. Dit encore autrement, un mot est accepté ssi en partant de l'état initial de l'automate et en suivant les transitions correspondant aux lettres successives du mot on finit dans un état terminal. 

La définition de $\delta^*$ donne quasiment directement une implémentation de la reconnaissance via automate fini déterministe :
\begin{figure}[!ht]
\begin{python}
state = q_0
for c in w:
    state = delta(state,c)
return (state in F)
\end{python}
\caption{Reconnaissance par un AFD}
\label{afdrec}
\end{figure}

\begin{example}
L'automate de la figure \ref{aaauto} se formalise de la façon suivante :

\begin{itemize}
\item $Q = \{0,1,2\}$
\item $\Sigma = \{a,b\}$
\item $q_0 = 0$
\item $F = \{2\}$
\item $\delta(0,a) = 1; \delta(0,b) = 0; \delta(1,a) = 2; \delta(1,b) = 0; \delta(2,a) = 2; \delta(2,b) = 2$
\end{itemize}

On peut vérifier qu'il accepte bien le mot $abbaaba$ (lecture comme une BD) :

\begin{tabular}{lllll}
$\delta^*(0,abbaaba)$ &$=$& $\delta^*(\delta(0,a),bbaaba)$& $=$&$\delta^*(1,bbaaba)$ \\
&$=$& $\delta^*(\delta(1,b),baaba)$ &$=$& $\delta^*(0,baaba) $\\
&$=$& $\delta^*(\delta(0,b),aaba)$ &$=$& $\delta^*(0,aaba) $\\
&$=$& $\delta^*(\delta(0,a),aba)$ &$=$& $\delta^*(1,aba) $\\
&$=$& $\delta^*(\delta(1,a),ba)$ &$=$& $\delta^*(2,ba) $\\
&$=$& $\delta^*(\delta(2,b),a)$ &$=$& $\delta^*(2,a) $\\
&$=$& $\delta^*(\delta(2,a),\epsilon)$ &$=$& $\delta^*(2,\epsilon) $\\
&&&$=$&$2 \in F$
\end{tabular}


\end{example}

\begin{exercice}
Donner la formalisation de l'automate de l'exemple \ref{exemplePI} et vérifier qu'il accepte le mot $aababba$. 
\end{exercice}

On a introduit en \ref{reappart} l'expression rationnelle $e = ((\Sigma^*baaba^+)^*baa(abba)^+ba(bb)^*a)^*$, qu'on était censé traduire en programme via les automates finis. Or, la traduction en AFD n'est à priori pas si évidente que ça (on conseille à nouveau d'essayer pour se rendre compte de la difficulté), du fait du haut niveau de non-déterminisme dans la \textit{regex}. On va donc avoir besoin d'un modèle un peu plus permissif.

\section{Automates finis non-déterministes}
\label{NDFA}

Les automates finis qu'on a vus jusqu'ici sont déterministes, en ce qu'un automate admet au maximum une seule transition par lettre, et donc que tout mot n'a lui-même pas plus d'un chemin. On va ici voir une nouvelle classe d'automates, les automates finis non-déterministes (AFND, ou \textit{NDFA} pour \textit{non-deterministic finite automaton/a}), qui vont justement nous libérer de cette contrainte.

\subsection{Principe général}

Le non-déterminisme se manifeste de deux façons. On a d'abord les $\epsilon$-transitions, qui seront étudiées à part dans le cadre d'un DM. Ici, on se concentrera sur la possibilité d'avoir plusieurs transitions pour le même couple état $\times$ lettre, ainsi que plusieurs états initiaux.

On peut donc maintenant avoir dans un automate plusieurs chemins pour un même mot, chemins qui vont chacun mener ou non à un état terminal. On accepte tout mot qui mène à un état terminal via au moins un chemin.

\begin{example}
\label{exnondet1}
Le langage des mots qui contiennent le facteur $aba$, dénoté par la \textit{regex} $\Sigma^*aba\Sigma^*$, est reconnu par l'automate suivant :

\begin{figure}[!ht]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.9cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


  \node[initial,state] (0)                    {$0$};
  \node[state] (1)      [right of=0]                {$1$};  
  \node[state] (2)      [right of=1]                {$2$};
  \node[accepting,state] (3)      [right of=2]                {$3$};

  \path %(I) edge[loop above]              node {$a,b$} (I)
(0) edge      [loop above]        node {$a,b$} (0)
(0) edge      []        node {$a$} (1)
(1) edge      []        node {$b$} (2)
(2) edge      []        node {$a$} (3)
(3) edge      [loop above]        node {$a,b$} (3);
\end{tikzpicture}
\end{figure}

Si on regarde par exemple le mot $aabab$, il dispose de 3 parcours dans l'automate : 

\begin{itemize}
\item $0 \xrightarrow{a} 0 \xrightarrow{a} 0 \xrightarrow{b} 0 \xrightarrow{a} 0 \xrightarrow{b} 0$
\item $0 \xrightarrow{a} 0 \xrightarrow{a} 0 \xrightarrow{b} 0 \xrightarrow{a} 1 \xrightarrow{b} 2$
\item $0 \xrightarrow{a} 0 \xrightarrow{a} 1 \xrightarrow{b} 2 \xrightarrow{a} 3 \xrightarrow{b} 3$
\end{itemize}

On peut aussi passer dans l'état $1$ avec le premier $a$, mais il sera alors impossible de lire l'entiéreté du mot (le deuxième $a$ n'aura pas de transition).

Des trois chemins possibles, un seul mène à un état terminal. C'est néanmoins suffisant pour que le mot soit accepté. A l'inverse, le mot $abbaabbaaabba$, bien que pouvant faire de très nombreux chemins dans l'automate, n'est pas accepté car aucun ne finit en $3$
\end{example}

Un tel automate a l'avantage de reconnaître très clairement le langage $\Sigma^*aba\Sigma^*$. On peut par exemple le comparer à sa version déterministe qui, malgré la simplicité du langage, perd déjà pas mal en lisibilité :

\begin{figure}[!ht]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.9cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


  \node[initial,state] (0)                    {$0$};
  \node[state] (1)      [right of=0]                {$1$};  
  \node[state] (2)      [right of=1]                {$2$};
  \node[accepting,state] (3)      [right of=2]                {$3$};

  \path %(I) edge[loop above]              node {$a,b$} (I)
(0) edge      [loop above]        node {$b$} (0)
(0) edge      []        node {$a$} (1)
(1) edge      [loop above]        node {$a$} (1)
(1) edge      []        node {$b$} (2)
(2) edge      []        node {$a$} (3)
(2) edge      [bend left]        node {$b$} (0)
(3) edge      [loop above]        node {$a,b$} (3);
\end{tikzpicture}
\end{figure}

La grande différence entre les deux automates est que le premier utilise le non-déterminisme pour être une transcription directe de la \textit{regex}, là où le deuxième se bat avec le déterminisme pour reconnaître le langage de façon presque "accidentelle". En un sens, on est passé du domaine de la \textbf{spécification} à l'\textbf{implémentation}. La mauvaise nouvelle, c'est que les automates non-déterministes sont plus compliqués à mettre en pratique, du fait - ô surprise - du non-déterminisme, qui impose de tester énormément de chemins. La bonne nouvelle, c'est que, comme on va le voir en \ref{det}, on peut traduire automatiquement les automates non-déterministes en automates déterministes équivalents\footnote{Pour se rendre compte du miracle que c'est, on peut comparer aux langages de programmation classiques. Ce n'est pas parce qu'on a spécifié formellement, par exemple, le tri d'une liste (ce qui est déjà surprenamment non-trivial) qu'on peut automatiquement obtenir un programme réalisant cette tâche. Même une fois qu'on a codé un tel programme, selon l'algorithme chopisi, il n'est pas forcément aisé de se convaincre qu'il est correct, et encore moins de le prouver formellement. Il est donc assez \textit{cool} que tout ce passage de la spécification (la \textit{regex}) à une représentation intermédiaire (l'automate non-déterministe) à l'implémentation (le déterministe) soit automatique et sûre.}, avec bien sûr un certain coût. Mais avant de plonger dans ces histoires, on va voir encore quelques exemples d'AFND, et en étudier la formalisation.

\begin{example}
\label{incomptoo}
On veut reconnaître le langage des mots qui contiennent le facteur $aba$ ou (inclusif) $bab$. On peut exploiter la possibilité d'avoir plusieurs états initiaux, et tout simplement produire l'automate suivant :

\begin{figure}[!ht]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.9cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


  \node[initial,state] (0)                    {$0$};
  \node[state] (1)      [right of=0]                {$1$};  
  \node[state] (2)      [right of=1]                {$2$};
  \node[accepting,state] (3)      [right of=2]                {$3$};

  \node[initial,state] (4)  [below of=0]            {$4$};
  \node[state] (5)      [right of=4]                {$5$};  
  \node[state] (6)      [right of=5]                {$6$};
  \node[accepting,state] (7)      [right of=6]                {$7$};

  \path %(I) edge[loop above]              node {$a,b$} (I)
(0) edge      [loop above]        node {$a,b$} (0)
(0) edge      []        node {$a$} (1)
(1) edge      []        node {$b$} (2)
(2) edge      []        node {$a$} (3)
(3) edge      [loop above]        node {$a,b$} (3)
(4) edge      [loop above]        node {$a,b$} (4)
(4) edge      []        node {$b$} (5)
(5) edge      []        node {$a$} (6)
(6) edge      []        node {$b$} (7)
(7) edge      [loop above]        node {$a,b$} (7);

\end{tikzpicture}
\end{figure}

On notera bien sûr la symétrie entre l'automate ci-dessus, et la regex $\Sigma^*aba\Sigma^* + \Sigma^*bab\Sigma^*$.

On peut aussi tenter d'être un poil plus malin, se rendre compte que les états $0$ et $4$ ont le même \textbf{rôle}, que les états $3$ et $7$ aussi, et donc qu'on peut réduire le nombre d'états en les fusionnant :


\begin{figure}[!ht]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.9cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


  \node[initial,state] (0)                    {$0/4$};
  \node[state] (1)      [above right of=0]                {$1$};  
  \node[state] (2)      [right of=1]                {$2$};
  \node[state] (3)      [below right of=0]                {$5$};  
  \node[state] (4)      [right of=3]                {$6$};
  \node[accepting,state] (5)      [below right of=2]                {$3/7$};

  \path %(I) edge[loop above]              node {$a,b$} (I)
(0) edge      [loop right]        node {$a,b$} (0)
(0) edge      []        node {$a$} (1)
(0) edge      []        node {$b$} (3)
(1) edge      []        node {$b$} (2)
(3) edge      []        node {$a$} (4)
(2) edge      []        node {$a$} (5)
(4) edge      []        node {$b$} (5)
(5) edge      [loop right]        node {$a,b$} (5);

\end{tikzpicture}
\end{figure}
\newpage
Cette notion d'états équivalents et fusionnables sera formalisée en \ref{minim}. On remarquera (à nouveau) la symétrie entre cet automate et la regex $\Sigma^*(aba+bab)\Sigma^*$.

\end{example}

\begin{exercice}
Donner une \textit{regex} et un automate fini pour le langage $L = \{w ~|~ aba$ est un sous-mot de $w\}$.
\end{exercice}


\begin{exercice}
Donner une \textit{regex} et un automate fini pour le langage des mots qui commencent par $ab$ et finissent par $ba$.
\end{exercice}

\subsection{Formalisation et implémentation}

Les automates non-déterministes sont une généralisation\footnote{En effet, un AFD peut-être vu comme un AFND qui se trouve être ... déterministe. Rien dans la définition d'un AFND n'impose que le non-déterminisme permis par le changement de type de $\delta$ soit exploité, et on peut donc très bien avoir $|\delta(q,c)| \leq 1~\forall q \in Q$ et $\forall c \in \Sigma$.} des automates déterministes, où
 
\begin{itemize}
\item L'état initial $q_0$ est remplacé par un ensemble d'états initiaux $I \subseteq Q$
\item La fonction de transition $\delta$ change de type, en passant de $(Q \times \Sigma) \rightarrow Q$ à $(Q \times \Sigma) \rightarrow P(Q)$\footnote{Pour rappel, $P(Q)$ est l'ensemble des sous-parties de $Q$, cad. l'ensemble des ensembles d'états, cf \ref{powerset}.}. Dit autrement, étant donnés un état $q \in Q$ et une lettre $c \in \Sigma$, on a (potentiellement) \textit{accès} à un ensemble d'états plutôt qu'à un seul.
\end{itemize}


Puisqu'on a changé le type $\delta$, on doit également changer son \textit{lift} $\delta^*$, qui renvoie maintenant un ensemble d'états et est donc de type $(Q \times \Sigma^*) \rightarrow P(Q)$ :
 
\begin{itemize}
\item $\delta^*(q,\epsilon) = \{q\}$
\item $\delta^*(q,a.w) = \bigcup_{q' \in \delta(q,a)} \delta^*(q',w)$
\end{itemize}

Il nous reste à vérifier que l'ensemble d'états atteignales contient un état terminal. Un AFND accepte donc un mot $w$ ssi. $\exists q \in ((\bigcup_{q_i \in I} \delta^*(q_i,w)) \cap F)$.

Pour ce qui est de la mise en application de $\delta^*$, on est cette fois face à un parcours d'arbres (l'ensemble des chemins) plutôt que d'une liste, comme dans la version déterministe. On adapte donc l'annexe \ref{itersif} :

\begin{figure}[!ht]
\begin{python}
# fonction ndfa_acc(auto,w)
# renvoie true ssi. l automate auto accepte le mot w
todo = stack()
// On va empiler des couples etat x mot qu il faut tester
// On commence par se noter tous les etats initiaux
for i in initial(auto):
    todo.add(i,w)
while (todo pas vide):
    (q,mot) = todo.pop()
    // Si on a fini de lire le mot et qu on est
    // arrive sur un etat final, on accepte
    // Si l etat n est pas final, on ne renvoie
    // pas false, car il peut rester des chemins
    // qu il faut tester
    if mot is empty et q in F:
        return true 
    elif mot is a.reste:
        // On continue la lecture du mot avec 
        // chaque etat qu on peut atteindre
        // avec la premiere lettre
        next_states = delta(q,a)
        for suivant in next_states:
            todo.add(suivant,reste)
// Si on n a au final rien trouve, on dit non
return false
\end{python}
\caption{Reconnaissance par un AFND - version iterative}
%\label{treeit}
\end{figure}

\begin{figure}[!ht]
\begin{python}
# fonction ndfa_acc_bis(auto,w,q)
# renvoie true ssi. l automate auto accepte le mot w en partant de l etat q
if w is empty:
    return q in F
elif w is a.reste:
    for suivant in delta(q,a):
        if ndfa_acc_bis(auto,reste,suivant):
            return true
    return false


# fonction ndfa_acc(auto,w)
# renvoie true ssi. l automate auto accepte le mot w
for i in initial(auto):
    if ndfa_acc_bis(auto,w,i):
        return true
return false
\end{python}
\caption{Reconnaissance par un AFND - version récursive}
%\label{treerec}
\end{figure}
\newpage

\section{Transformation d'automates}
\label{transauto}


La formalisation très limitée et simple des automates en fait des programmes particulièrement simple à manipuler, comme l'illustrent les algorithmes de transformation d'automates présentés ici.

\subsection{Complétion}


On peut facilement compléter un automate en rajoutant un état "poubelle", non terminal et bouclant, qui absorbera tous les transitions ajoutées.

\begin{example}
Si on complète l'automate de la figure \ref{incompauto}, on rajoute un état $P$ qui boucle sur lui-même. Il manquait dans l'automate uniquement une $b$-transition partant de l'état $1$. On rajoute donc $1 \xrightarrow{b} P$, et on obtient 

\begin{figure}[!h]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.9cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


  \node[initial,state] (A)                    {$0$};
  \node[state] (B)      [right of=A]                {$1$};
  \node[state] (P)      [below of=B]                {$P$};
  \node[accepting,state] (C)      [right of=B]                {$2$};

  \path %(I) edge[loop above]              node {$a,b$} (I)
(A) edge      [loop above]        node {$b$} (A)
(C) edge      [loop above]        node {$a,b$} (C)
(A) edge      []        node {$a$} (B)
(B) edge      []        node {$b$} (P)
(P) edge      [loop left]        node {$a,b$} (P)
(B) edge      []        node {$a$} (C);
\end{tikzpicture}
\caption{Un automate complété}
\label{incompautocor}
\end{figure}
\end{example}

\begin{exercice}
Compléter le premier automate de l'exemple \ref{incomptoo}.
\end{exercice}

On peut se convaincre assez facilement que la complétion ne change pas le langage reconnu par un automate : un parcours prend de nouvelles transitions ssi. il ne pouvait aller jusqu'au bout dans l'automate initial. Dans les deux cas, le mot associé n'est pas accepté, puisqu'on boucle sur un état non-terminal dans le premier cas, et on "plante" dans le second.

Cette transformation se formalise également assez facilement. Soit un automate $\big \langle Q,\Sigma,q_0,F,\delta \big \rangle$, alors on renvoie l'automate \big \langle Q \cup~\{P\},\Sigma,q_0,F,\delta' \big \rangle, avec

\[
\left\{\!\begin{aligned}
&\delta'(q,a) = \delta(q,a) &\text{ si } \delta(q,a) \text{ défini},\\[1ex]
&\delta'(q,a) = P &\text{ si } \delta(q,a) \text{ non défini},\\[1ex]
&\delta'(P,a) = P &\text{ pour tout } a \in \Sigma\\[1ex]
\end{aligned}
\]

Notez qu'on met les cas $\delta'(P,a)$ à part, car (on suppose) $P \not\in Q$, ce qui implique que $\delta(P,a)$ n'a pas de sens.

\subsection{Déterminisation}
\label{det}

L'algorithme présenté ici prend en entrée un AFND et renvoie un AFD reconnaissant le même langage. L'idée est que l'AFD va simuler le comportement de l'AFND, et donc, étant donné un mot, que le (seul) parcours dans l'AFD va représenter tous ceux dans l'AFND.

Pour ça, l'ensemble d'états de l'AFD va être l'ensemble des combinaisons d'états de l'AFND. Par exemple, si on a dans ce derniers deux états initiaux $i_1$ et $i_2$, l'automate initial de l'AFD sera l'état $\{i_1, i_2\}$. Supposons de plus que les transitions partant de $i_1$ et $i_2$ sont les suivantes :

\begin{itemize}
\item $i_1 \xrightarrow{a} q_1$
\item $i_1 \xrightarrow{a} q_2$
\item $i_2 \xrightarrow{a} q_1$
\item $i_2 \xrightarrow{a} q_3$
\end{itemize}

Tout mot commençant par $a$ lu par l'AFND peut donc faire son premier saut en $q_1$, $q_2$ ou $q_3$. On ajoute donc à l'AFD la transition $\{i_1,i_2\} \xrightarrow{a} \{q_1, q_2, q_3\}$, et ainsi de suite.

Arriver, après lecture d'un mot, dans un état $X$ de l'AFD signifie donc que, dans l'AFND, on peut atterir dans chacun des états contenus dans $X$ après la lecture du même mot. Puisqu'un AFND accepte quand au moins un des parcours termine sur un état terminal, tout état de l'AFD contenant un état terminal est lui-même terminal. 

\begin{example}
\label{detex1}
Si on essayer de déterminiser l'automate de l'exemple \ref{exnondet1}, on obtient

\begin{figure}[!ht]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.9cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


  \node[initial,state] (0)                    {$0$};
  \node[state] (1)      [right of=0]                {$0,1$};  
  \node[state] (2)      [right of=1]                {$0,2$};
  \node[accepting,state] (3)      [right of=2]                {$0,1,3$};
  \node[accepting,state] (4)      [right of=3]                {$0,2,3$};
  \node[accepting,state] (5)      [below of=4]                {$0,3$};

  \path %(I) edge[loop above]              node {$a,b$} (I)
(0) edge      [loop above]        node {$b$} (0)
(0) edge      []        node {$a$} (1)
(1) edge      [loop above]        node {$a$} (1)
(1) edge      []        node {$b$} (2)
(2) edge      [bend left]        node {$b$} (0)
(2) edge      []        node {$a$} (3)
(3) edge      [loop above]        node {$a$} (3)
(3) edge      []        node {$b$} (4)
(4) edge      [bend left]        node {$a$} (3)
(4) edge      []        node {$b$} (5)
(5) edge      [loop right]        node {$b$} (3)
(5) edge      []        node {$a$} (3);
\end{tikzpicture}
\end{figure}

On notera une grande proximité avec la déterminisation "à la main" qu'on avait initialement faite dans l'exemple. En effet, on a les correspondances suivantes entre les états :

\begin{itemize}
\item $0 \approx 0$
\item $1 \approx 0,1$
\item $2 \approx 0,2$
\item $3 \approx 0,1,3 + 0,2,3 + 0,3$
\end{itemize}
\end{example}

\begin{exercice}
Déterminiser le premier automate de l'exemple \ref{incomptoo}.
\end{exercice}

La déterminisation se formalise aussi assez bien en termes de définitions. Soit un automate $\big \langle Q,\Sigma,I,F,\delta \big \rangle$, alors on renvoie l'automate \big \langle P(Q),\Sigma,\bigcup_{i \in I} i,F,\delta' \big \rangle, avec

\[
\delta'(X,a) = \bigcup_{q \in X} \delta(q,a)
\]

Noter que suivre cette définition génère un automate qui contient tout un tas d'états qui vont être inatteignables, et donc ne servir à rien. En l'appliquant sur l'exemple \ref{detex1}, on devrait notamment produire les états $\{1,2\}$ ou $\{2,3\}$. En pratique, on préfèrera donc suivre l'algorithme présenté avec les mains, qui consiste à partir de l'état initial et d'ajouter les états / transitions au fur à mesure, jusqu'à atteindre un point fixe.

Il s'agit d'un résultat extrêmement important de la théorie des automates, notamment en ce qu'il nous permet d'utiliser amplement le non-déterminisme dans nos conceptions d'automates, ce dernier pouvant être éliminé par cet algorithme. Cette transformation a cependant un coût, qui peut être très élevé. En effet, le lemme \ref{cardpowerset} implique que la déterminisation d'un automate à $n$ états peut en avoir jusqu'à $2^n$.

On peut commencer à voir pourquoi en re-regardant l'exemple \ref{detex1}, où on a 3 états terminaux alors qu'un seul serait suffisant : une fois qu'on a atteint l'état $\{0,1,3\}$, on ne fait que tourner entre trois états terminaux, ce qui veut dire que n'importe quel (reste de) mot sera accepté. L'algorithme de déterminisation ne s'intéresse pas au rôle des états (il est \textbf{syntaxique}, et non \textbf{sémantique}), et ne voit donc pas qu'une fusion est ici possible. De telles optimisations vont cependant nous être fournies par le prochain algorithme.


\subsection{Minimisation}
\label{minim}

\section{Propriétés de clôture}
\label{cloture}
\subsection{Union}

\subsection{Intersection}

\subsection{Concaténation}

\subsection{Itération}


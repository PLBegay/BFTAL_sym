\chapter{Automates finis}
\label{automates}


%\epigraph{- "Qu'est-ce qu'un automate ?"\\- "Des ronds et des flèches m'sieur !"\\- "Rien à voir ! [...] Un automate, c'est un graphe orienté."}{[censuré]}

Les automates forment un langage de programmation un peu particulier, en ce qu'il est très visuel (chaque programme est un graphe annoté, ou plus prosaïquement des ronds et des flèches) et que tout programme a le même type : un mot en entrée, un booleen en sortie. Un automate définit donc un langage en donnant un moyen automatique de déterminer si n'importe quel mot donné en fait partie ou non\footnote{En ce sens, les automates sont des \href{https://fr.wikipedia.org/wiki/Fonction_caract\%C3\%A9ristique_(th\%C3\%A9orie_des_ensembles)}{fonctions caractéristiques}, qui sont aux ensembles ce que les videurs sont aux boîtes de nuit.}.

Les automates se divisent en de nombreuses sous-catégories, dont certaines ramifications seront explorées dans ce cours. On verra d'abord le fonctionnement général des automates finis déterministes (\ref{DFA}) et non-déterministes (\ref{NDFA}), en allant à chaque fois du général au technique. On verra ensuite des algorithmes pour transformer (\ref{transauto}) des automates. On étudiera enfin les combinaisons d'automates, et donc les propriétés de clôture des langages qu'ils définissent (\ref{cloture}).

\section{Automates finis déterministes}
\label{DFA}

On introduit les Automates finis déterministes, noté $AFD$ (ou $DFA$, pour \textit{deterministic finite automaton}\footnote{Notez qu'on parle d'\textit{automat\textbf{on}} au singulier et d'\textit{automat\textbf{a}} au pluriel}), avant d'en étudier la formalisation.


\subsection{Principe général}

Imaginez que vous développiez un jeu d'infiltration. Dans ce jeu, le comportement des méchants gardes ressemblerait sans doute à la figure \ref{garde}.

\begin{figure}[!h]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.9cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


  \node[initial,state] (A)                    {Dodo};
  \node[] (D) [right of=A] {} ;
  \node[state] (B)      [right of=D]                {Fouille};
  \node[state] (C)      [above of=B]                {Combat};

  \path %(I) edge[loop above]              node {$a,b$} (I)
(A) edge      [bend right]        node {Bruit suspect} (B)
(B) edge      [bend right]        node {Rien trouvé} (A)
(B) edge      [bend right]        node {Ennemi trouvé} (C)
(C) edge      [bend right]        node {Ennemi tué} (A);
\end{tikzpicture}
\caption{Comportement des gardes d'un jeu imaginaire}
\label{garde}
\end{figure}

Ce qu'est censé traduire ce graphe, c'est qu'un garde commence (la $\rightarrow$ sur sa gauche) dans un \textbf{état} qui est le dodo, et que différents événements (un bruit, un ennemi trouvé ou non, ou encore tué) vont le faire changer d'\textbf{état}. Un AFD fonctionne sur un principe similaire\footnote{Les AFD sont en fait des cas particuliers de Machines à états finis, \href{https://www.youtube.com/watch?v=JyF0oyarz4U}{qui sont effectivement employées dans la conception de jeux vidéo}}, mais où les transitions sont déclenchées par la lecture de lettres : un $AFD$, en partant d'un état initial, lit le mot donné en argument lettre par lettre et, à chaque lecture, change d'état en fonction de la lettre. 

\begin{example}
L'automate de la figure \ref{aaauto} contient trois états, appelés $0$, $1$ et $2$. La lecture de tout mot commence en $0$, appelé \textbf{état initial}. Si on lui passe le mot $abbaaba$ en argument, la première lettre ($a$) va nous faire passer de l'état $0$ à $1$. La deuxième lettre ($b$) nous refait passer en $0$. La troisième ($b$) nous y fait rester. Les deux lettres suivantes nous font ensuite passer en $1$ puis en $2$. Les deux dernières lectures nous font rester en $2$ (la virgule est à comprendre comme une disjonction, cad. comme un "ou").
\end{example}



\begin{figure}[!h]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.9cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


  \node[initial,state] (A)                    {$0$};
  \node[state] (B)      [right of=A]                {$1$};
  \node[accepting,state] (C)      [right of=B]                {$2$};

  \path %(I) edge[loop above]              node {$a,b$} (I)
(A) edge      [loop above]        node {$b$} (A)
(C) edge      [loop above]        node {$a,b$} (C)
(A) edge      [bend right]        node {$a$} (B)
(B) edge      [bend right]        node {$b$} (A)
(B) edge      []        node {$a$} (C);
\end{tikzpicture}
\caption{Un premier automate}
\label{aaauto}
\end{figure}

Comme dit en introduction, un automate accepte ou rejette tout mot donné. Certains états, notés par une douche couche, sont appelés états finaux (ou terminaux). Un mot est accepté par un automate si et seulement si le parcours de ce mot dans l'automate se termine sur un état final.

\begin{example}
L'automate de la figure \ref{aaauto} accepte le mot $abbaaba$, puisqu'il nous fait passer de l'état initial $0$ à $2$, qui est un état final. Il n'accepte en revanche pas les mots $bbaba$ (état $1$), $babbab$ ou $\epsilon$ (état $0$ tous les deux).
\end{example}

\begin{exercice}
Les mots $abbaba$, $ababbaab$ et $abba$ sont-ils acceptés par l'automate de la figure \ref{aaauto} ?
\end{exercice}

\begin{exercice}
Quel est le \textbf{langage reconnu}, cad. l'ensemble des mots acceptés, par l'automate de la figure \ref{aaauto} ? Donner la réponse en français et sous forme d'expression rationnelle.
\end{exercice}

\paragraph*{Remarque} Un automate ne contient pas toujours une transition pour chaque couple d'état / lettre, auquel cas il est dit \textbf{incomplet}. Si un automate ne contient pas de chemin correspondant à un mot, ce dernier est rejetté.

\begin{example}
L'automate de la figure \ref{incompauto} rejette le mot $aba$, car il n'y a pas de transition partant de l'état $1$ pour la lettre $b$.
\end{example}


\begin{figure}[!h]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.9cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


  \node[initial,state] (A)                    {$0$};
  \node[state] (B)      [right of=A]                {$1$};
  \node[accepting,state] (C)      [right of=B]                {$2$};

  \path %(I) edge[loop above]              node {$a,b$} (I)
(A) edge      [loop above]        node {$b$} (A)
(C) edge      [loop above]        node {$a,b$} (C)
(A) edge      []        node {$a$} (B)
(B) edge      []        node {$a$} (C);
\end{tikzpicture}
\caption{Un automate incomplet}
\label{incompauto}
\end{figure}


\begin{exercice}
Les mots $bbbaababbaaba$, $bbabaab$ et $baaaaaab$ sont-ils acceptés par l'automate de la figure \ref{incompauto} ?
\end{exercice}

\begin{exercice}
Quel est le langage reconnu par l'automate de la figure \ref{incompauto} ? Donner la réponse en français et sous forme d'expression rationnelle.
\end{exercice}


Il nous semble important d'insister sur le point suivant : de la même façon qu'un programme devrait la traduction d'une logique sous-jacente plutôt qu'un bidouaille fait à la va-vite, les états d'un automate ont un sens. Avant d'écrire un automate, il convient donc de réfléchir quelles sont les informations à retenir au cours de la lecture du mot. Si la bonne réponse est trouvée, le reste de l'automate devrait s'écrire seul.

\begin{example}
\label{exemplePI}
On veut écrire un automate reconnaissant le langage $L = \{w \in \Sigma^*~|~|w|_a$ pair et $|w|_b$ impair$\}$, cad. l'ensemble des mots avec un nombre pair de $a$ et impairs de $b$\footnote{On conseillera tout d'abord au lecteur ou à la lectrice de tenter lui/elle-même l'exercice, afin de mesurer la pertinence de l'approche ici présentée}.

Il n'est pas question de compter les $a$ et les $b$ comme on pourrait naïvement l'imaginer, non seulement puisqu'il faut se contenter d'un nombre fini d'états, mais aussi parce que c'est beaucoup plus d'information que nécessaire.
Les seules données qui nous intéressent sont en effet la parité du nombre de $a$ et du nombre de $b$ du mot donné : $a^2b$ comme $a^{26}b^{131}$ sont équivalents dans leur appartenance à $L$.

Le nombre de $a$ et de $b$ étant tous les deux pairs ou impairs, on a 4 possibilités. Nos états s'appeleront $PP$ (nombre de $a$ pair et nombre de $b$ pair), $PI$ ($a$ pair et $b$ impair), $IP$ et $II$. La définition de $L$ nous dit immédiatement que seul $PI$ devrait être terminal. L'état initial devrait être celui qui correspond à $\epsilon$, cad. $PP$.

Les transitions s'écrivent naturellement : en partant de $PP$, la lecture d'un $a$ change la parité du nombre de $a$ mais pas celle du nombre de $b$, et nous emmène donc vers $IP$, tandis que $b$ pointe vers $PI$, et ainsi de suite. S'il y a d'autres lettres dans l'alphabet, elles devraient faire des boucles, puisqu'elles ne changent rien aux parités qui nous intéressent.

Au final, on obtient l'automate suivant : 


\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.9cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


  \node[initial,state] (PP)                    {$PP$};
  \node[state] (IP)      [above right of=PP]                {$IP$};  \node[state] (II)      [below right of=IP]                {$II$};
  \node[accepting,state] (PI)      [below right of=PP]                {$PI$};

  \path %(I) edge[loop above]              node {$a,b$} (I)
(PP) edge      [bend right]        node {$a$} (IP)
(PP) edge      [bend right]        node {$b$} (PI)
(PI) edge      [bend right]        node {$a$} (II)
(PI) edge      [bend right]        node {$b$} (PP)
(IP) edge      [bend right]        node {$a$} (PP)
(IP) edge      [bend right]        node {$b$} (II)
(II) edge      [bend right]        node {$a$} (PI)
(II) edge      [bend right]        node {$b$} (IP);
\end{tikzpicture}
\end{example}

\begin{exercice} (**) En reprenant l'exemple \ref{exemplePI}, montrer que $\forall w, w \in L \leftrightarrow$ l'automate accepte $w$. Vous pouvez procéder par induction sur $w$, en utilisant un objectif un peu plus précis que celui fourni.
\end{exercice}

Dans la série d'exercices qui suit, on utilisera comme alphabet $\Sigma = \{a,b\}$.

\begin{exercice}
Donner un automate qui reconnaît le langage $\{w \in \Sigma^*~|~|w| \geq 3\}$. 
\end{exercice}

\begin{exercice}
Donner un automate pour les mots qui commencent par $a$.
\end{exercice}

\begin{exercice}
Donner un automate pour les mots qui finissent par $b$.
\end{exercice}

\begin{exercice}
Donner un automate pour les mots qui commencent par $a$ finissent par $b$.
\end{exercice}


\begin{exercice}
Donner un automate pour les mots de longueur paire.
\end{exercice}

\begin{exercice}
Donner un automate pour les mots de longueur impaire qui contiennent au moins 4 lettres.
\end{exercice}

\begin{exercice}
Donner un automate pour les mots de longueur impaire, qui contiennent au moins 4 lettres, commencent par $a$ et finissent par $b$.
\end{exercice}

\subsection{Formalisation et implémentation}

Un automate fini déterministe est un $5-uplet$ (cad. un "paquet" qui contient 5 éléments ordonnés)

\[
%A =  
\big \langle Q,\Sigma,q_0,F,\delta \big \rangle
\]

avec

\begin{itemize}
\item[] $Q$ ensemble fini d'états
\item[] $\Sigma$ l'alphabet
\item[] $q_0$ l'état initial
\item[] $F \subseteq Q$, les états terminaux
\item[] $\delta$ fonction partielle\footnote{Une fonction partielle est une fonction qui n'attribue pas forcément une image à tout argument. Dans le cas d'un automate complet, la fonction de transition est donc une fonction totale.} de $Q \times \Sigma$ dans $Q$ 
\end{itemize}

La fonction $\delta$ est alors \textit{liftée} aux mots\footnote{On dit qu'une fonction est \textit{liftée} lorsqu'on "soulève" le type d'un ou plusieurs de ses arguments, pour qu'elle s'applique par exemple à des listes ou des ensembles. Typiquement, si on a une fonction $f$ de type $\mathbb{N} \rightarrow \mathbb{N}$, alors sa version \textit{liftée} aux listes, étant donnée une liste $[a_1,...,a_n]$, renverra $[f(a_1),...,f(a_n)]$.} pour obtenir la fonction $\delta^* : (Q \times \Sigma^*) \rightarrow Q$ définie de la façon suivante :

\begin{itemize}
\item $\delta^*(q,\epsilon) = q$
\item $\delta^*(q,a.w) = \delta^*(\delta(q,a),w)$ ($a$ est une lettre et $w$ un mot, éventuellement vide)
\end{itemize}

Plus prosaïquement, la fonction $\delta^*$ applique $\delta$ sur $w$, lettre par lettre, de la gauche vers la droite. Dans ce cadre, on dit qu'un mot $w$ est \textbf{reconnu} (ou accepté) par l'automate ssi. $\delta^*(q_0,w) \in F$. Dit encore autrement, un mot est accepté ssi en partant de l'état initial de l'automate et en suivant les transitions correspondant aux lettres successives du mot on finit dans un état terminal. 

La définition de $\delta^*$ donne quasiment directement une implémentation de la reconnaissance via automate fini déterministe :
\begin{figure}[!ht]
\begin{python}
state = q_0
for c in w:
    state = delta(state,c)
return (state in F)
\end{python}
\caption{Reconnaissance par un AFD}
\label{afdrec}
\end{figure}

\begin{example}
L'automate de la figure \ref{aaauto} se formalise de la façon suivante :

\begin{itemize}
\item $Q = \{0,1,2\}$
\item $\Sigma = \{a,b\}$
\item $q_0 = 0$
\item $F = \{2\}$
\item $\delta(0,a) = 1; \delta(0,b) = 0; \delta(1,a) = 2; \delta(1,b) = 0; \delta(2,a) = 2; \delta(2,b) = 2$
\end{itemize}

On peut vérifier qu'il accepte bien le mot $abbaaba$ (lecture comme une BD) :

\begin{tabular}{lllll}
$\delta^*(0,abbaaba)$ &$=$& $\delta^*(\delta(0,a),bbaaba)$& $=$&$\delta^*(1,bbaaba)$ \\
&$=$& $\delta^*(\delta(1,b),baaba)$ &$=$& $\delta^*(0,baaba) $\\
&$=$& $\delta^*(\delta(0,b),aaba)$ &$=$& $\delta^*(0,aaba) $\\
&$=$& $\delta^*(\delta(0,a),aba)$ &$=$& $\delta^*(1,aba) $\\
&$=$& $\delta^*(\delta(1,a),ba)$ &$=$& $\delta^*(2,ba) $\\
&$=$& $\delta^*(\delta(2,b),a)$ &$=$& $\delta^*(2,a) $\\
&$=$& $\delta^*(\delta(2,a),\epsilon)$ &$=$& $\delta^*(2,\epsilon) $\\
&&&$=$&$2 \in F$
\end{tabular}


\end{example}

\begin{exercice}
Donner la formalisation de l'automate de l'exemple \ref{exemplePI} et vérifier qu'il accepte le mot $aababba$. 
\end{exercice}

On a introduit en \ref{reappart} l'expression rationnelle $e = ((\Sigma^*baaba^+)^*baa(abba)^+ba(bb)^*a)^*$, qu'on était censé traduire en programme via les automates finis. Or, la traduction en AFD n'est à priori pas si évidente que ça (on conseille à nouveau d'essayer pour se rendre compte de la difficulté), du fait du haut niveau de non-déterminisme dans la \textit{regex}. On va donc avoir besoin d'un modèle un peu plus permissif.

\section{Automates finis non-déterministes}
\label{NDFA}

Les automates finis qu'on a vus jusqu'ici sont déterministes, en ce qu'un automate admet au maximum une seule transition par lettre, et donc que tout mot n'a lui-même pas plus d'un chemin. On va ici voir une nouvelle classe d'automates, les automates finis non-déterministes (AFND, ou \textit{NDFA} pour \textit{non-deterministic finite automaton/a}), qui vont justement nous libérer de cette contrainte.

\subsection{Principe général}

Le non-déterminisme se manifeste de deux façons. On a d'abord les $\epsilon$-transitions, qui seront étudiées à part dans le cadre d'un DM. Ici, on se concentrera sur la possibilité d'avoir plusieurs transitions pour le même couple état $\times$ lettre, ainsi que plusieurs états initiaux.

On peut donc maintenant avoir dans un automate plusieurs chemins pour un même mot, chemins qui vont chacun mener ou non à un état terminal. On accepte tout mot qui mène à un état terminal via au moins un chemin.

\begin{example}
\label{exnondet1}
Le langage des mots qui contiennent le facteur $aba$, dénoté par la \textit{regex} $\Sigma^*aba\Sigma^*$, est reconnu par l'automate suivant :

\begin{figure}[!ht]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.9cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


  \node[initial,state] (0)                    {$0$};
  \node[state] (1)      [right of=0]                {$1$};  
  \node[state] (2)      [right of=1]                {$2$};
  \node[accepting,state] (3)      [right of=2]                {$3$};

  \path %(I) edge[loop above]              node {$a,b$} (I)
(0) edge      [loop above]        node {$a,b$} (0)
(0) edge      []        node {$a$} (1)
(1) edge      []        node {$b$} (2)
(2) edge      []        node {$a$} (3)
(3) edge      [loop above]        node {$a,b$} (3);
\end{tikzpicture}
\end{figure}

Si on regarde par exemple le mot $aabab$, il dispose de 3 parcours dans l'automate : 

\begin{itemize}
\item $0 \xrightarrow{a} 0 \xrightarrow{a} 0 \xrightarrow{b} 0 \xrightarrow{a} 0 \xrightarrow{b} 0$
\item $0 \xrightarrow{a} 0 \xrightarrow{a} 0 \xrightarrow{b} 0 \xrightarrow{a} 1 \xrightarrow{b} 2$
\item $0 \xrightarrow{a} 0 \xrightarrow{a} 1 \xrightarrow{b} 2 \xrightarrow{a} 3 \xrightarrow{b} 3$
\end{itemize}

On peut aussi passer dans l'état $1$ avec le premier $a$, mais il sera alors impossible de lire l'entiéreté du mot (le deuxième $a$ n'aura pas de transition).

Des trois chemins possibles, un seul mène à un état terminal. C'est néanmoins suffisant pour que le mot soit accepté. A l'inverse, le mot $abbaabbaaabba$, bien que pouvant faire de très nombreux chemins dans l'automate, n'est pas accepté car aucun ne finit en $3$
\end{example}

Un tel automate a l'avantage de reconnaître très clairement le langage $\Sigma^*aba\Sigma^*$. On peut par exemple le comparer à sa version déterministe qui, malgré la simplicité du langage, perd déjà pas mal en lisibilité :

\begin{figure}[!ht]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.9cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


  \node[initial,state] (0)                    {$0$};
  \node[state] (1)      [right of=0]                {$1$};  
  \node[state] (2)      [right of=1]                {$2$};
  \node[accepting,state] (3)      [right of=2]                {$3$};

  \path %(I) edge[loop above]              node {$a,b$} (I)
(0) edge      [loop above]        node {$b$} (0)
(0) edge      []        node {$a$} (1)
(1) edge      [loop above]        node {$a$} (1)
(1) edge      []        node {$b$} (2)
(2) edge      []        node {$a$} (3)
(2) edge      [bend left]        node {$b$} (0)
(3) edge      [loop above]        node {$a,b$} (3);
\end{tikzpicture}
\end{figure}

La grande différence entre les deux automates est que le premier utilise le non-déterminisme pour être une transcription directe de la \textit{regex}, là où le deuxième se bat avec le déterminisme pour reconnaître le langage de façon presque "accidentelle". En un sens, on est passé du domaine de la \textbf{spécification} à l'\textbf{implémentation}. La mauvaise nouvelle, c'est que les automates non-déterministes sont plus compliqués à mettre en pratique, du fait - ô surprise - du non-déterminisme, qui impose de tester énormément de chemins. La bonne nouvelle, c'est que, comme on va le voir en \ref{det}, on peut traduire automatiquement les automates non-déterministes en automates déterministes équivalents\footnote{Pour se rendre compte du miracle que c'est, on peut comparer aux langages de programmation classiques. Ce n'est pas parce qu'on a spécifié formellement, par exemple, le tri d'une liste (ce qui est déjà surprenamment non-trivial) qu'on peut automatiquement obtenir un programme réalisant cette tâche. Même une fois qu'on a codé un tel programme, selon l'algorithme chopisi, il n'est pas forcément aisé de se convaincre qu'il est correct, et encore moins de le prouver formellement. Il est donc assez \textit{cool} que tout ce passage de la spécification (la \textit{regex}) à une représentation intermédiaire (l'automate non-déterministe) à l'implémentation (le déterministe) soit automatique et sûre.}, avec bien sûr un certain coût. Mais avant de plonger dans ces histoires, on va voir encore quelques exemples d'AFND, et en étudier la formalisation.

\begin{example}
\label{incomptoo}
On veut reconnaître le langage des mots qui contiennent le facteur $aba$ ou (inclusif) $bab$. On peut exploiter la possibilité d'avoir plusieurs états initiaux, et tout simplement produire l'automate suivant :

\begin{figure}[!ht]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.9cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


  \node[initial,state] (0)                    {$0$};
  \node[state] (1)      [right of=0]                {$1$};  
  \node[state] (2)      [right of=1]                {$2$};
  \node[accepting,state] (3)      [right of=2]                {$3$};

  \node[initial,state] (4)  [below of=0]            {$4$};
  \node[state] (5)      [right of=4]                {$5$};  
  \node[state] (6)      [right of=5]                {$6$};
  \node[accepting,state] (7)      [right of=6]                {$7$};

  \path %(I) edge[loop above]              node {$a,b$} (I)
(0) edge      [loop above]        node {$a,b$} (0)
(0) edge      []        node {$a$} (1)
(1) edge      []        node {$b$} (2)
(2) edge      []        node {$a$} (3)
(3) edge      [loop above]        node {$a,b$} (3)
(4) edge      [loop above]        node {$a,b$} (4)
(4) edge      []        node {$b$} (5)
(5) edge      []        node {$a$} (6)
(6) edge      []        node {$b$} (7)
(7) edge      [loop above]        node {$a,b$} (7);

\end{tikzpicture}
\end{figure}

On notera bien sûr la symétrie entre l'automate ci-dessus, et la regex $\Sigma^*aba\Sigma^* + \Sigma^*bab\Sigma^*$.

On peut aussi tenter d'être un poil plus malin, se rendre compte que les états $0$ et $4$ ont le même \textbf{rôle}, que les états $3$ et $7$ aussi, et donc qu'on peut réduire le nombre d'états en les fusionnant :


\begin{figure}[!ht]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.9cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


  \node[initial,state] (0)                    {$0/4$};
  \node[state] (1)      [above right of=0]                {$1$};  
  \node[state] (2)      [right of=1]                {$2$};
  \node[state] (3)      [below right of=0]                {$5$};  
  \node[state] (4)      [right of=3]                {$6$};
  \node[accepting,state] (5)      [below right of=2]                {$3/7$};

  \path %(I) edge[loop above]              node {$a,b$} (I)
(0) edge      [loop right]        node {$a,b$} (0)
(0) edge      []        node {$a$} (1)
(0) edge      []        node {$b$} (3)
(1) edge      []        node {$b$} (2)
(3) edge      []        node {$a$} (4)
(2) edge      []        node {$a$} (5)
(4) edge      []        node {$b$} (5)
(5) edge      [loop right]        node {$a,b$} (5);

\end{tikzpicture}
\end{figure}
\newpage
Cette notion d'états équivalents et fusionnables sera formalisée en \ref{minim}. On remarquera (à nouveau) la symétrie entre cet automate et la regex $\Sigma^*(aba+bab)\Sigma^*$.

\end{example}

\begin{exercice}
Donner une \textit{regex} et un automate fini pour le langage $L = \{w ~|~ aba$ est un sous-mot de $w\}$.
\end{exercice}


\begin{exercice}
Donner une \textit{regex} et un automate fini pour le langage des mots qui commencent par $ab$ et finissent par $ba$.
\end{exercice}

\subsection{Formalisation et implémentation}

Les automates non-déterministes sont une généralisation\footnote{En effet, un AFD peut-être vu comme un AFND qui se trouve être ... déterministe. Rien dans la définition d'un AFND n'impose que le non-déterminisme permis par le changement de type de $\delta$ soit exploité, et on peut donc très bien avoir $|\delta(q,c)| \leq 1~\forall q \in Q$ et $\forall c \in \Sigma$.} des automates déterministes, où
 
\begin{itemize}
\item L'état initial $q_0$ est remplacé par un ensemble d'états initiaux $I \subseteq Q$
\item La fonction de transition $\delta$ change de type, en passant de $(Q \times \Sigma) \rightarrow Q$ à $(Q \times \Sigma) \rightarrow P(Q)$\footnote{Pour rappel, $P(Q)$ est l'ensemble des sous-parties de $Q$, cad. l'ensemble des ensembles d'états, cf \ref{powerset}.}. Dit autrement, étant donnés un état $q \in Q$ et une lettre $c \in \Sigma$, on a (potentiellement) \textit{accès} à un ensemble d'états plutôt qu'à un seul.
\end{itemize}


Puisqu'on a changé le type $\delta$, on doit également changer son \textit{lift} $\delta^*$, qui renvoie maintenant un ensemble d'états et est donc de type $(Q \times \Sigma^*) \rightarrow P(Q)$ :
 
\begin{itemize}
\item $\delta^*(q,\epsilon) = \{q\}$
\item $\delta^*(q,a.w) = \bigcup_{q' \in \delta(q,a)} \delta^*(q',w)$
\end{itemize}

Il nous reste à vérifier que l'ensemble d'états atteignales contient un état terminal. Un AFND accepte donc un mot $w$ ssi. $\exists q \in ((\bigcup_{q_i \in I} \delta^*(q_i,w)) \cap F)$.

Pour ce qui est de la mise en application de $\delta^*$, on est cette fois face à un parcours d'arbres (l'ensemble des chemins) plutôt que d'une liste, comme dans la version déterministe. On adapte donc l'annexe \ref{itersif} :

\begin{figure}[!ht]
\begin{python}
# fonction ndfa_acc(auto,w)
# renvoie true ssi. l automate auto accepte le mot w
todo = stack()
// On va empiler des couples etat x mot qu il faut tester
// On commence par se noter tous les etats initiaux
for i in initial(auto):
    todo.add(i,w)
while (todo pas vide):
    (q,mot) = todo.pop()
    // Si on a fini de lire le mot et qu on est
    // arrive sur un etat final, on accepte
    // Si l etat n est pas final, on ne renvoie
    // pas false, car il peut rester des chemins
    // qu il faut tester
    if mot is empty et q in F:
        return true 
    elif mot is a.reste:
        // On continue la lecture du mot avec 
        // chaque etat qu on peut atteindre
        // avec la premiere lettre
        next_states = delta(q,a)
        for suivant in next_states:
            todo.add(suivant,reste)
// Si on n a au final rien trouve, on dit non
return false
\end{python}
\caption{Reconnaissance par un AFND - version iterative}
%\label{treeit}
\end{figure}

\begin{figure}[!ht]
\begin{python}
# fonction ndfa_acc_bis(auto,w,q)
# renvoie true ssi. l automate auto accepte le mot w en partant de l etat q
if w is empty:
    return q in F
elif w is a.reste:
    for suivant in delta(q,a):
        if ndfa_acc_bis(auto,reste,suivant):
            return true
    return false


# fonction ndfa_acc(auto,w)
# renvoie true ssi. l automate auto accepte le mot w
for i in initial(auto):
    if ndfa_acc_bis(auto,w,i):
        return true
return false
\end{python}
\caption{Reconnaissance par un AFND - version récursive}
%\label{treerec}
\end{figure}
\newpage

\section{Transformation d'automates}
\label{transauto}


La formalisation très limitée et simple des automates en fait des programmes particulièrement simple à manipuler, comme l'illustrent les algorithmes de transformation d'automates présentés ici.

\subsection{Complétion}


On peut facilement compléter un automate en rajoutant un état "poubelle", non terminal et bouclant, qui absorbera tous les transitions ajoutées.

\begin{example}
Si on complète l'automate de la figure \ref{incompauto}, on rajoute un état $P$ qui boucle sur lui-même. Il manquait dans l'automate uniquement une $b$-transition partant de l'état $1$. On rajoute donc $1 \xrightarrow{b} P$, et on obtient 

\begin{figure}[!h]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.9cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


  \node[initial,state] (A)                    {$0$};
  \node[state] (B)      [right of=A]                {$1$};
  \node[state] (P)      [below of=B]                {$P$};
  \node[accepting,state] (C)      [right of=B]                {$2$};

  \path %(I) edge[loop above]              node {$a,b$} (I)
(A) edge      [loop above]        node {$b$} (A)
(C) edge      [loop above]        node {$a,b$} (C)
(A) edge      []        node {$a$} (B)
(B) edge      []        node {$b$} (P)
(P) edge      [loop left]        node {$a,b$} (P)
(B) edge      []        node {$a$} (C);
\end{tikzpicture}
\caption{Un automate complété}
\label{incompautocor}
\end{figure}
\end{example}

\begin{exercice}
Compléter le premier automate de l'exemple \ref{incomptoo}.
\end{exercice}

On peut se convaincre assez facilement que la complétion ne change pas le langage reconnu par un automate : un parcours prend de nouvelles transitions ssi. il ne pouvait aller jusqu'au bout dans l'automate initial. Dans les deux cas, le mot associé n'est pas accepté, puisqu'on boucle sur un état non-terminal dans le premier cas, et on "plante" dans le second.

Cette transformation se formalise également assez facilement. Soit un automate déterministe $\big \langle Q,\Sigma,q_0,F,\delta \big \rangle$, alors on renvoie l'AFD $\big \langle Q \cup~\{P\},\Sigma,q_0,F,\delta' \big \rangle$, avec

\[
\begin{cases}
\delta'(q,a) = \delta(q,a) &\text{ si } \delta(q,a) \text{ défini},\\[1ex]
\delta'(q,a) = P &\text{ si } \delta(q,a) \text{ non défini},\\[1ex]
\delta'(P,a) = P &\text{ pour tout } a \in \Sigma  \end{cases}
\]

Notez qu'on met les cas $\delta'(P,a)$ à part, car (on suppose) $P \not\in Q$, ce qui implique que $\delta(P,a)$ n'a pas de sens.

\begin{exercice}
Donner la formalisation de la complétion d'un automate non-déterministe.
\end{exercice}

\subsection{Déterminisation}
\label{det}

L'algorithme présenté ici prend en entrée un AFND et renvoie un AFD reconnaissant le même langage. L'idée est que l'AFD va simuler le comportement de l'AFND, et donc, étant donné un mot, que le (seul) parcours dans l'AFD va représenter tous ceux dans l'AFND.

Pour ça, l'ensemble d'états de l'AFD va être l'ensemble des combinaisons d'états de l'AFND. Par exemple, si on a dans ce derniers deux états initiaux $i_1$ et $i_2$, l'automate initial de l'AFD sera l'état $\{i_1, i_2\}$. Supposons de plus que les transitions partant de $i_1$ et $i_2$ sont les suivantes :

\begin{itemize}
\item $i_1 \xrightarrow{a} q_1$
\item $i_1 \xrightarrow{a} q_2$
\item $i_2 \xrightarrow{a} q_1$
\item $i_2 \xrightarrow{a} q_3$
\end{itemize}

Tout mot commençant par $a$ lu par l'AFND peut donc faire son premier saut en $q_1$, $q_2$ ou $q_3$. On ajoute donc à l'AFD la transition $\{i_1,i_2\} \xrightarrow{a} \{q_1, q_2, q_3\}$, et ainsi de suite.

Arriver, après lecture d'un mot, dans un état $X$ de l'AFD signifie donc que, dans l'AFND, on peut atterir dans chacun des états contenus dans $X$ après la lecture du même mot. Puisqu'un AFND accepte quand au moins un des parcours termine sur un état terminal, tout état de l'AFD contenant un état terminal est lui-même terminal. 

\begin{example}
\label{detex1}
Si on essaye de déterminiser l'automate de l'exemple \ref{exnondet1}, on obtient

\begin{figure}[!ht]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.9cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


  \node[initial,state] (0)                    {$0$};
  \node[state] (1)      [right of=0]                {$0,1$};  
  \node[state] (2)      [right of=1]                {$0,2$};
  \node[accepting,state] (3)      [right of=2]                {$0,1,3$};
  \node[accepting,state] (4)      [right of=3]                {$0,2,3$};
  \node[accepting,state] (5)      [below of=4]                {$0,3$};

  \path %(I) edge[loop above]              node {$a,b$} (I)
(0) edge      [loop above]        node {$b$} (0)
(0) edge      []        node {$a$} (1)
(1) edge      [loop above]        node {$a$} (1)
(1) edge      []        node {$b$} (2)
(2) edge      [bend left]        node {$b$} (0)
(2) edge      []        node {$a$} (3)
(3) edge      [loop above]        node {$a$} (3)
(3) edge      []        node {$b$} (4)
(4) edge      [bend left]        node {$a$} (3)
(4) edge      []        node {$b$} (5)
(5) edge      [loop right]        node {$b$} (3)
(5) edge      []        node {$a$} (3);
\end{tikzpicture}
\end{figure}

On notera une grande proximité avec la déterminisation "à la main" qu'on avait initialement faite dans l'exemple. En effet, on a les correspondances suivantes entre les états :

\begin{itemize}
\item $0 \approx 0$
\item $1 \approx 0,1$
\item $2 \approx 0,2$
\item $3 \approx 0,1,3 + 0,2,3 + 0,3$
\end{itemize}
\end{example}

\begin{exercice}
Déterminiser le premier automate de l'exemple \ref{incomptoo}. (la correction de cet exercice contient, contrairement à l'exemple ci-dessus, quelques étapes intermédiaires).
\end{exercice}

La déterminisation se formalise aussi assez bien en termes de définitions. Soit un automate $\big \langle Q,\Sigma,I,F,\delta \big \rangle$, alors on renvoie l'automate $\big \langle P(Q),\Sigma,\bigcup_{i \in I} i,F',\delta' \big \rangle$, avec

\[
\delta'(X,a) = \bigcup_{q \in X} \delta(q,a)
\]

\[
F' = \{X \in P(Q) ~|~ X~\cap~F \neq \emptyset\}
\]

Notez que suivre cette définition génère un automate qui contient tout un tas d'états qui vont être inatteignables, et donc ne servir à rien. En l'appliquant sur l'exemple \ref{detex1}, on devrait notamment produire les états $\{1,2\}$ ou $\{2,3\}$. En pratique, on préfèrera donc suivre l'algorithme présenté avec les mains, qui consiste à partir de l'état initial et d'ajouter les états / transitions au fur à mesure, jusqu'à atteindre un point fixe.

Il s'agit d'un résultat extrêmement important de la théorie des automates, puisqu'il établit l'équivalence entre automates finis déterministes et non-déterministes. Pour montrer qu'un langage est reconnaissable par un AFD, on pourra se contenter de fournir un AFND. D'un point de vue plus pratique, on pourra abondamment utiliser le non-déterminisme dans nos conceptions d'automates, ce dernier pouvant être éliminé par cet algorithme. Cette transformation a cependant un coût, qui peut être très élevé. En effet, le lemme \ref{cardpowerset} implique que la déterminisation d'un automate à $n$ états peut en avoir jusqu'à $2^n$.

On peut commencer à voir pourquoi en re-regardant l'exemple \ref{detex1}, où on a 3 états terminaux alors qu'un seul serait suffisant : une fois qu'on a atteint l'état $\{0,1,3\}$, on ne fait que tourner entre trois états terminaux, ce qui veut dire que n'importe quel (reste de) mot sera accepté. L'algorithme de déterminisation ne s'intéresse pas au rôle des états (il est \textbf{syntaxique}, et non \textbf{sémantique}), et ne voit donc pas qu'une fusion est ici possible. De telles optimisations vont cependant nous être fournies par le prochain algorithme.


\subsection{Minimisation}
\label{minim}

On a dit dans l'exemple \ref{detex1} que plusieurs états avaient le même rôle et pouvaient être fusionnés. On va ici présenter un algorithme qui prend en entrée un automate déterministe complet\footnote{Ce qui, grâce aux deux algorithmes précédents, sont des hypothèses gratuites.} et en classe les états selon leur rôle, ce qui permet ensuite de fusionner à l'intérieur de chaque classe. On obtient alors un automate reconnaissant le même langage que celui en entrée, mais de façon minimale (par rapport au nombre d'états). On va présenter l'algorithme \textit{via} l'exemple suivant :

\begin{example}

Soit l'automate suivant :



\begin{figure}[!ht]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.9cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


  \node[initial,state] (0)                    {$0$};
  \node[state] (1)      [above right of=0]                {$1$};  
  \node[state] (2)      [right of=0]                {$2$};   
  \node[state] (3)      [below right of=0]                {$3$};    
  \node[state,accepting] (4)      [right of=3]                {$4$};  


  \path %(I) edge[loop above]              node {$a,b$} (I)
(0) edge      []        node {$a$} (1)
(0) edge      [loop below]        node {$b$} (0)
(1) edge      [bend right]        node {$b$} (2)
(1) edge      [bend right]        node {$a$} (3)
(2) edge      []        node {$a$} (3)
(2) edge      [bend right]        node {$b$} (1)
(3) edge      [loop below]        node {$b$} (3)
(3) edge      []        node {$a$} (4)
(4) edge      [loop right]        node {$a,b$} (4);
\end{tikzpicture}
\end{figure}


On disait plus haut qu'on veut regrouper les états selon leur rôle. Le rôle d'un état $q$ est l'ensemble des mots qu'il accepte, cad. l'ensemble des mots qui vont de $q$ à un état terminal, ou $\{w ~|~ \delta^*(q,w) \in F\}$. On va partir d'un regroupement très approximatif, et affiner petit à petit. 

Pour commencer, on peut séparer les états terminaux des non-terminaux en deux sous-ensembles, ou classes. En effet, les premiers acceptent le mot $\epsilon$ alors que les seconds non. On divise donc notre ensemble d'états en $T = \{4\}$ et $N = \{0,1,2,3\}$. On ne va manifestement pas pouvoir affiner $T$, contrairement à $N$. Pour ça, on va regarder toutes les paires d'états de $N$ et, à chaque fois, vérifier si les deux états ont des désaccords en lisant $a$ ou $b$ :

\begin{itemize}
\item 0 vs. 1
\begin{itemize}
\item $\delta(0,a) = 1$ et $\delta(1,a) = 3$. Pour l'instant, $1$ et $3$ appartiennent tous les deux à $N$, ce qui veut dire qu'on suppose que $1$ accepte un mot $w$ ssi. $3$ accepte $w$. On peut donc conclure que, de ce qu'on sait, $0$ accepte un mot $a.w$ ssi. $1$ accepte $a.w$.
\item $\delta(0,b) = 0$ et $\delta(1,b) = 2$. $0$ et $2$ appartiennent à la même classe, on suppose donc pour l'instant que $0$ accepte un mot $b.w$ ssi. $1$ accepte un mot $b.w$.
\item[$\Rightarrow$] Pour l'instant, on conserve notre hypothèse selon laquelle $0$ et $1$ acceptent le même langage.
\end{itemize}
\item 0 vs. 2
\begin{itemize}
\item $\delta(0,a) = 1$ et $\delta(2,a) = 3$, $1$ et $3$ sont dans la même classe.
\item $\delta(0,b) = 0$ et $\delta(2,b) = 2$. $0$ et $2$ appartiennent à la même classe.
\item[$\Rightarrow$] Pour l'instant, on conserve notre hypothèse selon laquelle $0$ et $2$ acceptent le même langage.
\end{itemize}
\item 0 vs. 3
\begin{itemize}
\item $\delta(0,a) = 1$ et $\delta(3,a) = 4$, $1$ et $4$ ne sont pas dans la même classe, ce qui veut dire qu'il existe un mot $w$\footnote{En l'occurrence $\epsilon$, mais savoir quel mot exactement n'a pas d'importance.} sur lequel $1$ et $4$ ne sont pas d'accord, dans le sens où $1$ accepte $w$ alors que $4$ non, ou l'inverse. On en déduit donc que $0$ et $3$ sont en désaccord sur $a.w$. Puisqu'ils sont en désaccord, ils ne devraient pas être dans la même classe.
\item[$\Rightarrow$] Pas besoin de tester avec $b$, on sait déjà qu'on va séparer $0$ et $3$.
\end{itemize}
\item 1 vs. 2
\begin{itemize}
\item $\delta(1,a) = 3$ et $\delta(2,a) = 3$, pas de souci.
\item $\delta(1,b) = 2$ et $\delta(2,b) = 1$, idem.
\item[$\Rightarrow$] On garde $1$ et $2$ dans la même classe.
\end{itemize}
\item 1 vs. 3
\begin{itemize}
\item $\delta(1,a) = 3$ et $\delta(3,a) = 4$. 
\item[$\Rightarrow$] $3$ et $4$ ne sont pas dans la même classe, on doit donc séparer $1$ et $3$.
\end{itemize}
\item 2 vs. 3
\begin{itemize}
\item $\delta(2,a) = 3$ et $\delta(3,a) = 4$.
\item[$\Rightarrow$] $3$ et $4$ ne sont pas dans la même classe, on doit donc les séparer.
\end{itemize}
\end{itemize}

Si on résume ce premier tour de manège, $3$ est en désaccord avec $0$, $1$ et $2$, mais ces trois restent compatibles. On divise donc $N$ entre $N_1 = \{0,1,2\}$ et $N_2 = \{3\}$. Puisqu'on a scindé une classe en deux, les résultats de certains "duels" peuvent avoir changé. On refait donc une passe sur $N_1$ :

\begin{itemize}
\item 0 vs. 1
\begin{itemize}
\item $\delta(0,a) = 1$ et $\delta(1,a) = 3$. 
\item[$\Rightarrow$] $1$ et $3$ étant maintenant dans des classes différentes, on doit séparer $0$ et $1$.
\end{itemize}
\item 0 vs. 2
\begin{itemize}
\item $\delta(0,a) = 1$ et $\delta(2,a) = 3$. 
\item[$\Rightarrow$] Idem, on doit donc séparer $0$ et $2$.
\end{itemize}
\item 1 vs. 2
\begin{itemize}
\item $\delta(1,a) = 3$ et $\delta(2,a) = 3$. 
\item $\delta(1,b) = 2$ et $\delta(2,b) = 1$. 
\item[$\Rightarrow$] On ne sépare toujours pas $1$ et $2$.
\end{itemize}
\end{itemize}


On a donc séparé $N_1$ en $N_2 = \{0\}$ et $N_3 = \{1,2\}$. Maintenant qu'on a eu une nouvelle séparation, on doit re-tester $1$ et $2$ :

\begin{itemize}
\item 1 vs. 2
\begin{itemize}
\item $\delta(1,a) = 3$ et $\delta(2,a) = 3$. 
\item $\delta(1,b) = 2$ et $\delta(2,b) = 1$. 
\item[$\Rightarrow$] On ne sépare toujours pas $1$ et $2$.
\end{itemize}
\end{itemize}


Pour résumer la série des séparations :

\begin{center}
\Tree[.{$\{0,1,2,3,4\}$} [.{$\{0,1,2,3\}$} [.{$\{3\}$}  ] [.{$\{0,1,2\}$} [.{$\{0\}$}  ] [.{$\{1,2\}$}  ] ] ] [.{$\{4\}$}  ] ]
\end{center}


On peut maintenant s'amuser à répéter l'expérience autant de fois qu'on veut, mais à partir du moment où il y a eu un tour sans changement, il n'y en aura plus jamais. On accepte alors l'hypothèse selon laquelle $1$ et $2$ appartiennent à la même classe, ont donc le même rôle et peuvent être fusionnés. On introduit donc un état $1,2$. L'état $0$ menait initialement avec $a$ à l'état $1$, il pointe donc maintenant vers $1,2$. $1$ et $2$ menaient l'un vers l'autre, ça devient une boucle en $b$ sur $1,2$. Enfin, $1,2$ mène avec $a$ vers $3$. $1$ et $2$ n'étaient pas terminaux, $1,2$ ne l'est donc pas non plus :



\begin{figure}[!ht]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.9cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


  \node[initial,state] (0)                    {$0$};
  \node[state] (2)      [right of=0]                {$1,2$};   
  \node[state] (3)      [below right of=0]                {$3$};    
  \node[state,accepting] (4)      [right of=3]                {$4$};  


  \path %(I) edge[loop above]              node {$a,b$} (I)
(0) edge      []        node {$a$} (2)
(0) edge      [loop below]        node {$b$} (0)
(2) edge      [loop right]        node {$b$} (2)
(2) edge      []        node {$a$} (3)
(3) edge      [loop below]        node {$b$} (3)
(3) edge      []        node {$a$} (4)
(4) edge      [loop right]        node {$a,b$} (4);
\end{tikzpicture}
\end{figure}

\end{example}

\paragraph*{Remarque} A la fin de l'exemple, on a justifié de façon un peu rapide et légère l'arrêt de l'algorithme. On n'entrera pas dans les détails ici, mais on donnera l'idée pour que le lecteur ou la lectrice intéressé.e ait matière à réfléchir : l'algorithme présenté ici revient à tester - de façon efficace - les différences d'acceptation entre paires d'états pour les mots de longueur $0$, puis $1$, puis $2$, etc, jusqu'à atteindre un point fixe. Si on n'a pas de changement (ie. de séparation dans une classe) entre les mots de longueur $n$ et $n+1$, on sait que la stabilité va se propager à l'infini. En effet, soient $q_1$ et $q_2$ qui appartiennent à la même classe, et $w$ un mot de longueur $n+1$. $\delta(q_1,a)$ et $\delta(q_2,a)$ vont dans des états $q_1'$ et $q_2'$ qui appartiennent à la même classe, ce qui veut dire qu'aucun mot de longueur $\leq n+1$ ne peut les séparer. Alors $\delta^*(q_1,a.w) = \delta^*(q_1',w)$ et $\delta^*(q_2,a.w) = \delta^*(q_2',w)$ sont d'accord, et idem avec $b$. $q_1$ et $q_2$ sont donc d'accord sur les mots de longueur $n+2$. On peut itérer, ce qui implique qu'ils sont d'accord sur les mots de n'importe quelle longueur, et sont donc équivalents. 

\paragraph*{Remarque bis} On peut accélérer l'utilisation de cet algorithme en remarquant que la relation "être d'accord" est \textbf{transitive} : étant donnée une partition des états, si $q_1$ et $q_2$ sont d'accord d'une part, et $q_2$ et $q_3$ le sont d'autre part, alors $q_1$ et $q_3$ le sont également. De même, si $q_1$ et $q_2$ sont d'accord et que $q_2$ n'est pas d'accord avec $q_3$, alors ce dernier ne l'est pas avec $q_1$. On va donc pouvoir s'épargner pas mal de vérifications, comme illustré dans les corrections des deux exercices suivant.

\begin{exercice}
Minimiser (en utilisant l'algorithme) l'automate de l'exemple \ref{detex1}.
\end{exercice}


\begin{exercice}

Minimiser l'automate suivant :

\begin{figure}[!ht]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.9cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


  \node[initial,state] (0)                    {$0$};
  \node[state] (1)      [above right of=0]                {$1$};  
  \node[state] (2)      [below right of=0]                {$2$};   
  \node[state] (3)      [right of=0]                {$3$};    
  \node[state] (4)      [right of=1]                {$4$};  
  \node[state] (5)      [right of=2]                {$5$};   
  \node[state] (6)      [right of=3]                {$6$};   
  \node[state] (8)      [above of=6]                {$8$};   
  \node[state,accepting] (7)      [right of=6]                {$7$}; 

  \path %(I) edge[loop above]              node {$a,b$} (I)
(0) edge      []        node {$a$} (1)
(0) edge      []        node {$b$} (2)
(1) edge      []        node {$b$} (4)
(1) edge      []        node {$a$} (3)
(2) edge      []        node {$a$} (3)
(2) edge      []        node {$b$} (5)
(3) edge      []        node {$a,b$} (6)
(4) edge      []        node {$a$} (8)
(4) edge      []        node {$b$} (6)
(5) edge      []        node {$a,b$} (6)
(6) edge      [loop below]        node {$a$} (6)
(6) edge      []        node {$b$} (7)
(7) edge      [loop right]        node {$b$} (7)
(7) edge      [bend left]        node {$a$} (6)
(8) edge      []        node {$a$} (6)
(8) edge      []        node {$b$} (7);
\end{tikzpicture}
\end{figure}

\end{exercice}

\section{Limite de la reconnaissance par automates finis}

On s'est jusqu'ici amusé à écrire des automates qui reconnaissent tel ou tel langage, sans jamais faillir. Le théorème suivant va être notre premier échec.

\begin{theorem}
\label{anbn}
Il n'existe pas d'automate fini reconnaissant le langage $L = \{a^nb^n~|~n \in \mathbb{N}\}$

\end{theorem}

\begin{proof}
On va procéder par l'absurde (voir \ref{abs}), et donc supposer qu'il existe un automate fini $A$ reconnaissant $L$. Grâce aux algorithmes vus précédemment, on peut supposer que $A$ est déterministe et complet (puisque s'il ne l'est pas, on peut en générer un qui l'est et reconnaît également $L$).

L'ensemble d'états de $A$, appelé $Q$, est par définition fini, de cardinal $|Q|$. $L$ contient tous les mots de la forme $a^nb^n$, et notamment $a^{|Q|}b^{|Q|}$. Il existe donc dans $A$ un chemin 

\[
q_0 \xrightarrow{a} q_1 \xrightarrow{a} ... \xrightarrow{a} q_{|Q|} \xrightarrow{b} q_{|Q|+1} \xrightarrow{b} ... \xrightarrow{b} q_{2|Q|}
\]

dans $A$, avec $q_0$ initial et $q_{2|Q|}$ terminal. On note que, en lisant les $a$, on parcourt $|Q|+1$ états. D'après le \href{https://fr.wikipedia.org/wiki/Principe_des_tiroirs}{principe des tiroirs (à chaussettes)}, au moins un état est visité deux fois. On a donc $i$ et $j$ tels que $0 \leq i < j \leq |Q|$ et $q_i = q_j$. $A$ accepte alors le mot $a^{|Q|-(j-i)}b^{|Q|}$ via le chemin

\[
q_0 \xrightarrow{a} q_1 \xrightarrow{a} ... \xrightarrow{a} q_{i} \xrightarrow{a} q_{j+1} \xrightarrow{a} ... \xrightarrow{a} q_{|Q|} \xrightarrow{b} q_{|Q|+1} \xrightarrow{b} ... \xrightarrow{b} q_{2|Q|}
\]

Autrement dit, on a dans la lecture de $a^{|Q|}b^{|Q|}$ une lecture dans le passage sur les $a$, et on peut obtenir une nouvelle lecture en retirant le contenu de la boucle (la partie entre $i$ et $j$). Visuellement, ça ressemble au passage de 

\hspace{-1.5cm}
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=1cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]

    \node[state,initial] (0) {$q_0$};
      \node        (dots) [right=of 0] {$\cdots$}; 
    \node[state] (ij) [right=of dots] {$q_i = q_j$};
    \node[state] (i1) [above right=of ij] {$q_{i+1}$};    
    \node (ii) [above= 2cm of ij] {$\cdots$};    
    \node[state] (i2) [above left= of ij] {$q_{j-1}$};    
    \node[state] (j1) [right=of ij] {$q_{j+1}$};    
    \node        (bdots) [right=of j1] {$\cdots$}; 
    \node[state] (q) [right=of bdots] {$q_{|Q|}$}; 
    \node[state] (q1) [right=of q] {$q_{|Q|+1}$};    
    \node        (cdots) [right=of q1] {$\cdots$}; 
    \node[state,accepting] (qf) [right=of cdots] {$q_{2|Q|}$};    

    \path
    (0) edge node {a} (dots)  
    (dots) edge node {a} (ij) 
    (ij) edge node {a} (i1) 
    (i1) edge node {a} (ii) 
    (ii) edge  node {a} (i2) 
    (i2) edge node {a} (ij)  
    (ij) edge node {a} (j1) 
    (j1) edge node {a} (bdots) 
    (bdots) edge node {a} (q) 
    (q) edge  node {b} (q1) 
    (q1) edge  node {b} (cdots)
    (cdots) edge  node {b} (qf)
    ; %end path 

\end{tikzpicture} 

à

\hspace{-1,5cm}
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=1cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]

    \node[state,initial] (0) {$q_0$};
      \node        (dots) [right=of 0] {$\cdots$}; 
    \node[state] (ij) [right=of dots] {$q_i = q_j$};
    \node[state] (j1) [right=of ij] {$q_{j+1}$};    
    \node        (bdots) [right=of j1] {$\cdots$}; 
    \node[state] (q) [right=of bdots] {$q_{|Q|}$}; 
    \node[state] (q1) [right=of q] {$q_{|Q|+1}$};    
    \node        (cdots) [right=of q1] {$\cdots$}; 
    \node[state,accepting] (qf) [right=of cdots] {$q_{2|Q|}$};    

    \path
    (0) edge node {a} (dots)  
    (dots) edge node {a} (ij) 
    (ij) edge node {a} (j1) 
    (j1) edge node {a} (bdots) 
    (bdots) edge node {a} (q) 
    (q) edge  node {b} (q1) 
    (q1) edge  node {b} (cdots)
    (cdots) edge  node {b} (qf)
    ; %end path 

\end{tikzpicture} 


Or, le mot maintenant lu, $a^{|Q|-(j-i)}b^{|Q|}$, n'appartient pas au langage reconnu par l'automate. On obtient donc un paradoxe, ce qui veut dire que l'automate $A$ n'existait pas en premier lieu.
\end{proof}

Au-delà de la preuve, comment expliquer l'impossibilité pour un automate fini de reconnaître ce langage ? On comparera à l'exemple \ref{exemplePI}, où on pouvait raisonner \textit{modulo}, sans retenir toute l'information (le nombre de $a$ et de $b$ lus) mais seulement une abstraction, simplifiée et finie (la parité du nombre de $a$ et de $b$). Ici, quand on commence a lire des $b$, on doit avoir enregistré le nombre précis de $a$ lus, pour vérifier qu'on en a bien le même nombre. Or, le nombre de $a$ n'est pas borné, et la seule mémoire disponible dans un automate est les états.

Si on avait le droit à une infinité d'états, on pourrait essayer d'écrire, de manière finie, un automate infini comme celui de la figure \ref{infini}. Le domaine des automates infinis existe bel et bien, mais n'est pas au programme de ce cours. On évoquera, dans la partie \ref{grammaires}, une autre approche consistant à ajouter aux automates une deuxième forme de mémoire, potentiellement infinie mais aisément représentable de manière finie.

\begin{figure}[H]
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=1cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]

    \node[state,initial,accepting] (0) {$0_a$};
    \node[state] (1) [right=of 0] {$1_a$};
    \node[state] (2) [right=of 1] {$2_a$};
    \node[state] (3) [right=of 2] {$3_a$};
    \node[state] (4) [right=of 3] {$4_a$};
      \node        (dots) [right=of 4] {$\cdots$}; 
    \node[state,accepting] (b0) [below=of 0] {$0_b$};
    \node[state] (b1) [right=of b0] {$1_b$};    
    \node[state] (b2) [right=of b1] {$2_b$};    
    \node[state] (b3) [right=of b2] {$3_b$};    
    \node[state] (b4) [right=of b3] {$4_b$};    
    \node        (bdots) [right=of b4] {$\cdots$}; 

    \path
    (0) edge node {a} (1)  
    (1) edge node {a} (2) 
    (2) edge node {a} (3) 
    (3) edge node {a} (4) 
    (4) edge  node {a} (dots) 
    (1) edge node {b} (b0) 
    (2) edge node {b} (b1) 
    (3) edge node {b} (b2) 
    (4) edge  node {b} (b3) 

    (bdots) edge  node {b} (b4) 
    (b4) edge  node {b} (b3) 
    (b3) edge  node {b} (b2) 
    (b2) edge  node {b} (b1) 
    (b1) edge  node {b} (b0) 

    ; %end path 

\end{tikzpicture}  
\caption{Un exemple d'automate infini}
\label{infini}
\end{figure}

\section{Propriétés de clôture des langages reconnus par automates}
\label{cloture}

On dit qu'un ensemble $E$ est clos sous une opération binaire $\circ$ si, pour tous éléments $x$ et $y$ de $E$, $x \circ y$ appartient également à $E$. Dit autrement, $E$ est clos sous $\circ$ ssi. l'application de $\circ$ à ses éléments ne fait pas sortir de l'ensemble. On va regarder ici si les langages reconnaissables par automate fini sont clos sous les opérations sur les langages.

\paragraph*{Remarque} Les trois premiers points de cette section se présentent plus simplement en utilisant les $\epsilon$-transitions. On renverra pour ça à la correction du DM correspondant.

\subsection{Union}

\begin{theorem}
Les langages reconnaissables par automate fini sont clos par union, i.e. pour tous langages $L_1$ et $L_2$ reconnaissables par automate fini, il existe un automate fini reconnaissant $L_1 \cup L_2$.
\end{theorem}

\begin{proof}

Si $L_1$ et $L_2$ sont reconnaissables par automate fini, il existe des automates $A_1$ et $A_2$ qui reconnaissent $L_1$ et $L_2$, respectivement. Pour plus de généralité, on va supposer $A_1$ et $A_2$ non-déterministes. $L_1 \cup L_2$ est reconnu par "$A_1$ et $A_2$ posés à côté l'un de l'autre". Plus formellement, soient $A_1 = \big \langle Q_1, \Sigma_1, \delta_1, I_1, F_1\big \rangle$ et $A_1 = \big \langle Q_2, \Sigma_2, \delta_2, I_2, F_2\big \rangle$, alors $L_1 \cup L_2$ est reconnu par $\big \langle Q_1 \cup Q_2, \Sigma_1 \cup \Sigma_2, \delta', I_1 \cup I_2, F_1 \cup F_2\big \rangle$ avec 

\[
\begin{cases}
\delta'(q,a) = \delta_1(q,a) &\text{ si } q \in Q_1,\\[1ex]
\delta'(q,a) = \delta_2(q,a) &\text{ si } q \in Q_2\end{cases}
\]

\end{proof}

C'est exactement l'astuce qui a été utilisée dans l'exemple \ref{incomptoo}, où on a effectivement "mis ensemble" deux automates.

\subsection{Concaténation}

\begin{theorem}
Les langages reconnaissables par automate fini sont clos par concaténation, i.e. pour tous langages $L_1$ et $L_2$ reconnaissables par automate fini, il existe un automate fini reconnaissant $L_1.L_2$.
\end{theorem}

\begin{proof}

Si $L_1$ et $L_2$ sont reconnaissables par automate fini, il existe des automates $A_1$ et $A_2$ qui reconnaissent $L_1$ et $L_2$, respectivement. On veut reconnaître $L_1.L_2 = \{u.v ~|~ u \in L_1 ~\wedge~v \in L_2\}$, l'astuce va être de mettre $A_1$ et $A_2$ l'un après l'autre en rajoutant des transitions pour que, à chaque fois qu'on finit de lire un mot $u$ accepté par $A_1$, au lieu d'accepter, on va en un état initial de $A_2$ en lire un deuxième $v$. La figure \ref{concatscheme} illustre schématiquement cette transformation sur un exemple.



\begin{figure*}[ht]
    \centering
    \begin{subfigure}[b]{0.5\textwidth}
        \centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=1cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]

    \node[state] (0) {$0$};
    \node[state] (1) [below=of 0] {$1$};
    \node[state] (2) [below=of 1] {$2$};
    \node[state,accepting] (3) [right=of 0] {$f_1$};
    \node[state,accepting] (4) [right=of 2] {$f_2$};
    \node[state] (5) [right=of 4] {$i_2$};
    \node[] (6) [above=of 3] {...};
    \node[] (8) [below=of 4] {...};
    \node[] (7) [right=of 5] {...};

    \path
    (0) edge node {a,b} (3)  
    (1) edge [pos=0.37] node {b} (3) 
    (2) edge [pos=0.15] node {b} (3) 
    (2) edge node {a} (4) 
    (5) edge node {a} (7) 
    (4) edge [bend right] node {b} (8) 
    (3) edge [] node {a,b} (6) 
    ; %end path 

\end{tikzpicture}  
\caption{Deux automates voisins isolés ...}
%\label{infini}
    \end{subfigure}%
    ~ 
    \begin{subfigure}[b]{0.5\textwidth}
        \centering
	\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=1cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]

    \node[state] (0) {$0$};
    \node[state] (1) [below=of 0] {$1$};
    \node[state] (2) [below=of 1] {$2$};
    \node[state] (3) [right=of 0] {$f_1$};
    \node[state] (4) [right=of 2] {$f_2$};
    \node[state] (5) [right=of 4] {$i_2$};
    \node[] (6) [above=of 3] {...};
    \node[] (8) [below=of 4] {...};
    \node[] (7) [right=of 5] {...};

    \path
    (0) edge node {a,b} (3)  
    (1) edge [pos=0.37] node {b} (3) 
    (2) edge [pos=0.15] node {b} (3) 
    (2) edge node {a} (4) 
    (5) edge node {a} (7) 
    (0) edge [bend left=20] node {a,b} (5) 
    (1) edge [bend left=20] node {b} (5) 
    (2) edge [bend left] node {a,b} (5) 
    (4) edge [bend right] node {b} (8) 
    (3) edge [] node {a,b} (6) 
    ; %end path 

\end{tikzpicture}  
\caption{maintenant reliés}
%\label{infini}
    \end{subfigure}
    \caption{Concaténation d'automates}
    \label{concatscheme}
\end{figure*}

\newpage

Soit un mot $w = u.v$ avec $u \in L_1$ et $v \in L_2$. $u$ étant accepté par $A_1$, sa lecture en partant d'un état initial nous amène en $f_1$ ou $f_2$. Dans la version transformée, $u$ seul n'est plus accepté, mais la lecture de sa dernière lettre nous envoie en $i_2$. Or, $v$ est accepté par $A_2$, ce qui veut dire qu'il va nous envoyer de $i_2$ à un état terminal de $A_2$.



Plus formellement, soient $A_1 = \big \langle Q_1, \Sigma_1, \delta_1, I_1, F_1\big \rangle$ et $A_1 = \big \langle Q_2, \Sigma_2, \delta_2, I_2, F_2\big \rangle$, alors $L_1.L_2$ est reconnu par $\big \langle Q_1 \cup Q_2, \Sigma_1 \cup \Sigma_2, \delta', I', F_2\big \rangle$ avec 

\[
\begin{cases}
\delta'(q,a) = \delta_1(q,a) &\text{ si } q \in Q_1 ~\wedge~\delta_1(q,a) \cap F_1 = \emptyset,\\[1ex]
\delta'(q,a) = \delta_1(q,a) \cup I_2 &\text{ si } q \in Q_1 ~\wedge~\delta_1(q,a) \cap F_1 \neq \emptyset,\\[1ex]
\delta'(q,a) = \delta_2(q,a) &\text{ si } q \in Q_2\end{cases}
\]

Ainsi, chaque fois qu'un état de $A_1$ mène à un état terminal du même automate, on rajoute une transition avec la même lettre vers tous les états initiaux de $A_2$. Les transitions de $A_2$ ne changent pas.

\[
\begin{cases}
I' = I_1 &\text{ si } A_1 \text{ n'accepte pas le mot vide},\\[1ex]
I' = I_1 \cup I_2&\text{ si } A_1 \text{ accepte pas le mot vide}
\end{cases}
\]

Si $A_1$ accepte le mot vide, on veut pouvoir considérer cette possibilité et commencer la lecture en $A_2$ directement. Sinon, on passe forcément par $A_1$. On peut vérifier facilement si un automate accepte ou non $\epsilon$ : c'est le cas ssi. au moins un de ses états initiaux est terminal. 

Pas besoin de faire attention pour les états terminaux : si $A_2$ accepte le mot vide, au moins un de ses états initiaux est terminal, ce qui veut dire que les transitions qu'on ajoute permettront d'accepter un mot de $L_1$.
\end{proof}

\begin{example}
Soient $L_1 = \{w ~|~|w|_a$ pair et $|w|_b$ impair$\}$ et $L_2 = \Sigma^*(aba+bab)\Sigma^*$. On peut reconnaître $L_1.L_2$ en combinant les automates des exemples \ref{exemplePI} et \ref{incomptoo}. Les états $PP$ et $II$ envoie dans un état terminal, avec $b$ et $a$ respectivement. On leur rajoute donc les mêmes transitions pour les états $0$ et $4$, et on rend ces derniers non-initiaux. On obtient au final :


\begin{figure}[H]
\hspace{-2cm}
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.9cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


  \node[initial,state] (PP)                    {$PP$};
  \node[state] (IP)      [above right of=PP]                {$IP$};  \node[state] (II)      [below right of=IP]                {$II$};
  \node[accepting,state] (PI)      [below right of=PP]                {$PI$};
  \node[state] (0) [above right=0.8cm and 2cm of II]                   {$0$};
  \node[state] (1)      [right of=0]                {$1$};  
  \node[state] (2)      [right of=1]                {$2$};
  \node[accepting,state] (3)      [right of=2]                {$3$};

  \node[state] (4)  [below of=0]            {$4$};
  \node[state] (5)      [right of=4]                {$5$};  
  \node[state] (6)      [right of=5]                {$6$};
  \node[accepting,state] (7)      [right of=6]                {$7$};


  \path %(I) edge[loop above]              node {$a,b$} (I)
(PP) edge      [bend right]        node {$a$} (IP)
(PP) edge      [bend right]        node {$b$} (PI)
(PP) edge      [bend left=90]        node {$b$} (0)
(PP) edge      [bend right=90]        node {$b$} (4)
(PI) edge      [bend right]        node {$a$} (II)
(PI) edge      [bend right]        node {$b$} (PP)
(IP) edge      [bend right]        node {$a$} (PP)
(IP) edge      [bend right]        node {$b$} (II)
(II) edge      [bend right]        node {$a$} (PI)
(II) edge      []        node {$a$} (0)
(II) edge      []        node {$a$} (4)
(II) edge      [bend right]        node {$b$} (IP)
(0) edge      [loop above]        node {$a,b$} (0)
(0) edge      []        node {$a$} (1)
(1) edge      []        node {$b$} (2)
(2) edge      []        node {$a$} (3)
(3) edge      [loop above]        node {$a,b$} (3)
(4) edge      [loop above]        node {$a,b$} (4)
(4) edge      []        node {$b$} (5)
(5) edge      []        node {$a$} (6)
(6) edge      []        node {$b$} (7)
(7) edge      [loop above]        node {$a,b$} (7);
;
\end{tikzpicture}
\end{figure}

Notez que si on avait pris pour $L_1$ le langage des mots avec un nombre pair de $a$ et de $b$, cad. avec $PP$ terminal, les états $0$ et $4$ seraient restés initiaux pour pouvoir accepter, par exemple, $aba$.

\end{example}

\subsection{Itération}


\begin{theorem}
Les langages reconnaissables par automate fini sont clos par concaténation, i.e. pour tout langage $L$ reconnaissable par automate fini, il existe un automate fini reconnaissant $L^*$.
\end{theorem}

\begin{proof}
TODO.
\end{proof}
%On veut reconnaître des mots de la forme $u_1.u_2...u_n$ avec $u_i \in L$ pour tout $i$. On ajoute un état spécial, $S$, qui sera le seul initial et terminal, et qui sera le début et la fin de tout tour de manège. La construction de l'automate ressemble ensuite à celle de la concaténation, en ce qu'on rajoute des transitions qui, quand on s'apprête à accéder à un état terminal, nous permettent également de revenir à $S$. Dualement, pour toute transition $q \xrightarrow{c} q'$ avec $q$ initial, on ajoute la transition $S \xrightarrow{c} q'$. Ainsi, en lisant la dernière lettre de $u_1$, on peut revenir dans un état initial pour lire $u_2$ et ainsi de suite.

%Plus formellement, soient $A = \big \langle Q, \Sigma, \delta, I, F\big \rangle$, alors $L^*$ est reconnu par $\big \langle Q \cup \{S\}, \Sigma, \delta', \{S\}, \{S\} \big \rangle$ avec 

%\[
%\begin{cases}
%\delta'(q,a) = \delta(q,a) &\text{ si } \delta(q,a) \cap F = \emptyset,\\[1ex]
%\delta'(q,a) = \delta(q,a) \cup \{S\} &\text{ si } \delta(q,a) \cap F \neq \emptyset,\\[1ex]
%\delta'(S,a) = \displaystyle\bigcup_{i \in I} \delta(i,a) & 
%\end{cases}
%\]

%\end{proof}

%\begin{example}
%\label{itex}
%Soit $L = \{w \in \Sigma^*~|~|w|_a$ pair et $|w|_b$ impair$\}$. $L^*$ est reconnu par l'automate suivant : 

%\begin{figure}[H]
%\centering
%\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=4cm,
%                    semithick]
%  \tikzstyle{every state}=[fill=white,text=black]
%  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


%  \node[state] (PP)                    {$PP$};
%  \node[state] (IP)      [above right of=PP]                {$IP$};  \node[state] (II)      [below right of=IP]                {$II$};
%  \node[state] (PI)      [below right of=PP]                {$PI$};
%  \node[initial,accepting,state] (S)      [above=2cm of PI]                {$S$};

%  \path %(I) edge[loop above]              node {$a,b$} (I)
%(PP) edge      [bend right]        node {$a$} (IP)
%(PP) edge      [bend right]        node {$b$} (PI)
%(PI) edge      [bend right]        node {$a$} (II)
%(PI) edge      [bend right=10]        node {$b$} (PP)
%(IP) edge      [bend right]        node {$a$} (PP)
%(IP) edge      [bend right]        node {$b$} (II)
%(II) edge      [bend right]        node {$a$} (PI)
%(II) edge      [bend right]        node {$b$} (IP)

%(II) edge      []        node {$a$} (S)
%(PP) edge      [bend right]        node {$b$} (S)
%(S) edge      []        node {$b$} (PI)
%(S) edge      []        node {$a$} (IP)

%;
%\end{tikzpicture}
%\end{figure}

%\end{example}

%\begin{exercice}
%Est-il nécessaire dans la transformation de rendre non-terminaux les états qui l'étaient dans l'automate original ?
%\end{exercice}

%\begin{exercice}
%Pourquoi était-il indispensable d'introduire un nouvel état dans la transformation ?
%\end{exercice}

\subsection{Intersection}

\begin{theorem}
Les langages reconnaissables par automate fini sont clos par intersection, i.e. pour tous langages $L_1$ and $L_2$ reconnaissables par automate fini, il existe un automate fini reconnaissant $L_1 \cap L_2$.
\end{theorem}

\begin{proof}
Soient $A_1$ et $A_2$ des automates reconnaissant $L_1$ et $L_2$. Comme dans l'algorithme de déterminisation, on va utiliser un automate pour en simuler un autre, ou en l'occurrence deux, en utilisant comme états des couples d'états de $A_1$ / $A_2$. Si par exemple on a dans $q_1 \xrightarrow{c} q_1'$ dans $A_1$ et $q_2 \xrightarrow{c} q_2'$ dans $A_2$, alors on aura dans l'automate de $L_1 \cap L_2$


\begin{figure}[H]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=4cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


  \node[state] (1)                    {$q_1, q_2$};
  \node[state] (2)      [right of=1]                {$q_1',q_2'$}; 

  \path %(I) edge[loop above]              node {$a,b$} (I)
(1) edge      []        node {$c$} (2)
;
\end{tikzpicture}
\end{figure}

Ce faisant, la lecture d'un mot exécute celles du même mot à la fois dans $A_1$ (parties gauches des différents états) et dans $A_2$ (parties droites). On veut commencer au début des deux automates, les états initiaux seront donc l'ensemble des $i_1,i_2$ tels que $i_1$ est initial dans $A_1$ et $i_2$ dans $A_2$. On ne veut accepter un mot que s'il appartient aux deux langages, cad. ssi. il serait accepté par les deux langages. Les états terminaux sont donc ceux de la forme $f_1, f_2$, où $f_1$ et $f_2$ sont tous les deux terminaux dans leurs automates respectifs.

Plus formellement, soient $A_1 = \big \langle Q_1, \Sigma_1, \delta_1, I_1, F_1\big \rangle$ et $A_1 = \big \langle Q_2, \Sigma_2, \delta_2, I_2, F_2\big \rangle$, alors $L_1 \cap L_2$ est reconnu par $\big \langle Q_1 \times Q_2, \Sigma_1 \cap \Sigma_2, \delta', I_1 \times I_2, F_1 \times F_2\big \rangle$ avec $\delta(\big \langle q_1, q_2 \big \rangle,a) = \delta_1(q_1,a) \times \delta_2(q_2,a)$.

Par coquetterie et amour inconditionnel des homomorphismes, on mentionnera la jolie définition de $\delta'$ dans le cas déterministe :

\[
\delta(\big \langle q_1, q_2 \big \rangle,a) = \big \langle \delta_1(q_1,a), \delta_2(q_2,a) \big \rangle
\]

\end{proof}

\paragraph*{Remarque} L'intersection de deux automates est déterministe ssi. les deux automates sont déterministes.

\begin{example}
\label{interex}
On veut reconnaître le langage des mots qui contiennent les facteurs $aba$ et $bab$. Les facteurs se chevauchant, écrire directement un tel automate n'est pas totalement évident. On va utiliser l'algorithme d'intersection, dans sa version déterministe ou non. On choisit ici la première option. On commence donc en rappelant les AFD reconnaissant les deux langages à mêler : 


\begin{figure}[!ht]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.9cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


  \node[initial,state] (0)                    {$0$};
  \node[state] (1)      [right of=0]                {$1$};  
  \node[state] (2)      [right of=1]                {$2$};
  \node[accepting,state] (3)      [right of=2]                {$3$};

  \node[initial,state] (4)  [below of=0]            {$0$};
  \node[state] (5)      [right of=4]                {$1$};  
  \node[state] (6)      [right of=5]                {$2$};
  \node[accepting,state] (7)      [right of=6]                {$3$};

  \path %(I) edge[loop above]              node {$a,b$} (I)
(0) edge      [loop above]        node {$b$} (0)
(0) edge      []        node {$a$} (1)
(1) edge      [loop above]        node {$a$} (1)
(1) edge      []        node {$b$} (2)
(2) edge      []        node {$a$} (3)
(2) edge      [bend left]        node {$b$} (0)
(3) edge      [loop above]        node {$a,b$} (3)
(4) edge      [loop above]        node {$a$} (4)
(4) edge      []        node {$b$} (5)
(5) edge      [loop below]        node {$b$} (5)
(5) edge      []        node {$a$} (6)
(6) edge      []        node {$b$} (7)
(6) edge      [bend right]        node {$a$} (4)
(7) edge      [loop below]        node {$a,b$} (7);

\end{tikzpicture}
\end{figure}

On part de l'état $0,0$. Vu que $a$ nous emmène de $0$ en $1$ dans le premier automate et de $0$ en $0$ dans le second, $0,0$ va en $1,0$ et $1,0$ en lisant $a$, et ainsi de suite. On obtient au final l'automate suivant :


\begin{figure}[H]
\hspace{-1cm}
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


  \node[initial,state] (00)                    {$0,0$};
  \node[state] (10)      [above right of=00]                {$1,0$};  
  \node[state] (01)      [below right of=00]                {$0,1$};
  \node[state] (21)      [right of=10]                {$2,1$};  
  \node[state] (12)      [right of=01]                {$1,2$};
  \node[state] (32)      [right of=21]                {$3,2$};  
  \node[state] (23)      [right of=12]                {$2,3$};  
  \node[state,accepting] (33)      [below = 1.25cm of 32]                {$3,3$};
  \node[state] (30)      [right of=32]                {$3,0$};  
  \node[state] (03)      [right of=23]                {$0,3$};  
  \node[state] (31)      [right of=30]                {$3,1$};  
  \node[state] (13)      [right of=03]                {$1,3$};  

  \path %(I) edge[loop above]              node {$a,b$} (I)
(00) edge     []        node {$a$} (10)
(00) edge     []        node {$b$} (01)
(10) edge     [loop above]        node {$a$} (10)
(10) edge     []        node {$b$} (21)
(01) edge     [loop below]        node {$b$} (01)
(01) edge     []        node {$a$} (12)
(21) edge     [pos=0.8]        node {$b$} (01)
(12) edge     [pos=0.8]        node {$a$} (10)
(21) edge     []        node {$a$} (32)
(12) edge     []        node {$b$} (23)
(32) edge     []        node {$a$} (30)
(32) edge     []        node {$b$} (33)
(23) edge     []        node {$b$} (03)
(23) edge     []        node {$a$} (33)
(30) edge     [loop above]        node {$a$} (30)
(30) edge     []        node {$b$} (31)
(03) edge     [loop below]        node {$b$} (03)
(03) edge     []        node {$a$} (13)
(31) edge     [loop above]        node {$b$} (31)
(13) edge     [loop below]        node {$a$} (13)
(31) edge     [bend left=40]        node {$a$} (32)
(13) edge     [bend right=40]        node {$b$} (23)
(33) edge     [loop left]        node {$a,b$} (33)
;

\end{tikzpicture}
\end{figure}
\end{example}

\begin{exercice}
Minimiser l'automate de l'exemple \ref{interex}.
\end{exercice}

\begin{exercice}
Appliquer l'algorithme d'intersection sur les versions non-déterministes des automates de l'exemple \ref{interex} (cf. l'exemple \ref{incomptoo}).
\end{exercice}

\subsection{Complémentaire}


\begin{theorem}
Les langages reconnaissables par automate fini sont clos par complémentaire, i.e. pour tout langage $L$ reconnaissable par automate fini, il existe un automate fini reconnaissant $\overline{L}$, cad. le langage des mots qui n'appartiennent pas à $L$.
\end{theorem}

\begin{proof}
Puisqu'on veut reconnaître ce qui ne l'était pas, et ne plus reconnaître ce qui l'était, une idée assez naturelle est d'inverser les états terminaux et non-terminaux. Il y a cependant deux subtilités.

Il faut d'abord que l'état soit déterministe. En effet, si on a un AFND et un mot ayant dans l'automate deux chemins, un menant à un état terminal et un menant à un état non-terminal, alors le mot sera accepté avant et après inversion. On peut observer ce phénomène concrètement avec le mot $a$ et l'automate  


\begin{figure}[H]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


  \node[initial,state] (0)                    {$0$};
  \node[state,accepting] (1)      [above right=1cm and 2cm of 0]                {$1$};  
  \node[state] (2)      [below right=1cm and 2cm of 0]                 {$2$};  

  \path %(I) edge[loop above]              node {$a,b$} (I)
(0) edge     []        node {$a$} (1)
(0) edge     []        node {$a$} (2)
;

\end{tikzpicture}
\end{figure}

De plus, l'automate doit être complet. En effet, un chemin non-existant reste non-existant malgré une inversion des terminaux et non-terminaux. Par exemple le mot $a$ n'est pas reconnu par l'automate 

\begin{figure}[H]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


  \node[initial,state] (0)                    {$0$};
\end{tikzpicture}
\end{figure}

ni par l'automate 


\begin{figure}[H]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


  \node[initial,state,accepting] (0)                    {$0$};
\end{tikzpicture}
\end{figure}

Si on complète le premier automate, on obtient 

\begin{figure}[H]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


  \node[initial,state] (0)                    {$0$};
  \node[state] (P) [right of=0]                    {$P$};

  \path %(I) edge[loop above]              node {$a,b$} (I)
(0) edge     []        node {$a,b$} (P)
(P) edge     [loop right]        node {$a,b$} (P)
;

\end{tikzpicture}
\end{figure}

qui ne reconnait toujours aucun mot. En calculant son complémentaire, on obtient


\begin{figure}[H]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


  \node[initial,state,accepting] (0)                    {$0$};
  \node[state,accepting] (P) [right of=0]                    {$P$};

  \path %(I) edge[loop above]              node {$a,b$} (I)
(0) edge     []        node {$a,b$} (P)
(P) edge     [loop right]        node {$a,b$} (P)
;

\end{tikzpicture}
\end{figure}

qui accepte tous les mots.

\end{proof}

\begin{example}
On veut un automate pour les mots qui ne contiennent pas le facteur $aba$. En reprenant un exemple qu'on a déjà trop vu, on obtient 


\begin{figure}[H]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.9cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


  \node[initial,state,accepting] (0)                    {$0$};
  \node[state,accepting] (1)      [right of=0]                {$1$};  
  \node[state,accepting] (2)      [right of=1]                {$2$};
  \node[state] (3)      [right of=2]                {$3$};

  \path %(I) edge[loop above]              node {$a,b$} (I)
(0) edge      [loop above]        node {$b$} (0)
(0) edge      []        node {$a$} (1)
(1) edge      [loop above]        node {$a$} (1)
(1) edge      []        node {$b$} (2)
(2) edge      []        node {$a$} (3)
(2) edge      [bend left]        node {$b$} (0)
(3) edge      [loop above]        node {$a,b$} (3)
;

\end{tikzpicture}
\end{figure}
\end{example}

\begin{exercice}
Donner un automate des mots ne terminant pas par $aba$.
\end{exercice}

%TODO: clôture par morphisme ?

\subsection{Conséquences pour les langages non-reconnus}

On a vu que les langages reconnaissables par automate fini pouvaient se construire en combinant d'autres langages reconnaissables par automate fini, ce qui nous permet de montrer facilement que tout un tas de langages sont eux-mêmes reconnaissables par un automate fini. Mais ces propriétés de clôture permettent aussi, assez ironiquement, de montrer facilement que pas mal de langages ne le sont pas.

\begin{theorem}
Le langage $L = \{w ~|~ |w|_a = |w|_b\}$, cad. l'ensemble des mots contenant autant de $a$ que de $b$, n'est pas reconnaissable par automate fini.
\end{theorem}

\begin{proof}
On pourrait essayer d'adapter la preuve du théorème \ref{anbn}, mais ça serait beaucoup plus désagréable que d'utiliser la clôture par intersection. En effet, le langage $\{a^nb^n ~|~n \in \mathbb{N}\}$ peut être défini comme l'intersection de $a^*b^*$ et $L$. Or, $a^*b^*$ est reconnu par l'automate suivant :


\begin{figure}[H]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.9cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


  \node[initial,state,accepting] (0)                    {$0$};
  \node[state,accepting] (1)      [right of=0]                {$1$};  

  \path %(I) edge[loop above]              node {$a,b$} (I)
(0) edge      [loop above]        node {$a$} (0)
(0) edge      []        node {$b$} (1)
(1) edge      [loop above]        node {$b$} (1)
;

\end{tikzpicture}
\end{figure} 

Si $L$ était reconnu par un automate fini, $a^*b^* \cap L = \{a^nb^n ~|~ n \in \mathbb{N}\}$ le serait également, ce qui n'est pas le cas (cf. théorème \ref{anbn}). On en déduit donc que $L$ n'est pas reconnaissable par automate.

\end{proof}

\begin{exercice}
Montrer que le langage $\{w \in \{a,b,c\}^* ~|~ |w|_a = |w|_b\}$ n'est pas reconnaissable par automate.
\end{exercice}

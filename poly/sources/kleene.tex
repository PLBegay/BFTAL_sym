\chapter{Théorème de Kleene}
\label{hierarchie}

On a pour l'instant utilisé les expressions rationnelles pour décrire les langages reconnus par des automates, et utilisé des automates pour implémenter des expressions rationnelles. On a cependant vu que l'expressivité des automates était limitée, en ce qu'il existe de nombreux langages qu'ils ne peuvent reconnaître. On peut donc légitimement se demander si les expressions rationnelles sont plus ou moins expressives que les automates finis.

Le mathématicien Stephen C. Kleene (1909 - 1994) répond à cette question via le théorème qui porte son nom :

\begin{theorem}{\textbf{(Théorème de Kleene)}}
Les langages représentable par expression rationnelle sont exactement ceux reconnus par automate fini.
\end{theorem}

L'égalité entre deux ensembles $A$ et $B$ équivaut à la double inclusion entre les mêmes ensembles, cad. $A \subseteq B \wedge B \subseteq A$. On va donc chercher une preuve que chaque langage représentable par \textit{regex} est reconnaissable par automate fini, et inversement. Ces deux sous-théorèmes admettent aujourd'hui de nombreuses preuves, notamment constructives, cad. sous la forme d'algorithmes qui réalisent la transformation d'une \textit{regex} en automate, et inversement. Cette section présente plusieurs de ces algorithmes.

\section{Des expressions rationnelles aux automates}

On veut prouver ici le théorème suivant :

\begin{theorem}
Les langages représentables par expression rationnelle sont également reconnaissables par automate fini.
\end{theorem}

On en présente ici deux preuves différentes.

\subsection{Traduction récursive}

\begin{proof}
On va procéder par induction structurelle sur les expressions rationnelles. On en rappelle d'abord la définition récursive : 

\begin{tabular}{cccl}
$e$ & $\textcolor{black}{::=}$ & & $\epsilon$\\
& & $|$&  $a \in \Sigma$\\
& & $|$&  $e_1.e_2$\\
& & $|$&  $e_1+e_2$\\
& & $|$&  $e_1^*$\\
\end{tabular}

L'expression $\epsilon$ est clairement reconnu par l'automate 


\begin{figure}[H]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.9cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]

  \node[initial,state,accepting] (0)                    {$0$};
  
\end{tikzpicture}
\end{figure}

L'expression $a$ quant à elle est reconnue par 


\begin{figure}[H]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.9cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


  \node[initial,state] (0)                    {$0$};
  \node[state,accepting] (1)      [right of=0]                {$1$};

  \path %(I) edge[loop above]              node {$a,b$} (I)
(0) edge      []        node {$a$} (1);

\end{tikzpicture}
\end{figure}

On peut donc traduire en automates les cas de base des expressions rationnelles. Quant aux cas récursifs, on les a en fait déjà traités en \ref{cloture} : pour construire un automate reconnaissant $e_1 + e_2$, on construit des automates $A_1$ et $A_2$ reconnaissant $e_1$ et $e_2$, et on applique la construction de l'union. On procède de même avec la concaténation pour $e_1e_2$ et l'itération pour $e^*$.
\end{proof}

\paragraph*{Remarque} Les constructions vues pour les propriétés de clôture ne sont pas optimales. L'\href{https://fr.wikipedia.org/wiki/Algorithme_de_Thompson}{algorithme de Thomson} utilise les mêmes idées mais s'assure qu'il n'y ait pas plus d'un état initial et un état terminal (différents) tout au long de la construction de l'automate, ce qui permet de borner plus finement sa taille, et de faciliter la concaténation (on fusionne l'état terminal gauche et l'état initial droit).

\subsection{Traduction linéaire}

On propose un autre algorithme, qui sépare la construction des états de celles des transitions : l'\textbf{algorithme de Glushkov}.

\begin{example}

Soit $e = (abb^*a+(ba)^*)^*$. On commence par distinguer toutes les lettres de l'expression, par exemple en les indexant par leur position. On obtient donc

\[
(a_1b_2b_3^*a_4+(b_5a_6)^*)^*
\]

On crée ensuite un état pour chaque lettre, ainsi qu'un état initial $0$ :


\begin{figure}[H]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.5cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]

  \node[initial,state] (0)                    {$0$};
  \node[state] (1)   [above right of=0]                {$a_1$};
  \node[state] (2)    [right of=1]     {$b_2$};
  \node[state] (3)             [right of=2]       {$b_3$};
  \node[state] (4)        [right of=3]            {$a_4$};
  \node[state] (5)     [below right of=0]               {$b_5$};
  \node[state] (6)     [right of=5]               {$a_6$};


%  \path %(I) edge[loop above]              node {$a,b$} (I)
%(0) edge      []        node {$a$} (1);

\end{tikzpicture}
\end{figure}

Le jeu va être de représenter, avec les transitions, les "promenades" dans l'expression. Toute mot capturé par l'expression commence par $a_1$ ou $b_5$. On ajoute donc ces transitions : 


\begin{figure}[H]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.5cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]

  \node[initial,state] (0)                    {$0$};
  \node[state] (1)   [above right of=0]                {$a_1$};
  \node[state] (2)    [right of=1]     {$b_2$};
  \node[state] (3)             [right of=2]       {$b_3$};
  \node[state] (4)        [right of=3]            {$a_4$};
  \node[state] (5)     [below right of=0]               {$b_5$};
  \node[state] (6)     [right of=5]               {$a_6$};


  \path %(I) edge[loop above]              node {$a,b$} (I)
(0) edge      []        node {$a_1$} (1)
(0) edge      []        node {$b_5$} (5)
;

\end{tikzpicture}
\end{figure}


Quand on a lu un $a_1$, on est obligé de lire un $b_2$. De même, un $b_5$ est forcément suivi d'un $a_6$ :

\begin{figure}[H]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.5cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]

  \node[initial,state] (0)                    {$0$};
  \node[state] (1)   [above right of=0]                {$a_1$};
  \node[state] (2)    [right of=1]     {$b_2$};
  \node[state] (3)             [right of=2]       {$b_3$};
  \node[state] (4)        [right of=3]            {$a_4$};
  \node[state] (5)     [below right of=0]               {$b_5$};
  \node[state] (6)     [right of=5]               {$a_6$};


  \path %(I) edge[loop above]              node {$a,b$} (I)
(0) edge      []        node {$a_1$} (1)
(0) edge      []        node {$b_5$} (5)
(1) edge      []        node {$b_2$} (2)
(5) edge      [bend right=15]        node {$a_6$} (6)
;

\end{tikzpicture}
\end{figure}

Après la lecture d'un $a_6$, on peut recommencer la boucle $(b_5a_6)^*$, auquel cas on lit un $b_5$, ou recommencer la boucle entière $(a_1b_2b_3^*a_4+(b_5a_6)^*)^*$, en lisant un $a_1$ ou un $b_5$ :


\begin{figure}[H]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.5cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]

  \node[initial,state] (0)                    {$0$};
  \node[state] (1)   [above right of=0]                {$a_1$};
  \node[state] (2)    [right of=1]     {$b_2$};
  \node[state] (3)             [right of=2]       {$b_3$};
  \node[state] (4)        [right of=3]            {$a_4$};
  \node[state] (5)     [below right of=0]               {$b_5$};
  \node[state] (6)     [right of=5]               {$a_6$};


  \path %(I) edge[loop above]              node {$a,b$} (I)
(0) edge      []        node {$a_1$} (1)
(0) edge      []        node {$b_5$} (5)
(1) edge      []        node {$b_2$} (2)
(5) edge      [bend right=15]        node {$a_6$} (6)
(6) edge      [bend left]        node {$b_5$} (5)
(6) edge      []        node {$a_1$} (1)
;

\end{tikzpicture}
\end{figure}

Après la lecture d'un $b_2$, on peut lire un $b_3$, mais aussi sauter $b_3^*$ et aller directement lire un $a_4$. En $b_3$, on peut boucler ou passer en $a_4$. En $a_4$, comme en $a_6$, on peut lire $a_1$ ou $b_5$. On a donc :

\begin{figure}[H]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.5cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]

  \node[initial,state] (0)                    {$0$};
  \node[state] (1)   [above right of=0]                {$a_1$};
  \node[state] (2)    [right of=1]     {$b_2$};
  \node[state] (3)             [right of=2]       {$b_3$};
  \node[state] (4)        [right of=3]            {$a_4$};
  \node[state] (5)     [below right of=0]               {$b_5$};
  \node[state] (6)     [right of=5]               {$a_6$};


  \path %(I) edge[loop above]              node {$a,b$} (I)
(0) edge      []        node {$a_1$} (1)
(0) edge      []        node {$b_5$} (5)
(1) edge      []        node {$b_2$} (2)
(2) edge      []        node {$b_3$} (3)
(2) edge      [bend right=35]        node {$a_4$} (4)
(3) edge      []        node {$a_4$} (4)
(3) edge      [loop above]        node {$b_3$} (3)
(4) edge      [bend right=50]        node {$a_1$} (1)
(4) edge      [bend left=15]        node {$b_5$} (5)
(5) edge      [bend right=15]        node {$a_6$} (6)
(6) edge      [bend left]        node {$b_5$} (5)
(6) edge      []        node {$a_1$} (1)
;

\end{tikzpicture}
\end{figure}

On peut arrêter de boucler quand on vient de lire un $a_4$ ou un $a_6$, ce qui veut dire que les états correspondant vont être terminaux. De plus, l'expression rationnelle contient le mot vide, ce qui veut dire que l'état initial doit être terminal. Il ne nous reste plus qu'à "déspécialiser" les lettres, et éventuellement renommer les états :


\begin{figure}[H]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.5cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]

  \node[initial,state,accepting] (0)                    {$0$};
  \node[state] (1)   [above right of=0]                {$1$};
  \node[state] (2)    [right of=1]     {$2$};
  \node[state] (3)             [right of=2]       {$3$};
  \node[state,accepting] (4)        [right of=3]            {$4$};
  \node[state] (5)     [below right of=0]               {$5$};
  \node[state,accepting] (6)     [right of=5]               {$6$};


  \path %(I) edge[loop above]              node {$a,b$} (I)
(0) edge      []        node {$a$} (1)
(0) edge      []        node {$b$} (5)
(1) edge      []        node {$b$} (2)
(2) edge      []        node {$b$} (3)
(2) edge      [bend right=35]        node {$a$} (4)
(3) edge      []        node {$a$} (4)
(3) edge      [loop above]        node {$b$} (3)
(4) edge      [bend right=50]        node {$a$} (1)
(4) edge      [bend left=15]        node {$b$} (5)
(5) edge      [bend right=15]        node {$a$} (6)
(6) edge      [bend left]        node {$b$} (5)
(6) edge      []        node {$a$} (1)
;

\end{tikzpicture}
\end{figure}
\end{example}

On a présenté l'algorithme \textit{via} un exemple, mais il repose bien évidemment sur des définitions formelles, procédant par induction sur l'expression. Une fois qu'on a spécialisé les lettres et crée les états comme dans l'exemple, on veut d'abord savoir si l'expression rationnelle donnée accepte ou non le mot vide. C'est à cette question que répond la fonction suivante :

\[
\begin{cases}
E(\epsilon) = \top \\
E(a) = \bot \\
E(e_1+e_2) = E(e_1) \vee E(e_2) \\
E(e_1.e_2) = E(e_1) \wedge E(e_2) \\
E(e^*) = \top
\end{cases}
\]

L'état initial est terminal ssi. $E(e) = \top$. Pour les premières transitions, qui partiront de l'état initial $0$, on a besoin de déterminer quelles lettres peuvent commencer les mots reconnus par l'expression, ce que fait la fonction suivante : 

\[
\begin{cases}
D(\epsilon) = \emptyset \\
D(a) = \{a\} \\
D(e_1+e_2) = D(e_1) \cup D(e_2) \\
D(e_1.e_2) = D(e_1) & \text{Si } e_1 \text{ n'accepte pas le mot vide, cad. si }\neg E(e_1)\\
D(e_1.e_2) = D(e_1) \cup D(e_2) & \text{sinon}  \\
D(e^*) = D(e)
\end{cases}
\]

On ajoute une transition $0 \xrightarrow{q} q$ pour tout $q \in D(e)$. De même, on a besoin de savoir quelles lettres peuvent finir les mots du langage dénoté par une expression : 

\[
\begin{cases}
F(\epsilon) = \emptyset \\
F(a) = \{a\} \\
F(e_1+e_2) = F(e_1) \cup F(e_2) \\
F(e_1.e_2) = F(e_2) & \text{Si } e_2 \text{ n'accepte pas le mot vide, cad. si} \neg E(e_2)\\f
F(e_1.e_2) = F(e_1) \cup F(e_2) & \text{sinon}  \\
F(e^*) = F(e)
\end{cases}
\]


Tout les états de $F$ sont terminaux. En plus des premières transitions, on veut bien sûr les autres. Pour ça, on calcule l'ensemble des lettres qui peuvent se suivre dans le langage dénoté par l'expression :

\[
\begin{cases}
P(\epsilon) = \emptyset \\
P(a) = \emptyset \\
P(e_1+e_2) = P(e_1) \cup P(e_2) \\
P(e_1.e_2) = P(e_1) \cup P(e_2) \cup F(e_1).D(e_2) \\
P(e^*) = P(e) \cup F(e).D(e) 
\end{cases}
\]

Toute paire $\big \langle q_1, q_2 \big \rangle$ appartenant à $P(e)$ génère donc une transition $q_1 \xrightarrow{q_2} q_2$ dans l'automate.


\begin{exercice}
Utiliser l'algorithme de Glushkov pour traduire en automate l'expression \newline $e = (bb)^*(b(a+b)^*)^*$
\end{exercice}

\paragraph*{Remarque} On a présenté ces différents algorithmes comme des preuves de la "traductabilité" des expressions rationnelles en automates finis. Si on était vraiment rigoureux, les algorithmes ne suffiraient pas, il faudrait aussi prouver 1) qu'ils terminent sur toute entrée 2) qu'ils produisent bien un automate fini acceptant le langage décrit par l'expression donnée. Ces preuves sont autrement plus complexes que l'écriture des algorithmes\footnote{On entend souvent dire que la preuve d'un programme ou algorithme est au moins un ordre de grandeur plus complexe que l'écriture de ce dernier} et vont au-delà du programme du cours, mais il est toujours bon de garder son esprit critique face à ces choses. Cette remarque s'applique bien évidemment également à l'algorithme présenté dans les pages qui suivent pour la traduction inverse.



\section{Des automates aux expressions rationnelles - algorithme de McNaughton et Yamada}

On veut maintenant prouver le théorème suivant :

\begin{theorem}
Les langages reconnaissables par automate fini sont représentables par expression rationnelle.
\end{theorem}

On en présente ici une preuve constructive, connue sous le nom d'algorithme de McNaughton et Yamada.

\begin{proof}
Soit un automate $A$ ayant comme ensemble d'états $Q$. L'idée va être de calculer, pour toute paire d'états $(i,j)$, les ensembles de mots permettant d'aller de $i$ à $j$ en n'utilisant qu'une sélection d'états. On va faire ces calculs pour des sélections minimales, et grossir petit à petit, jusqu'à ne plus avoir de contrainte. 


On introduit pour ça la notation $L_{i,j}^X$, qui représente sous forme d'expression rationnelle l'ensemble des mots \underline{non-vides} menant de $i$ à $j$ en n'utilisant \underline{comme états intermédiaires} que des états appartenant à l'ensemble $X$. Par exemple, dans l'automate  

\begin{figure}[H]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.5cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]

  \node[initial,state] (0)                    {$0$};
  \node[initial,state,accepting] (1)   [above right of=0]                {$1$};
  \node[state] (2)    [below right of=0]     {$2$};
  \node[state,accepting] (3)             [right=2.5cm of 0]       {$3$};


  \path %(I) edge[loop above]              node {$a,b$} (I)
(0) edge      [loop above]        node {$a$} (0)
(1) edge      [loop above]        node {$c$} (1)
(2) edge      [loop below]        node {$d$} (2)
(0) edge      []        node {$a$} (1)
(0) edge      []        node {$b$} (2)
(1) edge      []        node {$b$} (3)
(2) edge      []        node {$a$} (3)
;

\end{tikzpicture}
\end{figure}

$L_{0,3}^{\{1\}} = ac^*b$. En effet, on ne peut pas boucler en $0$ car il servirait alors d'état intermédiaire, alors qu'il ne fait pas partie de ceux autorisés. De même, on ne peut pas passer par l'état $2$. On peut en revanche boucler sur $1$, d'où le $c^*$ dans la regex.

On commence en calculer tous les $L_{i,j}^{\emptyset}$. Puisqu'on n'a pas le droit au moindre état intermédiaire, $L_{i,j}^{\emptyset}$ vaut la lettre étiquettant la transition de $i$ à $j$ si elle existe, et $\emptyset$ sinon. Dans notre exemple, on a donc 

\begin{itemize}
\item En partant de $0$ :
   \begin{itemize}
	 \item $L_{0,0}^{\emptyset} = a$
	 \item $L_{0,1}^{\emptyset} = a$
	 \item $L_{0,2}^{\emptyset} = b$
	 \item $L_{0,3}^{\emptyset} = \emptyset$
   \end{itemize}
\item En partant de $1$ :
   \begin{itemize}
	 \item $L_{1,0}^{\emptyset} = \emptyset$
	 \item $L_{1,1}^{\emptyset} = c$
	 \item $L_{1,2}^{\emptyset} = \emptyset$
	 \item $L_{1,3}^{\emptyset} = b$
   \end{itemize}
\item En partant de $2$ :
   \begin{itemize}
	 \item $L_{2,0}^{\emptyset} = \emptyset$
	 \item $L_{2,1}^{\emptyset} = \emptyset$
	 \item $L_{2,2}^{\emptyset} = d$
	 \item $L_{2,3}^{\emptyset} = a$
   \end{itemize}
\item En partant de $3$ :
   \begin{itemize}
	 \item $L_{3,0}^{\emptyset} = \emptyset$
	 \item $L_{3,1}^{\emptyset} = \emptyset$
	 \item $L_{3,2}^{\emptyset} = \emptyset$
	 \item $L_{3,3}^{\emptyset} = \emptyset$
   \end{itemize}
\end{itemize}

Maintenant qu'on a notre cas de base, il s'agit de passer aux étapes suivantes en ajoutant de nouveaux états. Si on a tous nos $L_{i,j}^X$ et qu'on veut s'autoriser à passer par l'état $q$, on va utiliser la formule 

\[
L_{i,j}^{X \cup \{q\}} = L_{i,j}^X \cup L_{i,q}^X(L_{q,q}^X)^*L_{q,j}^X
\]

L'idée est que, pour aller de $i$ à $j$ en ayant le droit d'utiliser les états de $X$ et $q$, on passe ou non par $q$. Le deuxième cas est pris en compte la partie gauche de l'union ensembliste.

Supposons maintenant qu'on aille de $i$ à $j$ en passant au moins une fois par $q$. Dans ce cas, notre parcours commence par un chemin de $i$ à $q$ sans passer par $q$, cad. par la lecture d'un mot appartenant à $L_{i,q}^X$.

Le parcours peut passer plus d'une fois par $q$. On s'autoriste donc à faire des chemins de $q$ à $q$, ce qui correspond à la partie $(L_{q,q}^X)^*$ de la formule.

Enfin, une fois qu'on a fait notre dernier passage par l'état $q$, il faut finir notre parcours en allant en $j$ : $L_{q,j}^X$.

En résumé, pour calculer l'ensemble des mots menant de $i$ à $j$ en passant par les états de $X$ ou $q$, on isole explicitement les éventuels passages par $q$ pour pouvoir se ramener au cas précédent, où seuls les états appartenant à $X$ sont autorisés. On peut donc maintenant avancer les calculs pour notre automate, par exemple en autorisant maintenant les passages par l'état $1$ (l'ordre dans lequel on ajoute les états ne change pas le résultat, mais peut rendre les calculs plus ou moins longs) :


\begin{itemize}
\item En partant de $0$ :
   \begin{itemize}
	 \item $L_{0,0}^{\emptyset \cup \{1\}} = L_{0,0}^{\emptyset} \cup L_{0,1}^{\emptyset}(L_{1,1}^{\emptyset})^*L_{1,0}^{\emptyset} = a + a(c)^*\emptyset = a$\footnote{Pour rappel, $L\emptyset = \emptyset L = \emptyset$ pour tout langage $L$}
	 \item $L_{0,1}^{\{1\}} = L_{0,1}^{\emptyset} \cup L_{0,1}^{\emptyset}(L_{1,1}^{\emptyset})^*L_{1,1}^{\emptyset} = a + ac^*c = a + ac^+ = ac^*$
	 \item $L_{0,2}^{\{1\}} = L_{0,2}^{\emptyset} \cup L_{0,1}^{\emptyset}(L_{1,1}^{\emptyset})^*L_{1,2}^{\emptyset} = b + ac^*\emptyset = b$
	 \item $L_{0,3}^{\{1\}} = L_{0,3}^{\emptyset} \cup L_{0,1}^{\emptyset}(L_{1,1}^{\emptyset})^*L_{1,3}^{\emptyset} = ac^*b$
   \end{itemize}
\item En partant de $1$ :
   \begin{itemize}
	 \item $L_{1,0}^{\{1\}} = L_{1,0}^{\emptyset} \cup L_{1,1}^{\emptyset}(L_{1,1}^{\emptyset})^*L_{1,0}^{\emptyset} = \emptyset$
	 \item $L_{1,1}^{\{1\}} = L_{1,1}^{\emptyset} \cup L_{1,1}^{\emptyset}(L_{1,1}^{\emptyset})^*L_{1,1}^{\emptyset} = c + cc^*c = c^+$
	 \item $L_{1,2}^{\{1\}} = L_{1,2}^{\emptyset} \cup L_{1,1}^{\emptyset}(L_{1,1}^{\emptyset})^*L_{1,2}^{\emptyset} = \emptyset$
	 \item $L_{1,3}^{\{1\}} = L_{1,3}^{\emptyset} \cup L_{1,1}^{\emptyset}(L_{1,1}^{\emptyset})^*L_{1,3}^{\emptyset} = b + cc^*b = b + c^+b = c^*b$
   \end{itemize}
\item En partant de $2$ :
   \begin{itemize}
	 \item $L_{2,0}^{\{1\}} = L_{2,0}^{\emptyset} \cup L_{2,1}^{\emptyset}(L_{1,1}^{\emptyset})^*L_{1,0}^{\emptyset} = \emptyset$
	 \item $L_{2,1}^{\{1\}} = L_{2,1}^{\emptyset} \cup L_{2,1}^{\emptyset}(L_{1,1}^{\emptyset})^*L_{1,1}^{\emptyset} = \emptyset$
	 \item $L_{2,2}^{\{1\}} = L_{2,2}^{\emptyset} \cup L_{2,1}^{\emptyset}(L_{1,1}^{\emptyset})^*L_{1,2}^{\emptyset} = d$
	 \item $L_{2,3}^{\{1\}} = L_{2,3}^{\emptyset} \cup L_{2,1}^{\emptyset}(L_{1,1}^{\emptyset})^*L_{1,3}^{\emptyset} = a$
   \end{itemize}
\item En partant de $3$, vu que $L_{3,j}^{\emptyset} = \emptyset$ pour tout état $j$, on n'arrivera jamais à aller plus loin. Donc $L_{3,j}^{\{1\}} = \emptyset$ pour tout $j$.
\end{itemize}

On continue en ajoutant $2$ : 


\begin{itemize}
\item En partant de $0$ :
   \begin{itemize}
	 \item $L_{0,0}^{\{1\} \cup \{2\}} = L_{0,0}^{\{1\}} \cup L_{0,2}^{\{1\}}(L_{2,2}^{\{1\}})^*L_{2,0}^{\{1\}} = a$
	 \item $L_{0,1}^{\{1,2\}} = L_{0,1}^{\{1\}} \cup L_{0,2}^{\{1\}}(L_{2,2}^{\{1\}})^*L_{2,1}^{\{1\}} = ac^*$
	 \item $L_{0,2}^{\{1,2\}} = L_{0,2}^{\{1\}} \cup L_{0,2}^{\{1\}}(L_{2,2}^{\{1\}})^*L_{2,2}^{\{1\}} = b + bd^*d = bd^*$
	 \item $L_{0,3}^{\{1,2\}} = L_{0,3}^{\{1\}} \cup L_{0,2}^{\{1\}}(L_{2,2}^{\{1\}})^*L_{2,3}^{\{1\}} = ac^*b + bd^*a$
   \end{itemize}
\item En partant de $1$ :
   \begin{itemize}
	 \item $L_{1,0}^{\{1,2\}} = L_{1,0}^{\{1\}} \cup L_{1,2}^{\{1\}}(L_{2,2}^{\{1\}})^*L_{2,0}^{\{1\}} = \emptyset$
	 \item $L_{1,1}^{\{1,2\}} = L_{1,1}^{\{1\}} \cup L_{1,2}^{\{1\}}(L_{2,2}^{\{1\}})^*L_{2,1}^{\{1\}} = c^+$
	 \item $L_{1,2}^{\{1,2\}} = L_{1,2}^{\{1\}} \cup L_{1,2}^{\{1\}}(L_{2,2}^{\{1\}})^*L_{2,2}^{\{1\}} = \emptyset$
	 \item $L_{1,3}^{\{1,2\}} = L_{1,3}^{\{1\}} \cup L_{1,2}^{\{1\}}(L_{2,2}^{\{1\}})^*L_{2,3}^{\{1\}} = c^*b$
   \end{itemize}
\item En partant de $2$ :
   \begin{itemize}
	 \item $L_{2,0}^{\{1,2\}} = L_{2,0}^{\{1\}} \cup L_{2,2}^{\{1\}}(L_{2,2}^{\{1\}})^*L_{2,0}^{\{1\}} = \emptyset$
	 \item $L_{2,1}^{\{1,2\}} = L_{2,1}^{\{1\}} \cup L_{2,2}^{\{1\}}(L_{2,2}^{\{1\}})^*L_{2,1}^{\{1\}} = \emptyset$
	 \item $L_{2,2}^{\{1,2\}} = L_{2,2}^{\{1\}} \cup L_{2,2}^{\{1\}}(L_{2,2}^{\{1\}})^*L_{2,2}^{\{1\}} = d + dd^*d = d^+$
	 \item $L_{2,3}^{\{1,2\}} = L_{2,3}^{\{1\}} \cup L_{2,2}^{\{1\}}(L_{2,2}^{\{1\}})^*L_{2,3}^{\{1\}} = a + dd^*a = d^*a$
   \end{itemize}
\item $L_{3,j}^{\{1,2\}} = \emptyset$ pour tout $j$.
\end{itemize}

On ajoute maintenant $0$ : 


\begin{itemize}
\item En partant de $0$ :
   \begin{itemize}
	 \item $L_{0,0}^{\{1,2\} \cup \{0\}} = L_{0,0}^{\{1,2\}} \cup L_{0,0}^{\{1,2\}}(L_{0,0}^{\{0,2\}})^*L_{0,0}^{\{1,2\}} = a + aa^*a = a^+$
	 \item $L_{0,1}^{\{0,1,2\}} = L_{0,1}^{\{1,2\}} \cup L_{0,0}^{\{1,2\}}(L_{0,0}^{\{1,2\}})^*L_{0,1}^{\{1,2\}} = ac^* + aa^*ac^* = a^+c^*$
	 \item $L_{0,2}^{\{0,1,2\}} = L_{0,2}^{\{1,2\}} \cup L_{0,0}^{\{1,2\}}(L_{0,0}^{\{1,2\}})^*L_{0,2}^{\{1,2\}} = bd^* + aa^*bd^* = a^*bd^*$
	 \item $L_{0,3}^{\{0,1,2\}} = L_{0,3}^{\{1,2\}} \cup L_{0,0}^{\{1,2\}}(L_{0,0}^{\{1,2\}})^*L_{0,3}^{\{1,2\}} = ac^*b + bd^*a + aa^*(ac^*b + bd^*a) = a^*(ac^*b + bd^*a)$
   \end{itemize}
\item Comme on en a un peu marre, on remarque que $L_{i,0}^{\{1,2\}} = \emptyset$ quand $i \neq 0$, et donc que $L_{i,0}^{\{1,2\}}(L_{0,0}^{\{1,2\}})^*L_{0,j}^{\{1,2\}} = \emptyset$ pour tout état $j$. Donc, pour les départs d'états autres que $0$, le fait de pouvoir passer par $0$ ne va rien pouvoir ajouter. On a donc $L_{i,0}^{\{0,1,2\}} = L_{i,0}^{\{1,2\}}$ pour $i \neq 0$.
\end{itemize}

De même, $L_{3,i}^{\{0,1,2\}} = \emptyset$ pour tout état $i$. On a donc $L_{i,j}^Q = L_{i,j}^{\{0,1,2\}}$ pour toute paire d'états $i$ et $j$. 


Maintenant qu'on a calculé les langages reconnus par toute paire d'états, on combine ceux qui nous intéressent. Puisque les états initiaux sont $0$ et $1$ et que les terminaux sont $1$ et $3$, le langage reconnu par l'automate est l'union des mots allant de $0$ à $1$, de $0$ à $3$, de $1$ à $1$ et de $1$ à $3$ (on fait toues les combinaisons d'état initial / état terminal).

Attention cependant, $L_{i,j}^Q$ calcule l'ensemble des mots \underline{non-vides} allant de $i$ à $j$. Donc si un état est à la fois initial et terminal, il faut ajouter à la main le mot vide.

En conclusion, le langage reconnu par l'automate de l'exemple est décrit par la regex 

\[
L_{0,1}^Q + L_{0,3}^Q + L_{1,1}^Q + L_{1,3}^Q + \epsilon = a^+c^* + a^*(ac^*b + bd^*a) + c^+ + c^*b + \epsilon
\]

\end{proof}

Etant donné un automate fini, l'algorithme de McNaughton et Yamada permet donc, bien que parfois quelque peu laborieusement, de produire une expression rationnelle décrivant le même langage, réalisant donc la deuxième partie du théorème de Kleene.
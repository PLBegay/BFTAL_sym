\chapter{Théorème de Kleene}
\label{hierarchie}

On a pour l'instant utilisé les expressions rationnelles pour décrire les langages reconnus par des automates, et utilisé des automates pour implémenter des expressions rationnelles. On a cependant vu que l'expressivité des automates était limitée, en ce qu'il existe de nombreux langages qu'ils ne peuvent reconnaître. On peut donc légitimement se demander si les expressions rationnelles sont plus ou moins expressives que les automates finis.

Le mathématicien Stephen C. Kleene (1909 - 1994) répond à cette question via le théorème qui porte son nom :

\begin{theorem}{\textbf{(Théorème de Kleene)}}
Les langages représentable par expression rationnelle sont exactement ceux reconnus par automate fini.
\end{theorem}

L'égalité entre deux ensembles $A$ et $B$ équivaut à la double inclusion entre les mêmes ensembles, cad. $A \subseteq B \wedge B \subseteq A$. On va donc chercher une preuve que chaque langage représentable par \textit{regex} est reconnaissable par automate fini, et inversement. Ces deux sous-théorèmes admettent aujourd'hui de nombreuses preuves, notamment constructives, cad. sous la forme d'algorithmes qui réalisent la transformation d'une \textit{regex} en automate, et inversement. Cette section présente plusieurs de ces algorithmes.

\section{Des expressions rationnelles aux automates}

On veut prouver ici le théorème suivant :

\begin{theorem}
Les langages représentables par expression rationnelle sont également reconnaissables par automate fini.
\end{theorem}

On en présente ici deux preuves différentes.

\subsection{Traduction récursive}

\begin{proof}
On va procéder par induction structurelle sur les expressions rationnelles. On en rappelle d'abord la définition récursive : 

\begin{tabular}{cccl}
$e$ & $\textcolor{black}{::=}$ & & $\epsilon$\\
& & $|$&  $a \in \Sigma$\\
& & $|$&  $e_1.e_2$\\
& & $|$&  $e_1+e_2$\\
& & $|$&  $e_1^*$\\
\end{tabular}

L'expression $\epsilon$ est clairement reconnu par l'automate 


\begin{figure}[H]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.9cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]

  \node[initial,state,accepting] (0)                    {$0$};
  
\end{tikzpicture}
\end{figure}

L'expression $a$ quant à elle est reconnue par 


\begin{figure}[H]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.9cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


  \node[initial,state] (0)                    {$0$};
  \node[state,accepting] (1)      [right of=0]                {$1$};

  \path %(I) edge[loop above]              node {$a,b$} (I)
(0) edge      []        node {$a$} (1);

\end{tikzpicture}
\end{figure}

On peut donc traduire en automates les cas de base des expressions rationnelles. Quant aux cas récursifs, on les a en fait déjà traités en \ref{cloture} : pour construire un automate reconnaissant $e_1 + e_2$, on construit des automates $A_1$ et $A_2$ reconnaissant $e_1$ et $e_2$, et on applique la construction de l'union. On procède de même avec la concaténation pour $e_1e_2$ et l'itération pour $e^*$.
\end{proof}

\paragraph*{Remarque} Les constructions vues pour les propriétés de clôture ne sont pas optimales. L'\href{https://fr.wikipedia.org/wiki/Algorithme_de_Thompson}{algorithme de Thomson} utilise les mêmes idées mais s'assure qu'il n'y ait pas plus d'un état initial et un état terminal (différents) tout au long de la construction de l'automate, ce qui permet de borner plus finement sa taille, et de faciliter la concaténation (on fusionne l'état terminal gauche et l'état initial droit).

\subsection{Traduction linéaire}
\label{glushkov}
On propose un autre algorithme, qui sépare la construction des états de celles des transitions : l'\textbf{algorithme de Glushkov}.

\begin{example}

Soit $e = (abb^*a+(ba)^*)^*$. On commence par distinguer toutes les lettres de l'expression, par exemple en les indexant par leur position. On obtient donc

\[
(a_1b_2b_3^*a_4+(b_5a_6)^*)^*
\]

On crée ensuite un état pour chaque lettre, ainsi qu'un état initial $0$ :


\begin{figure}[H]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.5cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]

  \node[initial,state] (0)                    {$0$};
  \node[state] (1)   [above right of=0]                {$a_1$};
  \node[state] (2)    [right of=1]     {$b_2$};
  \node[state] (3)             [right of=2]       {$b_3$};
  \node[state] (4)        [right of=3]            {$a_4$};
  \node[state] (5)     [below right of=0]               {$b_5$};
  \node[state] (6)     [right of=5]               {$a_6$};


%  \path %(I) edge[loop above]              node {$a,b$} (I)
%(0) edge      []        node {$a$} (1);

\end{tikzpicture}
\end{figure}

Le jeu va être de représenter, avec les transitions, les "promenades" dans l'expression. Toute mot capturé par l'expression commence par $a_1$ ou $b_5$. On ajoute donc ces transitions : 


\begin{figure}[H]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.5cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]

  \node[initial,state] (0)                    {$0$};
  \node[state] (1)   [above right of=0]                {$a_1$};
  \node[state] (2)    [right of=1]     {$b_2$};
  \node[state] (3)             [right of=2]       {$b_3$};
  \node[state] (4)        [right of=3]            {$a_4$};
  \node[state] (5)     [below right of=0]               {$b_5$};
  \node[state] (6)     [right of=5]               {$a_6$};


  \path %(I) edge[loop above]              node {$a,b$} (I)
(0) edge      []        node {$a_1$} (1)
(0) edge      []        node {$b_5$} (5)
;

\end{tikzpicture}
\end{figure}


Quand on a lu un $a_1$, on est obligé de lire un $b_2$. De même, un $b_5$ est forcément suivi d'un $a_6$ :

\begin{figure}[H]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.5cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]

  \node[initial,state] (0)                    {$0$};
  \node[state] (1)   [above right of=0]                {$a_1$};
  \node[state] (2)    [right of=1]     {$b_2$};
  \node[state] (3)             [right of=2]       {$b_3$};
  \node[state] (4)        [right of=3]            {$a_4$};
  \node[state] (5)     [below right of=0]               {$b_5$};
  \node[state] (6)     [right of=5]               {$a_6$};


  \path %(I) edge[loop above]              node {$a,b$} (I)
(0) edge      []        node {$a_1$} (1)
(0) edge      []        node {$b_5$} (5)
(1) edge      []        node {$b_2$} (2)
(5) edge      [bend right=15]        node {$a_6$} (6)
;

\end{tikzpicture}
\end{figure}

Après la lecture d'un $a_6$, on peut recommencer la boucle $(b_5a_6)^*$, auquel cas on lit un $b_5$, ou recommencer la boucle entière $(a_1b_2b_3^*a_4+(b_5a_6)^*)^*$, en lisant un $a_1$ ou un $b_5$ :


\begin{figure}[H]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.5cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]

  \node[initial,state] (0)                    {$0$};
  \node[state] (1)   [above right of=0]                {$a_1$};
  \node[state] (2)    [right of=1]     {$b_2$};
  \node[state] (3)             [right of=2]       {$b_3$};
  \node[state] (4)        [right of=3]            {$a_4$};
  \node[state] (5)     [below right of=0]               {$b_5$};
  \node[state] (6)     [right of=5]               {$a_6$};


  \path %(I) edge[loop above]              node {$a,b$} (I)
(0) edge      []        node {$a_1$} (1)
(0) edge      []        node {$b_5$} (5)
(1) edge      []        node {$b_2$} (2)
(5) edge      [bend right=15]        node {$a_6$} (6)
(6) edge      [bend left]        node {$b_5$} (5)
(6) edge      []        node {$a_1$} (1)
;

\end{tikzpicture}
\end{figure}

Après la lecture d'un $b_2$, on peut lire un $b_3$, mais aussi sauter $b_3^*$ et aller directement lire un $a_4$. En $b_3$, on peut boucler ou passer en $a_4$. En $a_4$, comme en $a_6$, on peut lire $a_1$ ou $b_5$. On a donc :

\begin{figure}[H]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.5cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]

  \node[initial,state] (0)                    {$0$};
  \node[state] (1)   [above right of=0]                {$a_1$};
  \node[state] (2)    [right of=1]     {$b_2$};
  \node[state] (3)             [right of=2]       {$b_3$};
  \node[state] (4)        [right of=3]            {$a_4$};
  \node[state] (5)     [below right of=0]               {$b_5$};
  \node[state] (6)     [right of=5]               {$a_6$};


  \path %(I) edge[loop above]              node {$a,b$} (I)
(0) edge      []        node {$a_1$} (1)
(0) edge      []        node {$b_5$} (5)
(1) edge      []        node {$b_2$} (2)
(2) edge      []        node {$b_3$} (3)
(2) edge      [bend right=35]        node {$a_4$} (4)
(3) edge      []        node {$a_4$} (4)
(3) edge      [loop above]        node {$b_3$} (3)
(4) edge      [bend right=50]        node {$a_1$} (1)
(4) edge      [bend left=15]        node {$b_5$} (5)
(5) edge      [bend right=15]        node {$a_6$} (6)
(6) edge      [bend left]        node {$b_5$} (5)
(6) edge      []        node {$a_1$} (1)
;

\end{tikzpicture}
\end{figure}

On peut arrêter de boucler quand on vient de lire un $a_4$ ou un $a_6$, ce qui veut dire que les états correspondant vont être terminaux. De plus, l'expression rationnelle contient le mot vide, ce qui veut dire que l'état initial doit être terminal. Il ne nous reste plus qu'à "déspécialiser" les lettres, et éventuellement renommer les états :


\begin{figure}[H]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.5cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]

  \node[initial,state,accepting] (0)                    {$0$};
  \node[state] (1)   [above right of=0]                {$1$};
  \node[state] (2)    [right of=1]     {$2$};
  \node[state] (3)             [right of=2]       {$3$};
  \node[state,accepting] (4)        [right of=3]            {$4$};
  \node[state] (5)     [below right of=0]               {$5$};
  \node[state,accepting] (6)     [right of=5]               {$6$};


  \path %(I) edge[loop above]              node {$a,b$} (I)
(0) edge      []        node {$a$} (1)
(0) edge      []        node {$b$} (5)
(1) edge      []        node {$b$} (2)
(2) edge      []        node {$b$} (3)
(2) edge      [bend right=35]        node {$a$} (4)
(3) edge      []        node {$a$} (4)
(3) edge      [loop above]        node {$b$} (3)
(4) edge      [bend right=50]        node {$a$} (1)
(4) edge      [bend left=15]        node {$b$} (5)
(5) edge      [bend right=15]        node {$a$} (6)
(6) edge      [bend left]        node {$b$} (5)
(6) edge      []        node {$a$} (1)
;

\end{tikzpicture}
\end{figure}
\end{example}

On a présenté l'algorithme \textit{via} un exemple, mais il repose bien évidemment sur des définitions formelles, procédant par induction sur l'expression. Une fois qu'on a spécialisé les lettres et crée les états comme dans l'exemple, on veut d'abord savoir si l'expression rationnelle donnée accepte ou non le mot vide. C'est à cette question que répond la fonction suivante :

\[
\begin{cases}
E(\epsilon) = \top \\
E(a) = \bot \\
E(e_1+e_2) = E(e_1) \vee E(e_2) \\
E(e_1.e_2) = E(e_1) \wedge E(e_2) \\
E(e^*) = \top
\end{cases}
\]

L'état initial est terminal ssi. $E(e) = \top$. Pour les premières transitions, qui partiront de l'état initial $0$, on a besoin de déterminer quelles lettres peuvent commencer les mots reconnus par l'expression, ce que fait la fonction suivante : 

\[
\begin{cases}
D(\epsilon) = \emptyset \\
D(a) = \{a\} \\
D(e_1+e_2) = D(e_1) \cup D(e_2) \\
D(e_1.e_2) = D(e_1) & \text{Si } e_1 \text{ n'accepte pas le mot vide, cad. si }\neg E(e_1)\\
D(e_1.e_2) = D(e_1) \cup D(e_2) & \text{sinon}  \\
D(e^*) = D(e)
\end{cases}
\]

On ajoute une transition $0 \xrightarrow{q} q$ pour tout $q \in D(e)$. De même, on a besoin de savoir quelles lettres peuvent finir les mots du langage dénoté par une expression : 

\[
\begin{cases}
F(\epsilon) = \emptyset \\
F(a) = \{a\} \\
F(e_1+e_2) = F(e_1) \cup F(e_2) \\
F(e_1.e_2) = F(e_2) & \text{Si } e_2 \text{ n'accepte pas le mot vide, cad. si} \neg E(e_2)\\f
F(e_1.e_2) = F(e_1) \cup F(e_2) & \text{sinon}  \\
F(e^*) = F(e)
\end{cases}
\]


Tout les états de $F$ sont terminaux. En plus des premières transitions, on veut bien sûr les autres. Pour ça, on calcule l'ensemble des lettres qui peuvent se suivre dans le langage dénoté par l'expression :

\[
\begin{cases}
P(\epsilon) = \emptyset \\
P(a) = \emptyset \\
P(e_1+e_2) = P(e_1) \cup P(e_2) \\
P(e_1.e_2) = P(e_1) \cup P(e_2) \cup F(e_1).D(e_2) \\
P(e^*) = P(e) \cup F(e).D(e) 
\end{cases}
\]

Toute paire $\big \langle q_1, q_2 \big \rangle$ appartenant à $P(e)$ génère donc une transition $q_1 \xrightarrow{q_2} q_2$ dans l'automate.


\begin{exercice}
Utiliser l'algorithme de Glushkov pour traduire en automate l'expression \newline $e = (bb)^*(b(a+b)^*)^*$
\end{exercice}

\subsection{Méthode des résiduels}

Janusz A. Brzozowski introduit en 1964 la notion de dérivée partielle d'expression rationnelle, parfois appelée \textbf{dérivée de Brzozowski}, qu'il utilise dans un algorithme traduisant une regex en automate fini, déterministe et complet. En 1996, Valentin Antimirov propose une variation de la dérivation et de l'algorithme, qui produit un automate potentiellement non-déterministe mais minimal. On donnera ici une version quelque peu édulcorée de cette méthode générale via un exemple, pour en faire passer l'idée, puis on en fournira les bases techniques.


\begin{example}

On veut obtenir un automate reconnaissant le langage dénoté par l'expression $c(ab)^*ac + aac(ab)^*$. Pour ça, on va utiliser des états dont les noms sont, souf forme d'expression rationnelle, le langage qu'il nous reste à lire une fois qu'on les a atteints. Ce "langage qu'il nous reste à lire" est ce qu'on appelle un \textbf{résiduel}.

Au tout début de la lecture d'un mot, l'expression qu'il nous reste à reconnaître est bien évidemment $c(ab)^*ac + aac(ab)^*$ (qu'on écrira $e$). On a donc notre état initial :


\begin{figure}[H]
\centering

\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.5cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]

  \node[initial,state] (0) []                    {$e$};
  \node[] (a) [above right of=0]                    {};%{$ac(ab)^*$};
  \node[] (c) [below right of=0]                    {};%{$(ab)^*ac$};
  \node[] (aa) [right of=a]                    {};%{$c(ab)^*$};
  \node[] (ca) [right of=c]                    {};%{$b(ab)^*ac+c$};
    \node[] (aac) [right of=aa]                    {};%{$(ab)^*$};
    \node[] (aaca) [right of=aac]                   {};% {$b(ab)^*$};
  \node[] (cac) [below right of=ca]                  {};%  {$\epsilon$};

\end{tikzpicture}
%\caption{Automate reconnaissant $c(ab)^*ac + aac(ab)^*$}
\end{figure}

Il faut ensuite déterminer ce qu'il nous resterait à lire après un $a$ pour être dans l'expression $e$. On note ce langage $a^{-1}e = a^{-1}(c(ab)^*ac + aac(ab)^*)$.
Puisque $e$ est l'ensemble des mots de la forme $c(ab)^*ac$ ou $aac(ab)^*$, donc $a^{-1}e$ est l'ensemble des mots de la forme $a^{-1}c(ab)^*ac$ ou $a^{-1}aac(ab)^*$.

La notation $a^{-1}c(ab)^*ac$ dénote l'ensemble des mots $u$ tels que $au$ appartienne au langage $c(ab)^*ac$. On voit bien qu'il y a une incompatibilité au niveau de la première lettre, ce langage est donc vide.

En revanche, la notation $a^{-1}aac(ab)^*$ n'est pas vide. Il s'agit en effet de l'ensemble des mots $u$ tels que $au$ soit de la forme $aac(ab)^*$, c'est-à-dire $ac(ab)^*$. On intègre cette donnée à l'automate, en ajoutant un état et une transition disant que, quand on doit reconnaître $e$ et qu'on lit un $a$, il nous reste à lire un mot de la forme $ac(ab)^*$ :



\begin{figure}[H]
\centering

\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.5cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]

  \node[initial,state] (0) []                    {$e$};
  \node[state] (a) [above right of=0]                    {$ac(ab)^*$};
  \node[] (c) [below right of=0]                    {};%{$(ab)^*ac$};
  \node[] (aa) [right of=a]                    {};%{$c(ab)^*$};
  \node[] (ca) [right of=c]                    {};%{$b(ab)^*ac+c$};
    \node[] (aac) [right of=aa]                   {};% {$(ab)^*$};
    \node[] (aaca) [right of=aac]                   {};% {$b(ab)^*$};
  \node[] (cac) [below right of=ca]                {};%    {$\epsilon$};

  \path %(I) edge[loop above]              node {$a,b$} (I)

(0) edge      []        node {$a$} (a)
;
\end{tikzpicture}
\end{figure}

De même, on calcule $b^{-1}e = b^{-1}(c(ab)^*ac + aac(ab)^*) = b^{-1}(c(ab)^*ac + b^{-1}aac(ab)^*$. On voit que le langage est vide, puisqu'on cherche des mots qui commencent à la fois par $b$ et soit $c$ soit $a$. On n'ajoute donc pas d'état et de transition.

On calcule aussi $c^{-1}e = c^{-1}(c(ab)^*ac + aac(ab)^*) = c^{-1}(c(ab)^*ac + c^{-1}aac(ab)^*$. La partie droite du résiduelle est vide, mais pas la partie gauche. On a en effet $c^{-1}(c(ab)^*ac + c^{-1}aac(ab)^* = (ab)^*ac$. On ajoute donc l'état et la transition correspondant :



\begin{figure}[H]
\centering

\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.5cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]

  \node[initial,state] (0) []                    {$e$};
  \node[state] (a) [above right of=0]                    {$ac(ab)^*$};
  \node[state] (c) [below right of=0]                    {$(ab)^*ac$};
  \node[] (aa) [right of=a]                    {};%{$c(ab)^*$};
  \node[] (ca) [right of=c]                    {};%{$b(ab)^*ac+c$};
    \node[] (aac) [right of=aa]                   {};% {$(ab)^*$};
    \node[] (aaca) [right of=aac]                   {};% {$b(ab)^*$};
  \node[] (cac) [below right of=ca]                {};%    {$\epsilon$};

  \path %(I) edge[loop above]              node {$a,b$} (I)

(0) edge      []        node {$a$} (a)
(0) edge      []        node {$c$} (c)

;
\end{tikzpicture}
\end{figure}

On continue sur la partie haute de l'automate. On a 

\begin{itemize}
\item $a^{-1}ac(ab)^* = c(ab)^*$
\item $b^{-1}ac(ab)^* = c^{-1}ac(ab)^* = \emptyset$
\end{itemize}

puis

\begin{itemize}
\item $c^{-1}c(ab)^* = (ab)^*$
\item $a^{-1}c(ab)^* = b^{-1}c(ab)^* = \emptyset$
\end{itemize}

On met à jour l'automate : 


\begin{figure}[H]
\centering

\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.5cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]

  \node[initial,state] (0) []                    {$e$};
  \node[state] (a) [above right of=0]                    {$ac(ab)^*$};
  \node[state] (c) [below right of=0]                    {$(ab)^*ac$};
  \node[state] (aa) [right of=a]                    {$c(ab)^*$};
  \node[] (ca) [right of=c]                    {};%{$b(ab)^*ac+c$};
    \node[state] (aac) [right of=aa]                   {$(ab)^*$};
    \node[] (aaca) [right of=aac]                   {};% {$b(ab)^*$};
  \node[] (cac) [below right of=ca]                {};%    {$\epsilon$};

  \path %(I) edge[loop above]              node {$a,b$} (I)

(0) edge      []        node {$a$} (a)
(0) edge      []        node {$c$} (c)
(a) edge      []        node {$a$} (aa)
(aa) edge      []        node {$c$} (aac)

;
\end{tikzpicture}
\end{figure}

On s'intéresse ensuite à $(ab)^*$. Si un mot de $(ab)^*$ commence par $a$, c'est que l'étoile a été utilisée au moins une fois. Dans ce cas, l'expression "visée" est en fait $ab(ab)^*$. Le résiduel $a^{-1}(ab)^*$ est donc $a^{-1}ab(ab)^* = b(ab)^*$. Par le même raisonnement, $b^{-1}(ab)^* = c^{-1}(ab)^* = \emptyset$ :


\begin{figure}[H]
\centering

\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.5cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]

  \node[initial,state] (0) []                    {$e$};
  \node[state] (a) [above right of=0]                    {$ac(ab)^*$};
  \node[state] (c) [below right of=0]                    {$(ab)^*ac$};
  \node[state] (aa) [right of=a]                    {$c(ab)^*$};
  \node[] (ca) [right of=c]                    {};%{$b(ab)^*ac+c$};
    \node[state] (aac) [right of=aa]                   {$(ab)^*$};
    \node[state] (aaca) [right of=aac]                   {$b(ab)^*$};
  \node[] (cac) [below right of=ca]                {};%    {$\epsilon$};

  \path %(I) edge[loop above]              node {$a,b$} (I)

(0) edge      []        node {$a$} (a)
(0) edge      []        node {$c$} (c)
(a) edge      []        node {$a$} (aa)
(aa) edge      []        node {$c$} (aac)
(aac) edge      [bend left]        node {$a$} (aaca)


;
\end{tikzpicture}
\end{figure}

Le seul résiduel non-vide de $b(ab)^*$ est $b^{-1}b(ab)^* = (ab)^*$. On revient donc sur l'état précédent : 


\begin{figure}[H]
\centering

\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.5cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]

  \node[initial,state] (0) []                    {$e$};
  \node[state] (a) [above right of=0]                    {$ac(ab)^*$};
  \node[state] (c) [below right of=0]                    {$(ab)^*ac$};
  \node[state] (aa) [right of=a]                    {$c(ab)^*$};
  \node[] (ca) [right of=c]                    {};%{$b(ab)^*ac+c$};
    \node[state] (aac) [right of=aa]                   {$(ab)^*$};
    \node[state] (aaca) [right of=aac]                   {$b(ab)^*$};
  \node[] (cac) [below right of=ca]                {};%    {$\epsilon$};

  \path %(I) edge[loop above]              node {$a,b$} (I)

(0) edge      []        node {$a$} (a)
(0) edge      []        node {$c$} (c)
(a) edge      []        node {$a$} (aa)
(aa) edge      []        node {$c$} (aac)
(aac) edge      [bend left]        node {$a$} (aaca)
(aaca) edge      [bend left]        node {$b$} (aac)


;
\end{tikzpicture}
\end{figure}

On revient maintenant sur la partie basse de l'automate, en particulier l'état $(ab)^*ac$. On peut \textit{unfolder} manuellement l'étoile, en séparant les cas où elle est instanciée zéro ou au moins une fois, ce qui donne l'expression $ab(ab)^*ac + ac$. On peut maintenant calculer le résiduel $a^{-1}(ab)^*ac = a^{-1}(ab(ab)^*ac + ac) = b(ab)^*ac + c$. Les résiduels en $b$ et $c$ sont par contre vides : 


\begin{figure}[H]
\centering

\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.5cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]

  \node[initial,state] (0) []                    {$e$};
  \node[state] (a) [above right of=0]                    {$ac(ab)^*$};
  \node[state] (c) [below right of=0]                    {$(ab)^*ac$};
  \node[state] (aa) [right of=a]                    {$c(ab)^*$};
  \node[state] (ca) [right of=c]                    {$b(ab)^*ac+c$};
    \node[state] (aac) [right of=aa]                   {$(ab)^*$};
    \node[state] (aaca) [right of=aac]                   {$b(ab)^*$};
  \node[] (cac) [below right of=ca]                {};%    {$\epsilon$};

  \path %(I) edge[loop above]              node {$a,b$} (I)

(0) edge      []        node {$a$} (a)
(0) edge      []        node {$c$} (c)
(a) edge      []        node {$a$} (aa)
(aa) edge      []        node {$c$} (aac)
(aac) edge      [bend left]        node {$a$} (aaca)
(aaca) edge      [bend left]        node {$b$} (aac)
(ca) edge      [bend right]        node {$b$} (c)


;
\end{tikzpicture}
\end{figure}

En calculant les derniers résiduels, on arrive à 



\begin{figure}[H]
\centering

\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.5cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]

  \node[initial,state] (0) []                    {$e$};
  \node[state] (a) [above right of=0]                    {$ac(ab)^*$};
  \node[state] (c) [below right of=0]                    {$(ab)^*ac$};
  \node[state] (aa) [right of=a]                    {$c(ab)^*$};
  \node[state] (ca) [right of=c]                    {$b(ab)^*ac+c$};
    \node[state] (aac) [right of=aa]                   {$(ab)^*$};
    \node[state] (aaca) [right of=aac]                   {$b(ab)^*$};
  \node[state] (cac) [below right of=ca]                  {$\epsilon$};


  \path %(I) edge[loop above]              node {$a,b$} (I)

(0) edge      []        node {$a$} (a)
(0) edge      []        node {$c$} (c)

(a) edge      []        node {$a$} (aa)
(c) edge      [bend right]        node {$a$} (ca)

(aa) edge      []        node {$c$} (aac)
(aac) edge      [bend left]        node {$a$} (aaca)
(aaca) edge      [bend left]        node {$b$} (aac)
(ca) edge      [bend right]        node {$b$} (c)
(ca) edge      []        node {$c$} (cac)


;
\end{tikzpicture}
\end{figure}

Il ne nous manque plus que les états terminaux. On devrait pouvoir arrêter notre lecture ssi.  le langage qu'il nous reste à reconnaître contient le mot vide. Les états terminaux sont donc ceux dont le langage dénoté par l'expression rationnelle contient $\epsilon$, par exemple en utilisant la fonction $E$ donnée dans en \ref{glushkov}. Au final, l'automate est donc 


\begin{figure}[H]
\centering

\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.5cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]

  \node[initial,state] (0) []                    {$e$};
  \node[state] (a) [above right of=0]                    {$ac(ab)^*$};
  \node[state] (c) [below right of=0]                    {$(ab)^*ac$};
  \node[state] (aa) [right of=a]                    {$c(ab)^*$};
  \node[state] (ca) [right of=c]                    {$b(ab)^*ac+c$};
    \node[state,accepting] (aac) [right of=aa]                    {$(ab)^*$};
    \node[state] (aaca) [right of=aac]                    {$b(ab)^*$};
  \node[state,accepting] (cac) [below right of=ca]                    {$\epsilon$};

  \path %(I) edge[loop above]              node {$a,b$} (I)

(0) edge      []        node {$a$} (a)
(0) edge      []        node {$c$} (c)

(a) edge      []        node {$a$} (aa)
(c) edge      [bend right]        node {$a$} (ca)

(aa) edge      []        node {$c$} (aac)
(aac) edge      [bend left]        node {$a$} (aaca)
(aaca) edge      [bend left]        node {$b$} (aac)
(ca) edge      [bend right]        node {$b$} (c)
(ca) edge      []        node {$c$} (cac)


;
\end{tikzpicture}
\caption{Automate reconnaissant $c(ab)^*ac + aac(ab)^*$}
\end{figure}

\end{example}

On a fait l'exemple précédent \textit{avec les mains}, mais la dérivée est bien sûr formellement définie comme suit : 

\[
\begin{cases}
a^{-1}\epsilon = \emptyset \\
a^{-1}a = \epsilon \\
a^{-1}b = \emptyset \\
a^{-1}(e_1+e_2) = a^{-1}e_1 + a^{-1}e_2 \\
a^{-1}(e_1.e_2) = (a^{-1}e_1)e_2 & \text{Si } e_1 \text{ n'accepte pas le mot vide, cad. si }\neg E(e_1) \\
a^{-1}(e_1.e_2) = (a^{-1}e_1)e_2 + a^{-1}e_2 & \text{sinon}  \\
a^{-1}e^* = (a^{-1}e)e^*
\end{cases}
\]

\begin{example}
En appliquant ces calculs à l'expression $c(ab)^*ac + aac(ab)^*$, on retrouve la construction de notre automate :


\begin{itemize}
    \item $a^{-1}(c(ab)^*ac + aac(ab)^*) = a^{-1}c(ab)^*ac + a^{-1}aac(ab)^* = a^{-1}aac(ab)^* = ac(ab)^*$
    \begin{itemize}
        \item $a^{-1} ac(ab)^* = c(ab)^*$
        \begin{itemize}
            \item $a^{-1}c(ab)^* = b^{-1}c(ab)^* = \emptyset$
            \item $c^{-1}c(ab)^* = \textcolor{red}{(ab)^*}$
            \begin{itemize}
                \item $a^{-1}(ab)^* = b(ab)^*$
                \begin{enumerate}
                    \item[] $~~~~a^{-1}b(ab)^* = c^{-1}b(ab)^* = \emptyset$
                    \item[] $~~~~b^{-1}b(ab)^* = \textcolor{red}{(ab)^*}$
                \end{enumerate}
                \item $b^{-1}(ab)^* = c^{-1}(ab)^* = \emptyset$
            \end{itemize}
        \end{itemize}
        \item $b^{-1} ac(ab)^* = c^{-1} ac(ab)^* = \emptyset$
    \end{itemize}
    \item $b^{-1}(c(ab)^*ac + aac(ab)^*) = \emptyset$
    \item $c^{-1}(c(ab)^*ac + aac(ab)^*) = c^{-1}c(ab)^*ac + c^{-1}aac(ab)^* = c^{-1}c(ab)^*ac = \textcolor{blue}{(ab)^*ac}$
    \begin{itemize}
        \item $a^{-1}(ab)^*ac = b(ab)^*ac + c$
        \begin{itemize}
            \item $a^{-1}(b(ab)^*ac + c) = \emptyset$
            \item $b^{-1}(b(ab)^*ac + c) = \textcolor{blue}{(ab)^*ac}$
            \item $c^{-1}(b(ab)^*ac + c) = \epsilon$
        \end{itemize}
        \item $b^{-1}(ab)^*ac = c^{-1}(ab)^*ac = \emptyset$
    \end{itemize}
\end{itemize}
\end{example}


Une grande difficulté, qu'on a évitée dans l'exemple ci-dessus, est l'identification d'expressions rationnelles équivalentes. En effet, si on applique la méthode à l'expression $(aa)^*+aa$, la dérivée par $aa$ va nous emmener sur $(aa)^* + \epsilon$, qui est une expression syntaxiquement différente, mais sémantiquement identique, en ce qu'elle dénote le même langage. Si on utilise deux états différents pour ces expressions, l'automate obtenu ne sera pas minimal. C'est sur la gestion de ce problème que différent les méthodes de Brzozowski et Antimirov, différences qui ne sont pas étudiées ici. 



\paragraph*{Remarque} On a présenté dans cette section différents algorithmes comme des preuves de la "traductabilité" des expressions rationnelles en automates finis. Si on était vraiment rigoureux, les algorithmes ne suffiraient pas, il faudrait aussi prouver 1) qu'ils terminent sur toute entrée 2) qu'ils produisent bien un automate fini acceptant le langage décrit par l'expression donnée. Ces preuves sont autrement plus complexes que l'écriture des algorithmes\footnote{On entend souvent dire que la preuve d'un programme ou algorithme est au moins un ordre de grandeur plus complexe que l'écriture de ce dernier} et vont au-delà du programme du cours, mais il est toujours bon de garder son esprit critique face à ces choses. Cette remarque s'applique bien évidemment également à l'algorithme présenté dans les pages qui suivent pour la traduction inverse.



\section{Des automates aux expressions rationnelles - algorithme de McNaughton et Yamada}

On veut maintenant prouver le théorème suivant :

\begin{theorem}
Les langages reconnaissables par automate fini sont représentables par expression rationnelle.
\end{theorem}

On en présente ici une preuve constructive, connue sous le nom d'algorithme de McNaughton et Yamada.

\begin{proof}
Soit un automate $A$ ayant comme ensemble d'états $Q$. L'idée va être de calculer, pour toute paire d'états $(i,j)$, les ensembles de mots permettant d'aller de $i$ à $j$ en n'utilisant qu'une sélection d'états. On va faire ces calculs pour des sélections minimales, et grossir petit à petit, jusqu'à ne plus avoir de contrainte. 


On introduit pour ça la notation $L_{i,j}^X$, qui représente sous forme d'expression rationnelle l'ensemble des mots \underline{non-vides} menant de $i$ à $j$ en n'utilisant \underline{comme états intermédiaires} que des états appartenant à l'ensemble $X$. Par exemple, dans l'automate  

\begin{figure}[H]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.5cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]

  \node[initial,state] (0)                    {$0$};
  \node[initial,state,accepting] (1)   [above right of=0]                {$1$};
  \node[state] (2)    [below right of=0]     {$2$};
  \node[state,accepting] (3)             [right=2.5cm of 0]       {$3$};


  \path %(I) edge[loop above]              node {$a,b$} (I)
(0) edge      [loop above]        node {$a$} (0)
(1) edge      [loop above]        node {$c$} (1)
(2) edge      [loop below]        node {$d$} (2)
(0) edge      []        node {$a$} (1)
(0) edge      []        node {$b$} (2)
(1) edge      []        node {$b$} (3)
(2) edge      []        node {$a$} (3)
;

\end{tikzpicture}
\end{figure}

$L_{0,3}^{\{1\}} = ac^*b$. En effet, on ne peut pas boucler en $0$ car il servirait alors d'état intermédiaire, alors qu'il ne fait pas partie de ceux autorisés. De même, on ne peut pas passer par l'état $2$. On peut en revanche boucler sur $1$, d'où le $c^*$ dans la regex.

On commence en calculer tous les $L_{i,j}^{\emptyset}$. Puisqu'on n'a pas le droit au moindre état intermédiaire, $L_{i,j}^{\emptyset}$ vaut la lettre étiquettant la transition de $i$ à $j$ si elle existe, et $\emptyset$ sinon. Dans notre exemple, on a donc 

\begin{itemize}
\item En partant de $0$ :
   \begin{itemize}
	 \item $L_{0,0}^{\emptyset} = a$
	 \item $L_{0,1}^{\emptyset} = a$
	 \item $L_{0,2}^{\emptyset} = b$
	 \item $L_{0,3}^{\emptyset} = \emptyset$
   \end{itemize}
\item En partant de $1$ :
   \begin{itemize}
	 \item $L_{1,0}^{\emptyset} = \emptyset$
	 \item $L_{1,1}^{\emptyset} = c$
	 \item $L_{1,2}^{\emptyset} = \emptyset$
	 \item $L_{1,3}^{\emptyset} = b$
   \end{itemize}
\item En partant de $2$ :
   \begin{itemize}
	 \item $L_{2,0}^{\emptyset} = \emptyset$
	 \item $L_{2,1}^{\emptyset} = \emptyset$
	 \item $L_{2,2}^{\emptyset} = d$
	 \item $L_{2,3}^{\emptyset} = a$
   \end{itemize}
\item En partant de $3$ :
   \begin{itemize}
	 \item $L_{3,0}^{\emptyset} = \emptyset$
	 \item $L_{3,1}^{\emptyset} = \emptyset$
	 \item $L_{3,2}^{\emptyset} = \emptyset$
	 \item $L_{3,3}^{\emptyset} = \emptyset$
   \end{itemize}
\end{itemize}

Maintenant qu'on a notre cas de base, il s'agit de passer aux étapes suivantes en ajoutant de nouveaux états. Si on a tous nos $L_{i,j}^X$ et qu'on veut s'autoriser à passer par l'état $q$, on va utiliser la formule 

\[
L_{i,j}^{X \cup \{q\}} = L_{i,j}^X \cup L_{i,q}^X(L_{q,q}^X)^*L_{q,j}^X
\]

L'idée est que, pour aller de $i$ à $j$ en ayant le droit d'utiliser les états de $X$ et $q$, on passe ou non par $q$. Le deuxième cas est pris en compte la partie gauche de l'union ensembliste.

Supposons maintenant qu'on aille de $i$ à $j$ en passant au moins une fois par $q$. Dans ce cas, notre parcours commence par un chemin de $i$ à $q$ sans passer par $q$, cad. par la lecture d'un mot appartenant à $L_{i,q}^X$.

Le parcours peut passer plus d'une fois par $q$. On s'autoriste donc à faire des chemins de $q$ à $q$, ce qui correspond à la partie $(L_{q,q}^X)^*$ de la formule.

Enfin, une fois qu'on a fait notre dernier passage par l'état $q$, il faut finir notre parcours en allant en $j$ : $L_{q,j}^X$.

En résumé, pour calculer l'ensemble des mots menant de $i$ à $j$ en passant par les états de $X$ ou $q$, on isole explicitement les éventuels passages par $q$ pour pouvoir se ramener au cas précédent, où seuls les états appartenant à $X$ sont autorisés. On peut donc maintenant avancer les calculs pour notre automate, par exemple en autorisant maintenant les passages par l'état $1$ (l'ordre dans lequel on ajoute les états ne change pas le résultat, mais peut rendre les calculs plus ou moins longs) :


\begin{itemize}
\item En partant de $0$ :
   \begin{itemize}
	 \item $L_{0,0}^{\emptyset \cup \{1\}} = L_{0,0}^{\emptyset} \cup L_{0,1}^{\emptyset}(L_{1,1}^{\emptyset})^*L_{1,0}^{\emptyset} = a + a(c)^*\emptyset = a$\footnote{Pour rappel, $L\emptyset = \emptyset L = \emptyset$ pour tout langage $L$}
	 \item $L_{0,1}^{\{1\}} = L_{0,1}^{\emptyset} \cup L_{0,1}^{\emptyset}(L_{1,1}^{\emptyset})^*L_{1,1}^{\emptyset} = a + ac^*c = a + ac^+ = ac^*$
	 \item $L_{0,2}^{\{1\}} = L_{0,2}^{\emptyset} \cup L_{0,1}^{\emptyset}(L_{1,1}^{\emptyset})^*L_{1,2}^{\emptyset} = b + ac^*\emptyset = b$
	 \item $L_{0,3}^{\{1\}} = L_{0,3}^{\emptyset} \cup L_{0,1}^{\emptyset}(L_{1,1}^{\emptyset})^*L_{1,3}^{\emptyset} = ac^*b$
   \end{itemize}
\item En partant de $1$ :
   \begin{itemize}
	 \item $L_{1,0}^{\{1\}} = L_{1,0}^{\emptyset} \cup L_{1,1}^{\emptyset}(L_{1,1}^{\emptyset})^*L_{1,0}^{\emptyset} = \emptyset$
	 \item $L_{1,1}^{\{1\}} = L_{1,1}^{\emptyset} \cup L_{1,1}^{\emptyset}(L_{1,1}^{\emptyset})^*L_{1,1}^{\emptyset} = c + cc^*c = c^+$
	 \item $L_{1,2}^{\{1\}} = L_{1,2}^{\emptyset} \cup L_{1,1}^{\emptyset}(L_{1,1}^{\emptyset})^*L_{1,2}^{\emptyset} = \emptyset$
	 \item $L_{1,3}^{\{1\}} = L_{1,3}^{\emptyset} \cup L_{1,1}^{\emptyset}(L_{1,1}^{\emptyset})^*L_{1,3}^{\emptyset} = b + cc^*b = b + c^+b = c^*b$
   \end{itemize}
\item En partant de $2$ :
   \begin{itemize}
	 \item $L_{2,0}^{\{1\}} = L_{2,0}^{\emptyset} \cup L_{2,1}^{\emptyset}(L_{1,1}^{\emptyset})^*L_{1,0}^{\emptyset} = \emptyset$
	 \item $L_{2,1}^{\{1\}} = L_{2,1}^{\emptyset} \cup L_{2,1}^{\emptyset}(L_{1,1}^{\emptyset})^*L_{1,1}^{\emptyset} = \emptyset$
	 \item $L_{2,2}^{\{1\}} = L_{2,2}^{\emptyset} \cup L_{2,1}^{\emptyset}(L_{1,1}^{\emptyset})^*L_{1,2}^{\emptyset} = d$
	 \item $L_{2,3}^{\{1\}} = L_{2,3}^{\emptyset} \cup L_{2,1}^{\emptyset}(L_{1,1}^{\emptyset})^*L_{1,3}^{\emptyset} = a$
   \end{itemize}
\item En partant de $3$, vu que $L_{3,j}^{\emptyset} = \emptyset$ pour tout état $j$, on n'arrivera jamais à aller plus loin. Donc $L_{3,j}^{\{1\}} = \emptyset$ pour tout $j$.
\end{itemize}

On continue en ajoutant $2$ : 


\begin{itemize}
\item En partant de $0$ :
   \begin{itemize}
	 \item $L_{0,0}^{\{1\} \cup \{2\}} = L_{0,0}^{\{1\}} \cup L_{0,2}^{\{1\}}(L_{2,2}^{\{1\}})^*L_{2,0}^{\{1\}} = a$
	 \item $L_{0,1}^{\{1,2\}} = L_{0,1}^{\{1\}} \cup L_{0,2}^{\{1\}}(L_{2,2}^{\{1\}})^*L_{2,1}^{\{1\}} = ac^*$
	 \item $L_{0,2}^{\{1,2\}} = L_{0,2}^{\{1\}} \cup L_{0,2}^{\{1\}}(L_{2,2}^{\{1\}})^*L_{2,2}^{\{1\}} = b + bd^*d = bd^*$
	 \item $L_{0,3}^{\{1,2\}} = L_{0,3}^{\{1\}} \cup L_{0,2}^{\{1\}}(L_{2,2}^{\{1\}})^*L_{2,3}^{\{1\}} = ac^*b + bd^*a$
   \end{itemize}
\item En partant de $1$ :
   \begin{itemize}
	 \item $L_{1,0}^{\{1,2\}} = L_{1,0}^{\{1\}} \cup L_{1,2}^{\{1\}}(L_{2,2}^{\{1\}})^*L_{2,0}^{\{1\}} = \emptyset$
	 \item $L_{1,1}^{\{1,2\}} = L_{1,1}^{\{1\}} \cup L_{1,2}^{\{1\}}(L_{2,2}^{\{1\}})^*L_{2,1}^{\{1\}} = c^+$
	 \item $L_{1,2}^{\{1,2\}} = L_{1,2}^{\{1\}} \cup L_{1,2}^{\{1\}}(L_{2,2}^{\{1\}})^*L_{2,2}^{\{1\}} = \emptyset$
	 \item $L_{1,3}^{\{1,2\}} = L_{1,3}^{\{1\}} \cup L_{1,2}^{\{1\}}(L_{2,2}^{\{1\}})^*L_{2,3}^{\{1\}} = c^*b$
   \end{itemize}
\item En partant de $2$ :
   \begin{itemize}
	 \item $L_{2,0}^{\{1,2\}} = L_{2,0}^{\{1\}} \cup L_{2,2}^{\{1\}}(L_{2,2}^{\{1\}})^*L_{2,0}^{\{1\}} = \emptyset$
	 \item $L_{2,1}^{\{1,2\}} = L_{2,1}^{\{1\}} \cup L_{2,2}^{\{1\}}(L_{2,2}^{\{1\}})^*L_{2,1}^{\{1\}} = \emptyset$
	 \item $L_{2,2}^{\{1,2\}} = L_{2,2}^{\{1\}} \cup L_{2,2}^{\{1\}}(L_{2,2}^{\{1\}})^*L_{2,2}^{\{1\}} = d + dd^*d = d^+$
	 \item $L_{2,3}^{\{1,2\}} = L_{2,3}^{\{1\}} \cup L_{2,2}^{\{1\}}(L_{2,2}^{\{1\}})^*L_{2,3}^{\{1\}} = a + dd^*a = d^*a$
   \end{itemize}
\item $L_{3,j}^{\{1,2\}} = \emptyset$ pour tout $j$.
\end{itemize}

On ajoute maintenant $0$ : 


\begin{itemize}
\item En partant de $0$ :
   \begin{itemize}
	 \item $L_{0,0}^{\{1,2\} \cup \{0\}} = L_{0,0}^{\{1,2\}} \cup L_{0,0}^{\{1,2\}}(L_{0,0}^{\{0,2\}})^*L_{0,0}^{\{1,2\}} = a + aa^*a = a^+$
	 \item $L_{0,1}^{\{0,1,2\}} = L_{0,1}^{\{1,2\}} \cup L_{0,0}^{\{1,2\}}(L_{0,0}^{\{1,2\}})^*L_{0,1}^{\{1,2\}} = ac^* + aa^*ac^* = a^+c^*$
	 \item $L_{0,2}^{\{0,1,2\}} = L_{0,2}^{\{1,2\}} \cup L_{0,0}^{\{1,2\}}(L_{0,0}^{\{1,2\}})^*L_{0,2}^{\{1,2\}} = bd^* + aa^*bd^* = a^*bd^*$
	 \item $L_{0,3}^{\{0,1,2\}} = L_{0,3}^{\{1,2\}} \cup L_{0,0}^{\{1,2\}}(L_{0,0}^{\{1,2\}})^*L_{0,3}^{\{1,2\}} = ac^*b + bd^*a + aa^*(ac^*b + bd^*a) = a^*(ac^*b + bd^*a)$
   \end{itemize}
\item Comme on en a un peu marre, on remarque que $L_{i,0}^{\{1,2\}} = \emptyset$ quand $i \neq 0$, et donc que $L_{i,0}^{\{1,2\}}(L_{0,0}^{\{1,2\}})^*L_{0,j}^{\{1,2\}} = \emptyset$ pour tout état $j$. Donc, pour les départs d'états autres que $0$, le fait de pouvoir passer par $0$ ne va rien pouvoir ajouter. On a donc $L_{i,0}^{\{0,1,2\}} = L_{i,0}^{\{1,2\}}$ pour $i \neq 0$.
\end{itemize}

De même, $L_{3,i}^{\{0,1,2\}} = \emptyset$ pour tout état $i$. On a donc $L_{i,j}^Q = L_{i,j}^{\{0,1,2\}}$ pour toute paire d'états $i$ et $j$. 


Maintenant qu'on a calculé les langages reconnus par toute paire d'états, on combine ceux qui nous intéressent. Puisque les états initiaux sont $0$ et $1$ et que les terminaux sont $1$ et $3$, le langage reconnu par l'automate est l'union des mots allant de $0$ à $1$, de $0$ à $3$, de $1$ à $1$ et de $1$ à $3$ (on fait toues les combinaisons d'état initial / état terminal).

Attention cependant, $L_{i,j}^Q$ calcule l'ensemble des mots \underline{non-vides} allant de $i$ à $j$. Donc si un état est à la fois initial et terminal, il faut ajouter à la main le mot vide.

En conclusion, le langage reconnu par l'automate de l'exemple est décrit par la regex 

\[
L_{0,1}^Q + L_{0,3}^Q + L_{1,1}^Q + L_{1,3}^Q + \epsilon = a^+c^* + a^*(ac^*b + bd^*a) + c^+ + c^*b + \epsilon
\]

\end{proof}

Etant donné un automate fini, l'algorithme de McNaughton et Yamada permet donc, bien que parfois quelque peu laborieusement, de produire une expression rationnelle décrivant le même langage, réalisant donc la deuxième partie du théorème de Kleene.
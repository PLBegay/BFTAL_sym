\chapter{Théorème de Kleene}
\label{hierarchie}

On a pour l'instant utilisé les expressions rationnelles pour décrire les langages reconnus par des automates, et utilisé des automates pour implémenter des expressions rationnelles. On a cependant vu que l'expressivité des automates était limitée, en ce qu'il existe de nombreux langages qu'ils ne peuvent reconnaître. On peut donc légitimement se demander si les expressions rationnelles sont plus ou moins expressives que les automates finis.

Le mathématicien Stephen C. Kleene (1909 - 1994) répond à cette question via le théorème qui porte son nom :

\begin{theorem}{\textbf{(Théorème de Kleene)}}
Les langages représentable par expression rationnelle sont exactement ceux reconnus par automate fini.
\end{theorem}

L'égalité entre deux ensembles $A$ et $B$ équivaut à la double inclusion entre les mêmes ensembles, cad. $A \subseteq B \wedge B \subseteq A$. On va donc chercher une preuve que chaque langage représentable par \textit{regex} est reconnaissable par automate fini, et inversement. Ces deux sous-théorèmes admettent aujourd'hui de nombreuses preuves, notamment constructives, cad. sous la forme d'algorithmes qui réalisent la transformation d'une \textit{regex} en automate, et inversement. Cette section présente plusieurs de ces algorithmes.

\section{Des expressions rationnelles aux automates}

On veut prouver ici le théorème suivant :

\begin{theorem}
Les langages représentable par expression rationnelle sont également reconnus par automate fini.
\end{theorem}

On en présente ici deux preuves différentes.

\subsection{Traduction récursive}

\begin{proof}
On va procéder par induction structurelle sur les expressions rationnelles. On en rappelle d'abord la définition récursive : 

\begin{tabular}{cccl}
$e$ & $\textcolor{black}{::=}$ & & $\epsilon$\\
& & $|$&  $a \in \Sigma$\\
& & $|$&  $e_1.e_2$\\
& & $|$&  $e_1+e_2$\\
& & $|$&  $e_1^*$\\
\end{tabular}

L'expression $\epsilon$ est clairement reconnu par l'automate 


\begin{figure}[H]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.9cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]

  \node[initial,state,accepting] (0)                    {$0$};
  
\end{tikzpicture}
\end{figure}

L'expression $a$ quant à elle est reconnue par 


\begin{figure}[H]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.9cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


  \node[initial,state] (0)                    {$0$};
  \node[state,accepting] (1)      [right of=0]                {$1$};

  \path %(I) edge[loop above]              node {$a,b$} (I)
(0) edge      []        node {$a$} (1);

\end{tikzpicture}
\end{figure}

On peut donc traduire en automates les cas de base des expressions rationnelles. Quant aux cas récursifs, on les a en fait déjà traités en \ref{cloture} : pour construire un automate reconnaissant $e_1 + e_2$, on construit des automates $A_1$ et $A_2$ reconnaissant $e_1$ et $e_2$, et on applique la construction de l'union. On procède de même avec la concaténation pour $e_1e_2$ et l'itération pour $e^*$.
\end{proof}

%\paragraph*{Remarque} Les constructions vues pour les propriétés de clôture ne sont pas optimales. L'\href{https://fr.wikipedia.org/wiki/Algorithme_de_Thompson}{algorithme de Thomson} utilise les mêmes idées mais utilise les $\epsilon-transitions$ pour qu'il n'y ait pas plus d'un état initial et un état terminal tout au long de la construction de l'automate, ce qui permet de borner plus finement sa taille.

\subsection{Traduction linéaire}

On propose un autre algorithme, qui sépare la construction des états de celles des transitions : l'\textbf{algorithme de Glushkov}.

\begin{example}

Soit $e = (abb^*a+(ba)^*)^*$. On commence par distinguer toutes les lettres de l'expression, par exemple en les indexant par leur position. On obtient donc

\[
(a_1b_2b_3^*a_4+(b_5a_6)^*)^*
\]

On crée ensuite un état pour chaque lettre, ainsi qu'un état initial $0$ :


\begin{figure}[H]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.5cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]

  \node[initial,state] (0)                    {$0$};
  \node[state] (1)   [above right of=0]                {$a_1$};
  \node[state] (2)    [right of=1]     {$b_2$};
  \node[state] (3)             [right of=2]       {$b_3$};
  \node[state] (4)        [right of=3]            {$a_4$};
  \node[state] (5)     [below right of=0]               {$b_5$};
  \node[state] (6)     [right of=5]               {$a_6$};


%  \path %(I) edge[loop above]              node {$a,b$} (I)
%(0) edge      []        node {$a$} (1);

\end{tikzpicture}
\end{figure}

Le jeu va être de représenter, avec les transitions, les "promenades" dans l'expression. Toute mot capturé par l'expression commence par $a_1$ ou $b_5$. On ajoute donc ces transitions : 


\begin{figure}[H]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.5cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]

  \node[initial,state] (0)                    {$0$};
  \node[state] (1)   [above right of=0]                {$a_1$};
  \node[state] (2)    [right of=1]     {$b_2$};
  \node[state] (3)             [right of=2]       {$b_3$};
  \node[state] (4)        [right of=3]            {$a_4$};
  \node[state] (5)     [below right of=0]               {$b_5$};
  \node[state] (6)     [right of=5]               {$a_6$};


  \path %(I) edge[loop above]              node {$a,b$} (I)
(0) edge      []        node {$a_1$} (1)
(0) edge      []        node {$b_5$} (5)
;

\end{tikzpicture}
\end{figure}


Quand on a lu un $a_1$, on est obligé de lire un $b_2$. De même, un $b_5$ est forcément suivi d'un $a_6$ :

\begin{figure}[H]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.5cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]

  \node[initial,state] (0)                    {$0$};
  \node[state] (1)   [above right of=0]                {$a_1$};
  \node[state] (2)    [right of=1]     {$b_2$};
  \node[state] (3)             [right of=2]       {$b_3$};
  \node[state] (4)        [right of=3]            {$a_4$};
  \node[state] (5)     [below right of=0]               {$b_5$};
  \node[state] (6)     [right of=5]               {$a_6$};


  \path %(I) edge[loop above]              node {$a,b$} (I)
(0) edge      []        node {$a_1$} (1)
(0) edge      []        node {$b_5$} (5)
(1) edge      []        node {$b_2$} (2)
(5) edge      [bend right=15]        node {$a_6$} (6)
;

\end{tikzpicture}
\end{figure}

Après la lecture d'un $a_6$, on peut recommencer la boucle $(b_5a_6)^*$, auquel cas on lit un $b_5$, ou recommencer la boucle entière $(a_1b_2b_3^*a_4+(b_5a_6)^*)^*$, en lisant un $a_1$ ou un $b_5$ :


\begin{figure}[H]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.5cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]

  \node[initial,state] (0)                    {$0$};
  \node[state] (1)   [above right of=0]                {$a_1$};
  \node[state] (2)    [right of=1]     {$b_2$};
  \node[state] (3)             [right of=2]       {$b_3$};
  \node[state] (4)        [right of=3]            {$a_4$};
  \node[state] (5)     [below right of=0]               {$b_5$};
  \node[state] (6)     [right of=5]               {$a_6$};


  \path %(I) edge[loop above]              node {$a,b$} (I)
(0) edge      []        node {$a_1$} (1)
(0) edge      []        node {$b_5$} (5)
(1) edge      []        node {$b_2$} (2)
(5) edge      [bend right=15]        node {$a_6$} (6)
(6) edge      [bend left]        node {$b_5$} (5)
(6) edge      []        node {$a_1$} (1)
;

\end{tikzpicture}
\end{figure}

Après la lecture d'un $b_2$, on peut lire un $b_3$, mais aussi sauter $b_3^*$ et aller directement lire un $a_4$. En $b_3$, on peut boucler ou passer en $a_4$. En $a_4$, comme en $a_6$, on peut lire $a_1$ ou $b_5$. On a donc :

\begin{figure}[H]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.5cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]

  \node[initial,state] (0)                    {$0$};
  \node[state] (1)   [above right of=0]                {$a_1$};
  \node[state] (2)    [right of=1]     {$b_2$};
  \node[state] (3)             [right of=2]       {$b_3$};
  \node[state] (4)        [right of=3]            {$a_4$};
  \node[state] (5)     [below right of=0]               {$b_5$};
  \node[state] (6)     [right of=5]               {$a_6$};


  \path %(I) edge[loop above]              node {$a,b$} (I)
(0) edge      []        node {$a_1$} (1)
(0) edge      []        node {$b_5$} (5)
(1) edge      []        node {$b_2$} (2)
(2) edge      []        node {$b_3$} (3)
(2) edge      [bend right=35]        node {$a_4$} (4)
(3) edge      []        node {$a_4$} (4)
(3) edge      [loop above]        node {$b_3$} (3)
(4) edge      [bend right=50]        node {$a_1$} (1)
(4) edge      [bend left=15]        node {$b_5$} (5)
(5) edge      [bend right=15]        node {$a_6$} (6)
(6) edge      [bend left]        node {$b_5$} (5)
(6) edge      []        node {$a_1$} (1)
;

\end{tikzpicture}
\end{figure}

On peut arrêter de boucler quand on vient de lire un $a_4$ ou un $a_6$, ce qui veut dire que les états correspondant vont être terminaux. De plus, l'expression rationnelle contient le mot vide, ce qui veut dire que l'état initial doit être terminal. Il ne nous reste plus qu'à "déspécialiser" les lettres, et éventuellement renommer les états :


\begin{figure}[H]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.5cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]

  \node[initial,state,accepting] (0)                    {$0$};
  \node[state] (1)   [above right of=0]                {$1$};
  \node[state] (2)    [right of=1]     {$2$};
  \node[state] (3)             [right of=2]       {$3$};
  \node[state,accepting] (4)        [right of=3]            {$4$};
  \node[state] (5)     [below right of=0]               {$5$};
  \node[state,accepting] (6)     [right of=5]               {$6$};


  \path %(I) edge[loop above]              node {$a,b$} (I)
(0) edge      []        node {$a$} (1)
(0) edge      []        node {$b$} (5)
(1) edge      []        node {$b$} (2)
(2) edge      []        node {$b$} (3)
(2) edge      [bend right=35]        node {$a$} (4)
(3) edge      []        node {$a$} (4)
(3) edge      [loop above]        node {$b$} (3)
(4) edge      [bend right=50]        node {$a$} (1)
(4) edge      [bend left=15]        node {$b$} (5)
(5) edge      [bend right=15]        node {$a$} (6)
(6) edge      [bend left]        node {$b$} (5)
(6) edge      []        node {$a$} (1)
;

\end{tikzpicture}
\end{figure}
\end{example}

On a présenté l'algorithme \textit{via} un exemple, mais il repose bien évidemment sur des définitions formelles, procédant par induction sur l'expression. Une fois qu'on a spécialisé les lettres et crée les états comme dans l'exemple, on veut d'abord savoir si l'expression rationnelle donnée accepte ou non le mot vide. C'est à cette question que répond la fonction suivante :

\[
\begin{cases}
E(\epsilon) = \top \\
E(a) = \bot \\
E(e_1+e_2) = E(e_1) \vee E(e_2) \\
E(e_1.e_2) = E(e_1) \wedge E(e_2) \\
E(e^*) = \top
\end{cases}
\]

L'état initial est terminal ssi. $E(e) = \top$. Pour les premières transitions, qui partiront de l'état initial $0$, on a besoin de déterminer quelles lettres peuvent commencer les mots reconnus par l'expression, ce que fait la fonction suivante : 

\[
\begin{cases}
D(\epsilon) = \emptyset \\
D(a) = \{a\} \\
D(e_1+e_2) = D(e_1) \cup D(e_2) \\
D(e_1.e_2) = D(e_1) & \text{Si } e_1 \text{ n'accepte pas le mot vide, cad. si }\neg E(e_1)\\
D(e_1.e_2) = D(e_1) \cup D(e_2) & \text{sinon}  \\
D(e^*) = D(e)
\end{cases}
\]

On ajoute une transition $0 \xrightarrow{q} q$ pour tout $q \in D(e)$. De même, on a besoin de savoir quelles lettres peuvent finir les mots du langage dénoté par une expression : 

\[
\begin{cases}
F(\epsilon) = \emptyset \\
F(a) = \{a\} \\
F(e_1+e_2) = F(e_1) \cup F(e_2) \\
F(e_1.e_2) = F(e_2) & \text{Si } e_2 \text{ n'accepte pas le mot vide, cad. si} \neg E(e_2)\\f
F(e_1.e_2) = F(e_1) \cup F(e_2) & \text{sinon}  \\
F(e^*) = F(e)
\end{cases}
\]


Tout les états de $F$ sont terminaux. En plus des premières transitions, on veut bien sûr les autres. Pour ça, on calcule l'ensemble des lettres qui peuvent se suivre dans le langage dénoté par l'expression :

\[
\begin{cases}
P(\epsilon) = \emptyset \\
P(a) = \emptyset \\
P(e_1+e_2) = P(e_1) \cup P(e_2) \\
P(e_1.e_2) = P(e_1) \cup P(e_2) \cup F(e_1).D(e_2) \\
P(e^*) = P(e) \cup F(e).D(e) 
\end{cases}
\]

Toute paire $\big \langle q_1, q_2 \big \rangle$ appartenant à $P(e)$ génère donc une transition $q_1 \xrightarrow{q_2} q_2$ dans l'automate.


\begin{exercice}
Utiliser l'algorithme de Glushkov pour traduire en automate l'expression \newline $e = (bb)^*(b(a+b)^*)^*$
\end{exercice}

\paragraph*{Remarque} On a présenté ces différents algorithmes comme des preuves de la "traductabilité" des expressions rationnelles en automates finis. Si on était vraiment rigoureux, les algorithmes ne suffiraient pas, il faudrait aussi prouver 1) qu'ils terminent sur toute entrée 2) qu'ils produisent bien un automate fini acceptant le langage décrit par l'expression donnée. Ces preuves sont autrement plus complexes que l'écriture des algorithmes\footnote{On entend souvent dire que la preuve d'un programme ou algorithme est au moins un ordre de grandeur plus complexe que l'écriture de ce dernier} et vont au-delà du programme du cours, mais il est toujours bon de garder son esprit critique face à ces choses. Cette remarque s'applique bien évidemment également à l'algorithme présenté dans les pages qui suivent pour la traduction inverse.

\documentclass{article}[11pt]


%\documentclass[runningheads,a4paper]{llncs}
%\usepackage{hyperref}
%\usepackage{ amssymb }


%\gasset{frame=false} % switch to true to add frames
%\parindent=0pt

%\usepackage{bussproofs}
%\usepackage{varwidth}
%\usepackage{xspace}
%\usepackage{verbatim}

\usepackage{float} 
\usepackage[lmargin=4cm, rmargin=4cm, tmargin=3cm, bmargin=3cm]{geometry}
\usepackage{algpseudocode}
\usepackage{pdfpages}

\usepackage{url}
\usepackage{multirow} 
\usepackage{mathtools}
\usepackage{stmaryrd}
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\DeclarePairedDelimiter{\floor}{\lfloor}{\rfloor} 
%\usepackage{xspace}
\usepackage{latexsym,amsmath,amsfonts,amssymb,stmaryrd}
\let\proof\relax
\let\endproof\relax 
\usepackage{amsthm} 
\usepackage{tikz}
\usepackage{tikz-qtree}
\usepackage{tikz-qtree-compat}

\usepackage{listings}
\usepackage{chngpage}
\DeclareMathAlphabet{\mathpzc}{OT1}{pzc}{m}{it}

\usepackage{ amssymb }
\usepackage{soul}

\usepackage{tipa}
\usepackage{stmaryrd}

\usepackage{verbatim} 
\usepackage{epsfig} 
\usepackage{graphics}
\usepackage{ mathrsfs }
\usepackage{hyperref}
\usepackage{multicol}

\usepackage{epigraph}


% \usepackage{tipa}
\usepackage{graphicx}   
%\usepackage{url}
\usepackage{wrapfig}  
\usepackage{bm}   
\usepackage{epstopdf}  
\usepackage{ upgreek }
\usepackage[all,cmtip]{xy}

\usepackage{natbib}
% \usepackage{float} 
% \usepackage[lofdepth,lotdepth]{subfig}
%\usepackage{graphicx}
\usepackage[T1]{fontenc} 
\usepackage[utf8]{inputenc}
\usepackage{etoolbox}
\usepackage{textcomp}

\usepackage{mdwtab}
\usepackage{syntax} 

\renewcommand{\syntleft}{}          % do not display '<' associated with variable, for example <A>
\renewcommand{\syntright}{}         % do not display '>' associated with variable, for example <A>


\makeatletter 
\patchcmd{\maketitle}{\@copyrightspace}{}{}{}
\makeatother 
\usepackage{mathpartir}
%\usepackage{enumitem}
%\usepackage{supertabular} 
%\usepackage{soul}
\usepackage[all]{xy}
\usepackage{xifthen}
\usepackage{placeins} 
\usepackage{amsthm}
\usepackage{amsmath}


\usepackage{pgf}
\usepackage{tikz}
\usetikzlibrary{arrows,automata}
\tikzset{initial text={}}
\usetikzlibrary{calc,shapes.multipart,chains,arrows}
%prevents second paragraph indentations 
%\usepackage{parskip}
% \usepackage{floatrow}
\usepackage{tabularx} % in the preamble
\usepackage{bm}
\usepackage{caption}
\usepackage{subcaption} 

%\input{mac}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}


\setlength{\bibsep}{0pt plus 0.5ex}





\newenvironment{mathprooftree}
  {\varwidth{.9\textwidth}\centering\leavevmode}
  {\DisplayProof\endvarwidth}


\newcommand{\qm}{\overline{Q}\overline{m}}

\newcommand{\myparagraph}[1]{\paragraph{#1}\mbox{}\\}
\newcommand\myeq{\stackrel{\mathclap{\normalfont\mbox{\scriptsize{def}}}}{=}}

\title{DM de Bases formelles du TAL}

\author{Pierre-Léo Bégay}
\date{À me rendre le 1er mai 2020}
\theoremstyle{definition}
\newtheorem{exmp}{Exemple}
   

\begin{document}
 
\maketitle
\pagestyle{empty} %
\thispagestyle{empty}

%% Attention: pas plus d'un recto-verso!
% Ne conservez pas les questions

\section{Automates}

\subsection{Complétion}

\paragraph{Question} Donnez un automate qui reconnaît le complémentaire du langage reconnu par celui-ci : 


\begin{figure}[H]
\centering

\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.5cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


  \node[initial, state, accepting] (0)                    {$0$};
  \node[state] (1)      [right of=0]                {$1$};
  \node[state,accepting] (2)      [below of=0]                {$2$};
  \node[state] (3)      [right of=2]                {$3$};
 
 
  \path %(I) edge[loop above]              node {$a,b$} (I)

(0) edge      []        node {$a$} (1)

(1) edge      []        node {$a$} (3)

(3) edge      []        node {$a$} (0)
(2) edge      []        node {$a,b$} (3)

(0) edge      []        node {$b$} (2)
;
\end{tikzpicture}
\end{figure}

\paragraph{Correction} L'algorithme de complémentation d'un automate ne s'applique qu'à un automate complet. On s'intéresse donc, après application de l'algorithme classique (ajout d'un état poubelle), à l'automate suivant : 


\begin{figure}[H]
\centering

\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.5cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


  \node[initial, state, accepting] (0)                    {$0$};
  \node[state] (1)      [right of=0]                {$1$};
  \node[state,accepting] (2)      [below of=0]                {$2$};
  \node[state] (3)      [right of=2]                {$3$};
  \node[state] (P)      [right of=1]                {$P$};
 
 
  \path %(I) edge[loop above]              node {$a,b$} (I)

(0) edge      []        node {$a$} (1)

(1) edge      []        node {$a$} (3)
(1) edge      []        node {$b$} (P)
(P) edge      [loop right]        node {$a,b$} (P)

(3) edge      []        node {$a$} (0)
(3) edge      []        node {$b$} (P)
(2) edge      []        node {$a,b$} (3)

(0) edge      []        node {$b$} (2)
;
\end{tikzpicture}
\end{figure}

\paragraph{} On inverse alors les états terminaux et non-terminaux pour obtenir l'automate reconnaissant le langage complémentaire du précédent : 


\begin{figure}[H]
\centering

\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.5cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


  \node[initial, state,] (0)                    {$0$};
  \node[state,accepting] (1)      [right of=0]                {$1$};
  \node[state] (2)      [below of=0]                {$2$};
  \node[state,accepting] (3)      [right of=2]                {$3$};
  \node[state,accepting] (P)      [right of=1]                {$P$};
 
 
  \path %(I) edge[loop above]              node {$a,b$} (I)

(0) edge      []        node {$a$} (1)

(1) edge      []        node {$a$} (3)
(1) edge      []        node {$b$} (P)
(P) edge      [loop right]        node {$a,b$} (P)

(3) edge      []        node {$a$} (0)
(3) edge      []        node {$b$} (P)
(2) edge      []        node {$a,b$} (3)

(0) edge      []        node {$b$} (2)
;
\end{tikzpicture}
\end{figure}

\subsection{Déterminisation}

\paragraph{Question 1} Déterminisez l'automate suivant :


\begin{figure}[H]
\centering

\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.5cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


  \node[initial, state] (0)                    {$0$};
  \node[state] (1)      [above right of=0]                {$1$};
  \node[state] (2)      [right of=1]                {$2$};
  \node[state] (3)      [right of=2]                {$3$};
  \node[state,accepting] (4)      [right of=3]                {$4$};
  \node[state] (5)      [below right of=0]                {$5$};
  \node[state] (6)      [right of=5]                {$6$};
  \node[state] (7)      [right of=6]                {$7$};
 \node[state,accepting] (8)      [right of=7]   
 {$8$};
 \node[state] (9)      [above left of=7]   
 {$9$};
 \node[state,accepting] (10)      [above right of=7]   
 {$10$};
  
 
  \path %(I) edge[loop above]              node {$a,b$} (I)
(0) edge      [loop above]        node {$a,b$} (0)
(2) edge      [loop above]        node {$a,b$} (2)
(4) edge      [loop above]        node {$a,b$} (4)
(8) edge      [loop below]        node {$a,b$} (8)
(9) edge      [loop left]        node {$a,b$} (9)

(0) edge      []        node {$a$} (1)

(9) edge      []        node {$b$} (7)

(7) edge      []        node {$b$} (10)

(1) edge      []        node {$a$} (2)
(2) edge      []        node {$a$} (3)

(3) edge      []        node {$a$} (4)
(0) edge      []        node {$a$} (5)

(5) edge      []        node {$b$} (6)
(6) edge      []        node {$a$} (7)

(7) edge      []        node {$a$} (8);
\end{tikzpicture}
\end{figure}

\paragraph{Correction} En appliquant l'algorithme vu en cours, on obtient 


\begin{figure}[H]
\centering

\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.5cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


  \node[initial, state] (0)                    {$0,9$};
  \node[state] (15)      [above right of=0]                {$1,5$};
  \node[state] (6)      [right of=0]                {$6$};
  \node[state] (7)      [below right of=0]                {$7$};
  \node[state,accepting] (8)      [below left of=7]                {$8$};
  \node[state,accepting] (10)      [below right of=7]                {$10$};
  \node[state] (26)      [above right of=15]                {$2,6$};
  \node[state] (2)      [above right of=26]                {$2$};
 \node[state] (23)      [right of=2]   
 {$2,3$};
  \node[state,accepting] (234)      [right of=23]   
 {$2,3,4$};
 \node[state] (237)      [below right of=26]   
 {$2,3,7$};
 \node[state,accepting] (210)      [right of=237]   
 {$2,10$};
 \node[state,accepting] (2348)      [below of=237]   
 {$2,3,4,8$};
 \node[state,accepting] (28)      [below right of=2348]   
 {$2,8$};
 \node[state,accepting] (238)      [right of=28]   
 {$2,3,8$};

  \path %(I) edge[loop above]              node {$a,b$} (I)
(0) edge      []        node {$a$} (15)
(0) edge      []        node {$b$} (7)
(15) edge      []        node {$b$} (6)
(6) edge      []        node {$a$} (7)
(7) edge      []        node {$b$} (10)
(7) edge      []        node {$a$} (8)
(8) edge      [loop left]        node {$a,b$} (8)
(15) edge      []        node {$a$} (26)
(26) edge      []        node {$b$} (2)
(26) edge      []        node {$a$} (237)
(2) edge      [bend right]        node {$a$} (23)
(2) edge      [loop above]        node {$b$} (2)
(23) edge      []        node {$a$} (234)
(23) edge      [bend right]        node {$b$} (2)
(234) edge      [loop below]        node {$a$} (234)
(234) edge      [bend right=50]        node {$b$} (2)
(237) edge      []        node {$a$} (2348)
(237) edge      []        node {$b$} (210)
(210) edge      []        node {$a$} (23)
(210) edge      []        node {$b$} (2)
(2348) edge      [loop left]        node {$a$} (2348)
(2348) edge      []        node {$b$} (28)
(28) edge      [loop left]        node {$b$} (28)
(28) edge      [bend left]        node {$a$} (238)
(238) edge      [bend left]        node {$b$} (28)
(238) edge      [bend right]        node {$a$} (2348)
;
\end{tikzpicture}
\end{figure}

\paragraph{Question 2} Donnez une expression rationnelle décrivant le langage reconnu par l'automate.

\paragraph{Correction} L'automate étant relativement linéaire\footnote{Dans le sens où on repère les quelques "couloirs" qui le composent}, pas la peine d'utiliser McNaughton et Yamada. Tout parcours acceptant va de 0 à 4, 0 à 10, 0 à 8, 9 à 10 ou 9 à 8 (4 n'est pas accessible depuis 9). Respectivement, ça donne 

\[
aa\Sigma^*aa + a(a+b)ab + a(a+b)aa\Sigma^* + bb + ba\Sigma^* 
\]

On peut factoriser ça en 

\[
aa\Sigma^*aa + a(a+b)a(b+a\Sigma^*) + b(b + a\Sigma^*)
\]

\subsection{Minimisation}

\paragraph{Question 1} Minimisez l'automate suivant :


\begin{figure}[H]
\centering

\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.5cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


  \node[initial, state,accepting] (0)                    {$0$};
  \node[state] (1)      [right of=0]                {$1$};
  \node[state,accepting] (2)      [right of=1]                {$2$};
  \node[state] (3)      [right of=2]                {$3$};
  \node[state,accepting] (4)      [below of=3]                {$4$};
  \node[state] (5)      [left of=4]                {$5$};
  \node[state,accepting] (6)      [left of=5]                {$6$};
  \node[state] (7)      [left of=6]                {$7$};
  \path %(I) edge[loop above]              node {$a,b$} (I)
(0) edge      [bend left=20]        node {$a$} (3)
(0) edge      [bend right,out=240,in=-120,looseness=1.5]        node {$b$} (4)

(1) edge      []        node {$a$} (2)
(1) edge      []        node {} (7)

(2) edge      []        node {$a$} (3)
(2) edge      []        node {} (6)

(3) edge      []        node {$a$} (4)
(3) edge      []        node {} (5)

(4) edge      [bend left=20]        node {$a$} (7)
(4) edge      [bend right,out=240,in=-120,looseness=1.5]        node {$b$} (0)

(5) edge      []        node {$a$} (6)
(5) edge      []        node {$b$} (3)

(6) edge      []        node {$a$} (7)
(6) edge      []        node {$b$} (2)

(7) edge      []        node {$a$} (0)
(7) edge      []        node {$b$} (1);
\end{tikzpicture}
\end{figure}

\paragraph{Correction} On divise les états en deux classes, selon qu'ils soient terminaux ou non : 

\begin{itemize}
    \item $C_T = \{0,2,4,6\}$
    \item $C_{nT} = \{1,3,5,7\}$
\end{itemize}

\paragraph{}On remarque que 

\begin{itemize}
    \item en lisant un $a$,
    \begin{itemize}
        \item les états de $C_T$ envoient vers un état de $C_{nT}$
        \item les états de $C_{nT}$ envoient vers un état de $C_T$
    \end{itemize}
    \item en lisant un $b$,
    \begin{itemize}
        \item les états de $C_T$ envoient vers un état de $C_{T}$
        \item les états de $C_{nT}$ envoient vers un état de $C_{nT}$
    \end{itemize}
\end{itemize}

\paragraph{}Il n'y a donc pas moyen de "casser" (raffiner) les classes d'états. On fusionne donc 0, 2, 4 et 6 d'une part, et 1, 3, 5 et 7 d'autre part : 



\begin{figure}[H]
\centering

\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.5cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


  \node[initial, state,accepting] (0)                    {$0$};
  \node[state] (1)      [right of=0]                {$1$};
 
  \path %(I) edge[loop above]              node {$a,b$} (I)
(0) edge      [bend left]        node {$a$} (1)
(1) edge      [bend left]        node {$a$} (0)
(0) edge      [loop above]        node {$b$} (0)
(1) edge      [loop above]        node {$b$} (1)
;
\end{tikzpicture}
\end{figure}

\paragraph{Question 2} Quel est le langage reconnu par l'automate ?

\paragraph{Correction} Sur l'automate minimisé, on observe facilement que le langage reconnu est celui des mots contenant un nombre pair de $a$, décrit notamment par l'expression $b^*(ab^*ab^*)^*$ ou, de façon plus bourrine, $(b^*ab^*ab^*)^*$.

\paragraph{Bonus} Essayez d'expliquer comment l'automate non-minimal reconnaissait le langage, et en quoi il n'était pas optimal

\paragraph{Correction} Comme on l'a déjà vu dans la minimisation, les états 0, 2, 4 et 6 d'une part, et 1, 3, 5 et 7 d'autre part sont équivalents. En effet, au court de la lecture d'un mot, on est dans un état pair si et seulement si on a lu un nombre pair de $a$, tandis qu'on est dans un état impair si et seulement si on a lu un nombre impair de $a$. 

\paragraph{} Dans l'automate original, on s'amuse donc à sauter de façon très gratuite entre états équivalents sans grand sens. Par exemple, quand on lit un $b$ en 1 on va en 7 et inversement au lieu de rester en place, parce que pourquoi pas. Il fonctionne donc comme quatre copies de sa version minimale mélangées de façon chaotique.

\subsection{Automate produit}

\paragraph{Question} Donnez un automate qui reconnaît l'intersection des langages reconnus par les deux automates suivant :


\begin{figure}[H]
\centering

\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.5cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


  \node[initial, state,accepting] (0)                    {$0$};
  \node[state] (1)      [right of=0]                {$1$};
  \node[state,accepting] (2)      [below of=0]                {$2$};
  \node[state] (3)      [right of=2]                {$3$};
  \node[initial,state] (0bis)      [right of=1]                {$0$};
  \node[state,accepting] (1bis)      [right of=0bis]                {$1$};
  \node[state] (2bis)      [right of=1bis]                {$2$};
  
  \path %(I) edge[loop above]              node {$a,b$} (I)
(0) edge      []        node {$a$} (1)
(1) edge      []        node {$a,b$} (2)
(2) edge      []        node {$b$} (3)
(2) edge      [bend left]        node {$a$} (0)
(3) edge      [loop right]        node {$a,b$} (3)
(0) edge      [bend left]        node {$b$} (2)

(0bis) edge      [loop above]        node {$a$} (0bis)
(2bis) edge      [bend left]        node {$a,b$} (1bis)
(1bis) edge      [loop above]        node {$b$} (1bis)
(0bis) edge      []        node {$b$} (1bis)
(1bis) edge      [bend left]        node {$a$} (2bis)

;
\end{tikzpicture}
\end{figure}

\paragraph{Correction} En appliquant le produit d'automates, on obtient :


\begin{figure}[H]
\centering

\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.5cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


  \node[initial, state] (00)                    {$0,0$};
  \node[state] (10)      [right of=00]                {$1,0$};
  \node[state] (20)      [right of=10]                {$2,0$};
  \node[state,accepting] (21)      [below of=00]                {$2,1$};
  \node[state] (31)      [right of=21]                {$3,1$};
  \node[state] (32)      [right of=31]                {$3,2$};
  \node[state] (02)      [below of=21]                {$0,2$};
  \node[state] (11)      [right of=02]                {$1,1$};
  \node[state] (22)      [right of=11]                {$2,2$};
  
  \node[state,accepting] (01)      [below of=02]                {$0,1$};
  
  \node[state] (12)      [left of=01]                {$1,2$};
  
  \path %(I) edge[loop above]              node {$a,b$} (I)
(00) edge      []        node {$a$} (10)
(00) edge      []        node {$b$} (21)
(10) edge      []        node {$a$} (20)
(10) edge      []        node {$b$} (21)
(20) edge      [bend right=40]        node {$a$} (00)
(20) edge      [bend right=15]        node {$b$} (31)
(21) edge      []        node {$a$} (02)
(21) edge      []        node {$b$} (31)
(31) edge      [bend left]        node {$a$} (32)
(31) edge      [loop above]        node {$b$} (31)
(32) edge      [bend left]        node {$a,b$} (31)
(02) edge      []        node {$a$} (11)
(02) edge      [bend left]        node {$b$} (21)
(11) edge      []        node {$a$} (22)
(11) edge      []        node {$b$} (21)
(22) edge      [bend right=10]        node {$a$} (01)
(22) edge      []        node {$b$} (31)
(01) edge      []        node {$a$} (12)
(01) edge      [bend left=50]        node {$b$} (21)

(12) edge      [bend left=50]        node {$a,b$} (21)
;
\end{tikzpicture}
\end{figure}

\section{Langages intrinsèquement ambigus}

Dans cet exercice, on s'intéressera \textbf{uniquement} aux \textbf{grammaires de type 2} (ou grammaires algébriques). On rappelle que ces grammaires n'acceptent que les règles de la forme $A \rightarrow \gamma$, avec $\gamma \in (\Sigma \cup V)^*$. \newline \newline
\noindent
Vos réponses devront être accompagnées d'une justification légère (de l'ordre d'une ou deux phrases) expliquant comment la grammaire donnée génère le langage de la question.

\paragraph*{Indice} Il n'est pas interdit de penser au cours sur les propriétés de clôture des langages réguliers.

\subsection*{Question 0}

Donnez une grammaire qui reconnaît le langage $L_0 = \{a^nb^n~|~n \in \mathbb{N}\}$

\paragraph*{Correction}On pose $G_0 = \big \langle \{a,b\}, \{S\},S,\{S \rightarrow aSb~|~\epsilon $ (règles 1 et 2)$\}\big \rangle$ 


\noindent
Toute dérivation dans cette grammaire sera de la forme 

\[
S \rightarrow \textcolor{red}{a}S\textcolor{red}{b} \rightarrow \textcolor{red}{a}\textcolor{blue}{a}S\textcolor{blue}{b}\textcolor{red}{b} \rightarrow \textcolor{red}{a}\textcolor{blue}{a}\textcolor{green}{a}S\textcolor{green}{b}\textcolor{blue}{b}\textcolor{red}{b} \rightarrow ...
\]

\noindent
Plus précisément : 

\[
S \rightarrow_1^n a^nSb^n \rightarrow_2 a^n\epsilon b^n = a^nb^n
\]


\noindent
Où $\rightarrow_1^n$ représente $n$ applications de la règle 1 ($S \rightarrow aSb$) et $\rightarrow_2$ correspond à une application de la règle 2 ($S \rightarrow \epsilon$)

\subsection*{Question 1}

Donnez une grammaire qui reconnaît le langage $L_1 = \{a^nba^n~|~n \in \mathbb{N}\}$

\paragraph*{Correction} L'idée est à peu près la même que pour la question précédente. On \textit{pousse} un $a$ de chaque côté du S à chaque étape de la dérivation et on finit avec un $b$ au milieu (en lieu et place du $\epsilon$). \newline


\noindent
On pose donc $G_1 = \big \langle \{a,b\}, \{S\},S,\{S \rightarrow aSa~|~b $ (règles 1 et 2)$\}\big \rangle$ \newline

\noindent
Toute dérivation dans cette grammaire sera de la forme 

\[
S \rightarrow \textcolor{red}{a}S\textcolor{red}{a} \rightarrow \textcolor{red}{a}\textcolor{blue}{a}S\textcolor{blue}{a}\textcolor{red}{a} \rightarrow \textcolor{red}{a}\textcolor{blue}{a}\textcolor{green}{a}S\textcolor{green}{a}\textcolor{blue}{a}\textcolor{red}{a} \rightarrow ...
\]


\noindent
Plus précisément : 

\[
S \rightarrow_1^n a^nSa^n \rightarrow_2 a^nba^n 
\]

\subsection*{Question 2}

Donnez une grammaire qui reconnaît le langage $L_2 = \{a^nba^m~|~n,m \in \mathbb{N}$ et $ n \geq m\}$

\paragraph*{Correction} On peut tout d'abord observer que $\{a^nba^m~|~n,m \in \mathbb{N}$ et $ n \geq m\} = \{a^na^kba^n~|~n,k \in \mathbb{N} \}$. Dit autrement, $L_2$ contient exactement les mots de $L_1$ avec des $a$ qui se seraient \textit{glissés} entre le $b$ central et les $a$ de gauche.\newline

\noindent
C'est ce qu'on va traduire en règles, en \textit{prolongeant} la grammaire précédente : au lieu de produire uniquement un $b$, la deuxième règle de $S$ laissera également derrière elle un nouveau non-terminal appelé $A$, qui peut générer un nombre arbitraire de $a$.\newline

\noindent
On pose donc $G_2 = \big \langle \{a,b\}, \{S,A\},S,\{$

\begin{itemize}
\item[] $S \rightarrow aSa~|~Ab$ (règles 1 et 2),
\item[] $A \rightarrow aA~|~\epsilon $ (règles 3 et 4)$\}\big \rangle$ 
\end{itemize}

\noindent
Toute dérivation dans cette grammaire sera de la forme 

\[
S \rightarrow_1^n a^nSa^n \rightarrow_2 a^nAba^n \rightarrow_3^k a^na^kbAa^n \rightarrow_4  a^na^kb\epsilon a^n = a^na^kba^n = a^{k+n}ba^{n}  
\]

\noindent
Avec la remarque quelques lignes plus haut, on obtient bien le langage $L_2$

\paragraph*{Remarque} On aurait pu obtenir le même langage avec une grammaire à 1 non-terminal en faisait $S \rightarrow aSa ~|~ aS ~|~ \epsilon$. Cependant, l'introduction du A permet d'obtenir une grammaire non-ambiguë, ce que la grammaire de la phrase précédente n'est pas. 

\subsection*{Question 3}

Donnez une grammaire qui reconnaît le langage 

\paragraph*{}$L_3 = \{a^nba^mba^pba^q~|~n,m,p,q \in \mathbb{N}, n \geq m$ et $p \geq q\}$

\paragraph*{Correction} On commence par la remarque suivante : $L_3 = \{ubv~|~u,v \in L_2\}$. Dit autrement, tout mot de $L_3$ est composé de deux mots (indépendants) de $L_2$ séparés par un $b$. Or, on a déjà une grammaire pour générer les mots de $L_2$, il serait donc dommage de ne pas en profiter. \newline

\noindent 
On pose donc $G_3 = \big \langle \{a,b\}, \{S',S,A\},S',\{$

\begin{itemize}
\item[] $S \rightarrow aSa~|~bA$ (règles 1 et 2),
\item[] $A \rightarrow aA~|~\epsilon $ (règles 3 et 4)
\item[] $S' \rightarrow SbS$ (règle 5)$\}\big \rangle$ 
\end{itemize}

\noindent
On notera trois différences entre $G_3$ et $G_2$ : 

\begin{itemize}
\item[] L'introduction du nouveau non-terminal $S'$
\item[] Le changement d'axiome, qui est désormais $S'$. $S$ est donc maintenant un non-terminal `comme les autres`
\item[] L'introduction de la nouvelle règle 5, qui permet de \textit{lancer} deux exécutions de de $G_2$, séparées par un $b$
\end{itemize}


\noindent
Toute dérivation dans cette grammaire sera de la forme 

\[
S' \rightarrow_5 S\textcolor{red}{b}S \rightarrow_{1,2,3,4}^*  a^na^kba^n\textcolor{red}{b}a^{n'}a^{k'}ba^{n'}
\]

\paragraph*{Remarque} On commence à voir se dessiner la logique de l'exercice, où les grammaires (enfin, certaines) vont être écrites \textit{au-dessus} d'une autre. Pour prouver que chaque grammaire $G_i$ engendre bien le langage $L_i$, on peut s'appuyer sur le fait que les grammaires précédentes étaient correctes (les miracles de la récursivités). C'est pour ça qu'on se permet, juste au-dessus, d'affirmer que $SbS$ se dérive, après un certain nombre d'applications des règles 1,2,3 et 4, en un mot de la forme $a^na^kba^nba^{n'}a^{k'}ba^{n'}$.

\subsection*{Question 4}

Donnez une grammaire qui reconnaît le langage 

\paragraph*{}$L_4 = \{a^nba^mba^pba^q~|~n,m,p,q \in \mathbb{N}, n \geq q$ et $m \geq p\}$

\paragraph*{Correction} Ici, on a des relations imbriquées entre les variables : 

\[
a^{\textcolor{red}{n}}ba^{\textcolor{blue}{m}}ba^{\textcolor{blue}{p}}ba^{\textcolor{red}{q}}
\]

\noindent
On va pouvoir retrouver cette structure \textit{pyramidale} avec deux dérivations de $G_2$ \textit{imbriquées}. On pose donc $G_4 = \big \langle \{a,b\}, \{S'',S''',A\},S'',\{$

\begin{itemize}
\item[] $S'' \rightarrow aS''a~|~AbS'''b$ (règles 1 et 2),
\item[] $A \rightarrow aA~|~\epsilon $ (règles 3 et 4),
\item[] $S''' \rightarrow aS'''a~|~Ab$ (règles 5 et 6)$\}\big \rangle$ 
\end{itemize}

\noindent
Notez qu'on a échangé $S$ contre $S''$ et $S'''$, le premier étant l'axiome, mais qu'on a gardé $A$ (vous devriez comprendre pourquoi à la question suivante). Dans l'idée, $S''$ sert à générer la partie \textit{extérieure} du mot (le $a^n$ et le $a^q$) et à \textit{lancer} la dérivation partant de $S'''$, qui va elle-même générer $a^m$ et $a^p$. Plus formellement, toute dérivation sera de la forme 

\begin{itemize}
\item[] $S''$
\item[$\rightarrow_1^q$] $a^qS''a^q $
\item[$\rightarrow_2$] $a^qAbS'''ba^q$
\item[$\rightarrow_3^k$] $a^qa^kAbS'''ba^q$
\item[$\rightarrow_4$] $a^qa^kbS'''ba^q$
\item[$\rightarrow^p_5$] $a^qa^kba^pS'''a^pba^q$
\item[$\rightarrow_6$] $a^qa^kba^pAba^pba^q$
\item[$\rightarrow_3^r$] $a^qa^kba^pa^rAba^pba^q$
\item[$\rightarrow_4$] $a^qa^kba^pa^rba^pba^q$
\end{itemize}
       

\noindent
En posant $k = n-q$ et $r = m-p$, on obtient bien exactement les mots de $L_4$.

\subsection*{Question 5}

Donnez une grammaire qui reconnaît le langage 

\paragraph*{}$L_5 = \{a^nba^mba^pba^q~|~n,m,p,q \in \mathbb{N}$ et $((n \geq m$ et $p \geq q)$ ou $(n \geq q$ et $m \geq p))\}$

\paragraph*{Correction} On remarque tout d'abord que $L_5 = L_3 \cup L_4$. On peut donc engendrer l'ensemble des mots de $L_5$ en combinant les grammaires $G_3$ et $G_4$. Dans l'idée, on a simplement besoin d'ajouter un nouveau symbole, qui servira aussi d'axiome, et qui permettra de choisir quelle grammaire ($G_3$ ou $G_4$) sera \textit{appelée}. Formellement, on a $G_5 = \big \langle \{a,b\}, \{S_f,S,S',S'',S''',A\},S_f,\{$

\begin{itemize}
\item[] $S_f \rightarrow S'~|~S''$,
\item[] $S' \rightarrow SbS$,
\item[] $S \rightarrow aSa~|~bA$,
\item[] $A \rightarrow aA~|~\epsilon $,
\item[] $S'' \rightarrow aS''a~|~AbS'''b$,
\item[] $S''' \rightarrow aS'''a~|~Ab\}\big \rangle$ 
\end{itemize}
 
\noindent
Dans les lignes 2, 3 et 4, on reconnaît les règles de $G_4$. Quant aux lignes 4, 5 et 6, on y retrouve les règles $G_3$ (notez que la règle de $A$ est \textit{partagée}, puisqu'elle apparaissait à l'identique dans les deux grammaires). Enfin, les deux règles de la première ligne, qui concernent l'axiome $S_f$, permettent de choisir si on veut effectuer une dérivation \textit{à la $G_3$} ou \textit{à la $G_4$}. $G_5$ génère donc $L_3 \cup L_4 = L_5$.


\subsection*{Question 6}

\paragraph*{}Donnez, dans la grammaire de la question 5, deux dérivations différentes d'un même mot de $L_5$ (pas de justification demandée)

\paragraph*{Correction} Soient $\phi(n,m,p,q) \equiv (n \geq m \wedge\footnote{$\wedge = $ `et`} p \geq q)$ et $\psi(n,m,p,q) \equiv (n \geq q \wedge m \geq p)$. Les grammaires $G_3$ et $G_4$ n'étant pas ambigües, on ne risque pas de trouver plusieurs dérivations pour un mot $a^nba^mba^pba^q$ correspondant \textit{strictement} à $\phi(n,m,p,q)$ ou $\psi(n,m,p,q)$ (cad rendant l'un vrai et l'autre faux). On veut donc un mot rendant les deux conditions vraies.\newline

\noindent
On prend par exemple $u = a^2ba^2ba^2ba^2$, qu'on peut obtenir par les deux dérivations suivantes\footnote{Notez qu'on n'a pas besoin d'avoir le même nombre de a dans chaque segment. Le mot $a^4ba^3ba^2ba^1$ marche aussi par exemple} :

	\begin{tabular}{c|c}
$\Tree[.{S_f} [.{S'}  [.S  a [.S a [.S b [.A {$\epsilon$} ]  ] a ] a  ] b [.S  a [.S a [.S b [.A {$\epsilon$} ]  ] a  ] a ] ] ]$ &
$\Tree[.{S_f} [.{S''} a [.{S''} a [.{S''} [.A {$\epsilon$} ] b [.{S'''} a [.{S'''} a [.{S'''} [.A {$\epsilon$} ] b ] a ] a ] b ] a ] a ] ]$\\
\end{tabular}

\noindent
On pourrait même être plus radical et prendre $u = a^0ba^0ba^0ba^0 = bbb$

\begin{center}
	\begin{tabular}{c|c}
$\Tree[.{S_f} [.{S'} [.S b [.A {$\epsilon$} ]  ]  b [.S b [.A {$\epsilon$} ]  ] ] ]$ &
$\Tree[.{S_f} [.{S''} [.A {$\epsilon$} ] b [.{S'''} [.A {$\epsilon$} ] b ] b ] ]$\\
\end{tabular}
\end{center}
\newpage
\section{Grammaire mystère}

\noindent
Soit la grammaire de type 0\footnote{Le langage décrit est lui-même de type 1, ce qui veut dire qu'on pourrait le faire avec une grammaire contextuelle, mais c'est plus \textit{simple} en s'accordant le luxe d'une type 0} suivante : $\big \langle \{a,b,\#\}, \{S,S',A,B,\$\},S,\{$

\begin{enumerate}

\item $S \rightarrow \$_GS'\$_D$
\item $S' \rightarrow aAS'$
\item $S' \rightarrow bBS'$
\item $S' \rightarrow \epsilon$
\item $Aa \rightarrow aA$
\item $Ab \rightarrow bA$
\item $Ba \rightarrow aB$
\item $Bb \rightarrow bB$
\item $\$_Ga \rightarrow a\$_G$
\item $\$_Gb \rightarrow b\$_G$
\item $A\$_D \rightarrow \$_Da$
\item $B\$_D \rightarrow \$_Db$
\item $\$_G\$_D \rightarrow \#\}\ \big \rangle$

\end{enumerate}

\noindent
Expliquez, en des termes très simples et \textit{naturels}, le langage décrit par cette grammaire. Justifiez votre réponse en expliquant succinctement le fonctionnement de la grammaire (au moins les grandes étapes).

\paragraph*{Indice} Plutôt que d'essayer de deviner le langage engendré en fixant longuement les règles, dérivez\footnote{Notez que pour les grammaire de type 0 (et 1), la traduction des dérivations en arbre n'est plus possible. Vous devrez donc faire des dérivations `plates`, comme on faisait au début du chapitre sur les grammaires} quelques mots au hasard et voyez s'ils n'ont pas l'air de partager une propriété intéressante. C'est beaucoup plus facile de vérifier qu'une grammaire a une propriété donnée que de l'inférer. 

\paragraph*{Correction} Si on s'amuse à faire quelques dérivations, on se retrouve toujours avec des mots de la forme $u\#u$, comme par exemple $abba\#abba$ : \newline

\begin{itemize}
\item[] $\textcolor{red}{S} $
\item[$\rightarrow_1$] $\$_G\textcolor{red}{S'}\$_D$ 
\item[$\rightarrow_2$] $\$_GaA\textcolor{red}{S'}\$_D$
\item[$\rightarrow_3^2$] $\$_GaAbBbB\textcolor{red}{S'}\$_D$
\item[$\rightarrow_2$] $\$_GaAbBbBaA\textcolor{red}{S'}\$_D$
\item[$\rightarrow_4$] $\$_GaAbBb\textcolor{red}{B}aA\$_D$
\item[$\rightarrow_7$] $\$_GaAb\textcolor{red}{B}baBA\$_D$
\item[$\rightarrow_8$] $\$_GaAbb\textcolor{red}{B}aBA\$_D$
\item[$\rightarrow_7$] $\$_Ga\textcolor{red}{A}bbaBBA\$_D$
\item[$\rightarrow_{5+6}^3$] $\textcolor{red}{\$_G}abbaABBA\$_D$
\item[$\rightarrow_{9+10}^4$] $abba\$_GABBA\textcolor{red}{\$_D}$
\item[$\rightarrow_{11+12}^4$] $abba\textcolor{red}{\$_G\$_D}abba$
\item[$\rightarrow_{13}$] $abba\#abba$
\end{itemize}

\noindent
Le langage engendré est en effet celui des mots `doublés` (avec un \# qui sert de séparateur à la fin\footnote{Notez que c'est uniquement pour repérer plus facilement le milieu, on aurait tout à fait pu changer la règle 13 en $\$\$ \rightarrow \epsilon$ pour faire des `purs doublons`}). On peut justifier cette réponse en étudiant l'ensemble des dérivations possibles :\newline

\begin{itemize}
\item Dans un premier temps, l'axiome $S$ passe la main à un `second axiome` en encadrant le mot par des \$ qui serviront plus loin à repérer le milieu du mot engendré
\item Ensuite, on utilise les règles 2 et 3 permettent de générer le mot qui va être doublé (le $u$ de $u\#u)$. Dans l'exemple ci-dessus, on a utilisé R2, R3, R3 puis R2 pour générer les terminaux abba (dans cet ordre-là). Les terminaux sont cependant pour l'instant accompagnés des non-terminaux correspondant.
\begin{itemize}
\item[] A supposer qu'on veuille générer le mot $u\#u$ avec $u = c_1c_2...c_n$, à ce point de la dérivation on a $\$_Gc_1C_1c_2C_2...c_nC_nS'\$_D$
\end{itemize}
\item La règle 4 fait ensuite disparaître le S'
\begin{itemize}
\item[] On a $\$_Gc_1C_1c_2C_2...c_nC_n\$_D$
\end{itemize}
\item Les règles 5 à 8 permettent ensuite aux non-terminaux de \textit{remonter} le mot (en allant vers la droite). L'astuce ici est que les non-terminaux peuvent \textit{enjamber} les terminaux, \underline{mais pas les autres non-terminaux}. L'ordre entre ces derniers est donc préservé.
\begin{itemize}
\item[] On en est donc à $\$_Gc_1c_2...c_nC_1C_2...C_n\$_D$
\end{itemize}
\item Les règles 9 et 10 font quant à elles remonter le $\$_G$ jusqu'au début des non-terminaux
\begin{itemize}
\item[] Ce qui donne $c_1c_2...c_n\$_GC_1C_2...C_n\$_D$
\end{itemize}
\item Dualement, les règles 11 et 12 font \textit{descendre} le $\$_D$. Cependant, ce dernier transforme tous les non-terminaux en le terminal correspondant (ie. A en a et B en b)
\begin{itemize}
\item[] On se retrouve avec $c_1c_2...c_n\$_G\$_Dc_1c_2...c_n$
\end{itemize}
\item Enfin, la règle 13 transforme la paire nouvellement crée de \$ en \#. On finit donc bien avec  $c_1c_2...c_n\#c_1c_2...c_n \in \Sigma^*$
\end{itemize}






\end{document} 
  


 
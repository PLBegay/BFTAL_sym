\chapter{Automates finis}
\label{automates}

\section{Automates finis déterministes}
\label{DFA}

\subsection{Principe général}


\begin{figure}[!h]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.9cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


  \node[initial,state] (A)                    {$0$};
  \node[state] (B)      [right of=A]                {$1$};
  \node[accepting,state] (C)      [right of=B]                {$2$};

  \path %(I) edge[loop above]              node {$a,b$} (I)
(A) edge      [loop above]        node {$b$} (A)
(C) edge      [loop above]        node {$a,b$} (C)
(A) edge      [bend right]        node {$a$} (B)
(B) edge      [bend right]        node {$b$} (A)
(B) edge      []        node {$a$} (C);
\end{tikzpicture}
\caption{Un premier automate}
\label{aaauto}
\end{figure}

\begin{exercice}
Les mots $abbaba$, $ababbaab$ et $abba$ sont-ils acceptés par l'automate de la figure \ref{aaauto} ?
\end{exercice}

\begin{correction*}
On a les parcours suivant dans l'automate :
\begin{itemize}

\item $abbaba$
\begin{itemize}
\item[] $0 \xrightarrow{a} 1 \xrightarrow{b} 0 \xrightarrow{b} 0 \xrightarrow{a} 1 \xrightarrow{b} 0 \xrightarrow{a} 1 \notin \{2\}$, donc non.
\end{itemize}

\item $ababbaab$
\begin{itemize}
\item[] $0 \xrightarrow{a} 1 \xrightarrow{b} 0 \xrightarrow{a} 1 \xrightarrow{b} 0 \xrightarrow{b} 0 \xrightarrow{a} 1 \xrightarrow{a} 2 \xrightarrow{b} 2 \in \{2\}$, donc oui.
\end{itemize}

\item $abba$
\begin{itemize}
\item[] $0 \xrightarrow{a} 1 \xrightarrow{b} 0 \xrightarrow{b} 0 \xrightarrow{a} 1 \notin \{2\}$, donc non.
\end{itemize}

\end{itemize}
\end{correction*}

\begin{exercice}
Quel est le \textbf{langage reconnu}, cad. l'ensemble des mots acceptés, par l'automate de la figure \ref{aaauto} ? Donner la réponse en français et sous forme d'expression rationnelle.
\end{exercice}

\begin{correction*}
L'état $0$ correspond à "on n'a pas croisé de $aa$", l'état $1$ est "on vient de croiser un $a$ isolé" et $2$ est "On a croisé plus tôt $aa$". Le langage accepté est celui des mots ayant $aa$ comme facteur, cad. $\Sigma^*aa\Sigma^*$.
\end{correction*}


\begin{figure}[!h]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.9cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


  \node[initial,state] (A)                    {$0$};
  \node[state] (B)      [right of=A]                {$1$};
  \node[accepting,state] (C)      [right of=B]                {$2$};

  \path %(I) edge[loop above]              node {$a,b$} (I)
(A) edge      [loop above]        node {$b$} (A)
(C) edge      [loop above]        node {$a,b$} (C)
(A) edge      []        node {$a$} (B)
(B) edge      []        node {$a$} (C);
\end{tikzpicture}
\caption{Un automate incomplet}
\label{incompauto}
\end{figure}


\begin{exercice}
Les mots $bbbaababbaaba$, $bbabaab$ et $baaaaaab$ sont-ils acceptés par l'automate de la figure \ref{incompauto} ?
\end{exercice}


\begin{correction*}
On a les parcours suivant dans l'automate :
\begin{itemize}

\item $bbbaababbaaba$
\begin{itemize}
\item[] $0 \xrightarrow{b} 0 \xrightarrow{b} 0 \xrightarrow{b} 0 \xrightarrow{a} 1 \xrightarrow{a} 2 \xrightarrow{babbaaba} 2 \in \{2\}$, donc oui.
\end{itemize}

\item $bbabaab$
\begin{itemize}
\item[] $0 \xrightarrow{b} 0 \xrightarrow{b} 0 \xrightarrow{a} 1 \not\xrightarrow{b}$, donc non.
\end{itemize}

\item $baaaaaab$
\begin{itemize}
\item[] $0 \xrightarrow{b} 0 \xrightarrow{a} 1 \xrightarrow{a} 2 \xrightarrow{aaaab} 2 \in \{2\}$, donc oui.
\end{itemize}

\end{itemize}
\end{correction*}

\begin{exercice}
Quel est le langage reconnu par l'automate de la figure \ref{incompauto} ? Donner la réponse en français et sous forme d'expression rationnelle.
\end{exercice}

\begin{correction*}
On reste dans l'état $0$ tant qu'on a lu $b^*$. On passe en $1$ dès qu'on lit un premier $a$, et seul un autre $a$ tombant immédiatement permet de passer en $2$, où on accepte tout. Le langage reconnu est celui des mots qui contiennent des $a$ et dont le premier est immédiatement suivi d'un deuxième, cad. $b^*aa\Sigma^*$. 
\end{correction*}

\begin{example}
\label{exemplePI}
On veut écrire un automate reconnaissant le langage $L = \{w \in \Sigma^*~|~|w|_a$ pair et $|w|_b$ impair$\}$, cad. l'ensemble des mots avec un nombre pair de $a$ et impairs de $b$.

\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.9cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


  \node[initial,state] (PP)                    {$PP$};
  \node[state] (IP)      [above right of=PP]                {$IP$};  \node[state] (II)      [below right of=IP]                {$II$};
  \node[accepting,state] (PI)      [below right of=PP]                {$PI$};

  \path %(I) edge[loop above]              node {$a,b$} (I)
(PP) edge      [bend right]        node {$a$} (IP)
(PP) edge      [bend right]        node {$b$} (PI)
(PI) edge      [bend right]        node {$a$} (II)
(PI) edge      [bend right]        node {$b$} (PP)
(IP) edge      [bend right]        node {$a$} (PP)
(IP) edge      [bend right]        node {$b$} (II)
(II) edge      [bend right]        node {$a$} (PI)
(II) edge      [bend right]        node {$b$} (IP);
\end{tikzpicture}
\end{example}

\begin{exercice} (**) En reprenant l'exemple \ref{exemplePI}, montrer que $\forall w, w \in L \leftrightarrow$ l'automate accepte $w$. Vous pouvez procéder par induction sur $w$, en utilisant un objectif un peu plus précis que celui fourni.
\end{exercice}

\begin{correction*}
On est obligé, pour cette preuve, d'affiner la propriété qu'on veut prouver, en précisant le rôle des différents états :\\
\begin{tabular}{crl}
$\forall w,$& & $((PP \xrightarrow{w} PP$ ssi. $|w|_a $ pair et $|w|_b$ pair$)$ \\

&$\wedge$& $(PP \xrightarrow{w} IP$ ssi. $|w|_a $ impair et $|w|_b$ pair$)$ \\

&$\wedge$& $(PP \xrightarrow{w} PI$ ssi. $|w|_a $ pair et $|w|_b$ impair$)$ \\

&$\wedge$& $(PP \xrightarrow{w} II$ ssi. $|w|_a $ impair et $|w|_b$ impair$))$ 

\end{tabular}

On procède par induction (droite) sur $w$. Dans le cas où $w = \epsilon$, la formule devient \\

\begin{tabular}{rl}
& $((PP \xrightarrow{\epsilon} PP$ ssi. $|\epsilon|_a $ pair et $|\epsilon|_b$ pair$)$ \\

$\wedge$& $(PP \xrightarrow{\epsilon} IP$ ssi. $|\epsilon|_a $ impair et $|\epsilon|_b$ pair$)$ \\

$\wedge$& $(PP \xrightarrow{\epsilon} PI$ ssi. $|\epsilon|_a $ pair et $|\epsilon|_b$ impair$)$ \\

$\wedge$& $(PP \xrightarrow{\epsilon} II$ ssi. $|\epsilon|_a $ impair et $|\epsilon|_b$ impair$))$ 
\end{tabular}

Qui se réécrit en \\

\begin{tabular}{rl}
& $\top$ ssi. $\top$ \\

$\wedge$& $\bot$ ssi. $\bot$ \\

$\wedge$& $\bot$ ssi. $\bot$ \\

$\wedge$& $\bot$ ssi. $\bot$
\end{tabular}

qui s'évalue à $\top$. Le cas de base est donc vrai. Pour la récursion, on suppose que la propriété est vraie pour $w$, et on veut vérifier qu'elle est vraie pour $w.a$ et $w.b$. On se concentre, sans perte de généralité, sur $w.a$. On a $4$ cas à étudier : $|w|_a$ pair et $|w|_b$ pair, $|w|_a$ impair et $|w|_b$ pair, $|w|_a$ pair et $|w|_b$ impair, et enfin $|w|_a$ impair et $|w|_b$ impair. On se concentre, encore une fois sans perte de généralité, sur le premier cas. On veut donc prouver \\

\begin{tabular}{rl}
& $((PP \xrightarrow{wa} PP$ ssi. $|wa|_a $ pair et $|wa|_b$ pair$)$ \\

$\wedge$& $(PP \xrightarrow{wa} IP$ ssi. $|wa|_a $ impair et $|wa|_b$ pair$)$ \\

$\wedge$& $(PP \xrightarrow{wa} PI$ ssi. $|wa|_a $ pair et $|wa|_b$ impair$)$ \\

$\wedge$& $(PP \xrightarrow{wa} II$ ssi. $|wa|_a $ impair et $|wa|_b$ impair$))$ 
\end{tabular}

Puisqu'on est dans le cas $|w|_a$ pair et $|w|_b$ pair, $|wa|_a$ impair et $|wa|_b$ pair. De plus, l'hypothèse de récurrence nous dit que $PP \xrightarrow{w} PP$. Puisque $PP \xrightarrow{a} IP$, on a $PP \xrightarrow{wa} IP$. La propriété reste donc vraie en passant de $w$ à $w.a$.

En généralisant cette preuve à tous les cas ignorés\footnote{Oui, la preuve formelle est un long et terrible chemin de croix parcouru par des héros et héroïnes du quotidien.}, on montre la propriété pour tout mot. Puisque le seul état terminal est $PI$, la correction de l'automate est un corrolaire.
\end{correction*}

Dans la série d'exercices qui suit, on utilisera comme alphabet $\Sigma = \{a,b\}$.

\begin{exercice}
Donner un automate qui reconnaît le langage $\{w \in \Sigma^*~|~|w| \geq 3\}$. 
\end{exercice}

\begin{correction*}

On vérifie simplement la présence de 3 premières lettres avant d'autoriser n'importe quoi. Le nom des états représente le nombre de lettres lues : 

\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.9cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


  \node[initial,state] (0)                    {$0$};
  \node[state] (1)      [right of=0]                {$1$};  \node[state] (2)      [right of=1]                {$2$};
  \node[accepting,state] (3)      [right of=2]                {$3+$};

  \path %(I) edge[loop above]              node {$a,b$} (I)
(0) edge      []        node {$a,b$} (1)
(1) edge      []        node {$a,b$} (2)
(2) edge      []        node {$a,b$} (3)
(3) edge      [loop above]        node {$a,b$} (3);
\end{tikzpicture}

\end{correction*}

\begin{exercice}
Donner un automate pour les mots qui commencent par $a$.
\end{exercice}

\begin{correction*}

On vérifie simplement la présence d'un $a$ au début du mot :

\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.9cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


  \node[initial,state] (0)                    {$0$};
  \node[state,accepting] (1)      [right of=0]                {$1$}; 

  \path %(I) edge[loop above]              node {$a,b$} (I)
(0) edge      []        node {$a$} (1)
(1) edge      [loop above]        node {$a,b$} (1);
\end{tikzpicture}

\end{correction*}


\begin{exercice}
Donner un automate pour les mots qui finissent par $b$.
\end{exercice}

\begin{correction*}

On vérifie simplement la présence d'un $b$ qui ne peut être suivi par rien :

\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.9cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


  \node[initial,state] (0)                    {$0$};
  \node[state,accepting] (1)      [right of=0]                {$1$}; 

  \path %(I) edge[loop above]              node {$a,b$} (I)
(0) edge      []        node {$b$} (1)
(0) edge      [loop above]        node {$a,b$} (0);
\end{tikzpicture}

\end{correction*}

\begin{exercice}
Donner un automate pour les mots qui commencent par $a$ finissent par $b$.
\end{exercice}

\begin{correction*}

En mélangeant les automates précédant, on obtient

\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.9cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


  \node[initial,state] (0)                    {$0$};
  \node[state] (1)      [right of=0]                {$1$}; 
  \node[state,accepting] (2)      [right of=1]                {$2$}; 

  \path %(I) edge[loop above]              node {$a,b$} (I)
(0) edge      []        node {$a$} (1)
(1) edge      [loop above]        node {$a,b$} (1)
(1) edge      []        node {$b$} (2);
\end{tikzpicture}

\end{correction*}

\begin{exercice}
Donner un automate pour les mots de longueur paire.
\end{exercice}


\begin{correction*}

On suit juste la parité de la longueur du mot donné :

\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.9cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


  \node[initial,state,accepting] (0)                    {$P$};
  \node[state] (1)      [right of=0]                {$I$}; 

  \path %(I) edge[loop above]              node {$a,b$} (I)
(0) edge      [bend right]        node {$a,b$} (1)
(1) edge      [bend right]        node {$a,b$} (0);
\end{tikzpicture}

\end{correction*}


\begin{exercice}
Donner un autuomate pour les mots de longueur impaire qui contiennent au moins 4 lettres.
\end{exercice}

\begin{correction*}

On vérifie d'abord qu'on a 5 lettres, puis qu'on ajoute un nombre pair de lettres :


\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.9cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


  \node[initial,state] (0)                    {$0$};
  \node[state] (1)      [right of=0]                {$1$};
  \node[state] (2)      [right of=1]                {$2$};
  \node[state] (3)      [right of=2]                {$3$};
  \node[state] (4)      [right of=3]                {$4$};
  \node[state,accepting] (5)      [right of=4]                {$5$}; 
  \node[state] (P)      [above of=5]                {$P$}; 

  \path %(I) edge[loop above]              node {$a,b$} (I)
(0) edge      []        node {$a,b$} (1)
(1) edge      []        node {$a,b$} (2)
(2) edge      []        node {$a,b$} (3)
(3) edge      []        node {$a,b$} (4)
(4) edge      []        node {$a,b$} (5)
(5) edge      [bend left]        node {$a,b$} (P)
(P) edge      [bend left]        node {$a,b$} (5);
\end{tikzpicture}

Notez qu'on peut ici fusionner les états $4$ et $I$ :

\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.9cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


  \node[initial,state] (0)                    {$0$};
  \node[state] (1)      [right of=0]                {$1$};
  \node[state] (2)      [right of=1]                {$2$};
  \node[state] (3)      [right of=2]                {$3$};
  \node[state] (4)      [right of=3]                {$4$};
  \node[state,accepting] (5)      [right of=4]                {$5$}; 

  \path %(I) edge[loop above]              node {$a,b$} (I)
(0) edge      []        node {$a,b$} (1)
(1) edge      []        node {$a,b$} (2)
(2) edge      []        node {$a,b$} (3)
(3) edge      []        node {$a,b$} (4)
(4) edge      [bend left]        node {$a,b$} (5)
(5) edge      [bend left]        node {$a,b$} (4);
\end{tikzpicture}
\end{correction*}


\begin{exercice}
Donner un automate pour les mots de longueur impaire, qui contiennent au moins 4 lettres, commencent par $a$ et finissent par $b$.
\end{exercice}


\begin{correction*}

On contraint un peu l'automate précédent en forçant un $a$ au début, et en ajoutant un état (on ne peut plus avoir $5$ terminal, car sinon on va soit permettre de finir avec $a$, soit trop contraindre l'intérieur des mots) :

\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.9cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


  \node[initial,state] (0)                    {$0$};
  \node[state] (1)      [right of=0]                {$1$};
  \node[state] (2)      [right of=1]                {$2$};
  \node[state] (3)      [right of=2]                {$3$};
  \node[state] (4)      [right of=3]                {$4$};
  \node[state] (5)      [right of=4]                {$5$}; 
  \node[state,accepting] (F)      [above right of=4]                {$F$}; 

  \path %(I) edge[loop above]              node {$a,b$} (I)
(0) edge      []        node {$a$} (1)
(1) edge      []        node {$a,b$} (2)
(2) edge      []        node {$a,b$} (3)
(3) edge      []        node {$a,b$} (4)
(4) edge      [bend left]        node {$a,b$} (5)
(4) edge      []        node {$b$} (F)
(5) edge      [bend left]        node {$a,b$} (4);
\end{tikzpicture}
\end{correction*}

\subsection{Formalisation et implémentation}

\begin{exercice}
Donner la formalisation de l'automate de l'exemple \ref{exemplePI} et vérifier qu'il accepte le mot $aababba$. 
\end{exercice}

\begin{correction*}
On a le 5-uplet suivant :
\begin{itemize}
\item $Q = \{PP,IP,PI,II\}$
\item $\Sigma = \{a,b\}$
\item $q_0 = PP$
\item $F = \{PI\}$
\item $\delta(PP,a) = IP; \delta(PP,b) = PI; \delta(IP,a) = PP; \delta(IP,b) = II; \delta(PI,a) = II; \delta(PI,b) = PP; \delta(II,a) = PI; \delta(II,b) = IP$.
\end{itemize}

On a alors le calcul suivant : 

\begin{itemize}
\item[] $\delta^*(PP,aababba)$
\item[$=$] $\delta^*(\delta(PP,a),ababba)$
\item[$=$] $\delta^*(IP,ababba)$
\item[$=$] $\delta^*(\delta(IP,a),babba)$
\item[$=$] $\delta^*(PP,babba)$
\item[$=$] $\delta^*(PI,abba)$
\item[$=$] $\delta^*(II,bba)$
\item[$=$] $\delta^*(IP,ba)$
\item[$=$] $\delta^*(II,a)$
\item[$=$] $\delta^*(PI,\epsilon)$
\item[$=$] $PI \in \{PI\}$, donc oui.
\end{itemize}

\end{correction*}

\section{Automates finis non-déterministes}
\label{NDFA}

\subsection{Principe général}


\begin{exercice}
Donner une \textit{regex} et un automate fini pour le langage $L = \{w ~|~ aba$ est un sous-mot de $w\}$.
\end{exercice}

\begin{correction*}
On peut fournir une $\textit{regex}$ hautemennt non-déterministe : $\Sigma^*a\Sigma^*b\Sigma^*a\Sigma^*$. L'automate non-déterministe équivalent est 


\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.9cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


  \node[initial,state] (0)                    {$0$};
  \node[state] (1)      [right of=0]                {$1$};
  \node[state] (2)      [right of=1]                {$2$};
  \node[state,accepting] (3)      [right of=2]                {$3$};


  \path %(I) edge[loop above]              node {$a,b$} (I)
(0) edge      [loop above]        node {$a,b$} (0)
(0) edge      []        node {$a$} (1)
(1) edge      [loop above]        node {$a,b$} (1)
(1) edge      []        node {$b$} (2)
(2) edge      [loop above]        node {$a,b$} (2)
(2) edge      []        node {$a$} (3)
(3) edge      [loop above]        node {$a,b$} (3);
\end{tikzpicture}

Assez étonnamment, on peut concevoir un automate déterministe qui reconnaît le même langage avec le même nombre d'états. 

\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.9cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


  \node[initial,state] (0)                    {$0$};
  \node[state] (1)      [right of=0]                {$1$};
  \node[state] (2)      [right of=1]                {$2$};
  \node[state,accepting] (3)      [right of=2]                {$3$};


  \path %(I) edge[loop above]              node {$a,b$} (I)
(0) edge      [loop above]        node {$b$} (0)
(0) edge      []        node {$a$} (1)
(1) edge      [loop above]        node {$a$} (1)
(1) edge      []        node {$b$} (2)
(2) edge      [loop above]        node {$b$} (2)
(2) edge      []        node {$a$} (3)
(3) edge      [loop above]        node {$a,b$} (3);
\end{tikzpicture}

Dans cette version, on enlève certaines transitions pour forcer que les transitions horizontales soient prises dès que possible. Cet automate permet de déduire une \textit{regex} moins claire car moins ambigüe, et donc plus efficace : $b^*aa^*bb^*a\Sigma^*$.

\end{correction*}

\begin{exercice}
Donner une \textit{regex} et un automate fini pour le langage des mots qui commencent par $ab$ et finissent par $ba$.
\end{exercice}

\begin{correction*}

On pourrait d'abord avoir envie de répondre 

\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.9cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


  \node[initial,state] (0)                    {$0$};
  \node[state] (1)      [right of=0]                {$1$};
  \node[state] (2)      [right of=1]                {$2$};
  \node[state] (3)      [right of=2]                {$3$};
  \node[state,accepting] (4)      [right of=3]                {$4$};


  \path %(I) edge[loop above]              node {$a,b$} (I)
(0) edge      []        node {$a$} (1)
(1) edge      []        node {$b$} (2)
(2) edge      [loop above]        node {$a,b$} (2)
(2) edge      []        node {$b$} (3)
(3) edge      []        node {$a$} (4);
\end{tikzpicture}

Cependant, cet automate n'accepte pas $aba$, qui fait pourtant partie du langage. Il s'agit cependant de la seule exception, qu'on peut rajouter à la main (l'état $5$ représente le choix que le premier $b$ est à la fois celui du début et de la fin, et donc que le mot lu est $aba$). On aurait pu être encore plus flemmard et rajouter deux états, dont un initial, plutôt que de partager $0$ et $1$.


\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.9cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


  \node[initial,state] (0)                    {$0$};
  \node[state] (1)      [right of=0]                {$1$};
  \node[state] (2)      [right of=1]                {$2$};
  \node[state] (3)      [right of=2]                {$3$};
  \node[state,accepting] (4)      [right of=3]                {$4$};
  \node[state] (5)      [below right of=1]                {$5$};
  \node[state,accepting] (6)      [below right of=2]                {$6$};

  \path %(I) edge[loop above]              node {$a,b$} (I)
(0) edge      []        node {$a$} (1)
(1) edge      []        node {$b$} (2)
(2) edge      [loop above]        node {$a,b$} (2)
(2) edge      []        node {$b$} (3)
(1) edge      []        node {$b$} (5)
(5) edge      []        node {$a$} (6)
(3) edge      []        node {$a$} (4);
\end{tikzpicture}

La \textit{regex} correspondant à cet automate est $a(b\Sigma^*ba + ba)$. On aurait pu plus simplement utiliser la version défactorisée $ab\Sigma^*ba + aba$.

\end{correction*}

\subsection{Formalisation et implémentation}

\section{Transformation d'automates}
\label{transauto}

\subsection{Complétion}


\begin{exercice}
\label{ndetcomp}
Compléter l'automate suivant :


\begin{figure}[!ht]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.9cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


  \node[initial,state] (0)                    {$0$};
  \node[state] (1)      [right of=0]                {$1$};  
  \node[state] (2)      [right of=1]                {$2$};
  \node[accepting,state] (3)      [right of=2]                {$3$};

  \node[initial,state] (4)  [below of=0]            {$4$};
  \node[state] (5)      [right of=4]                {$5$};  
  \node[state] (6)      [right of=5]                {$6$};
  \node[accepting,state] (7)      [right of=6]                {$7$};

  \path %(I) edge[loop above]              node {$a,b$} (I)
(0) edge      [loop above]        node {$a,b$} (0)
(0) edge      []        node {$a$} (1)
(1) edge      []        node {$b$} (2)
(2) edge      []        node {$a$} (3)
(3) edge      [loop above]        node {$a,b$} (3)
(4) edge      [loop above]        node {$a,b$} (4)
(4) edge      []        node {$b$} (5)
(5) edge      []        node {$a$} (6)
(6) edge      []        node {$b$} (7)
(7) edge      [loop above]        node {$a,b$} (7);

\end{tikzpicture}
\end{figure}
\end{exercice}

\begin{correction*}
On obtient 


\begin{figure}[!ht]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.9cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


  \node[initial,state] (0)                    {$0$};
  \node[state] (1)      [right of=0]                {$1$};  
  \node[state] (2)      [right of=1]                {$2$};
  \node[accepting,state] (3)      [right of=2]                {$3$};
  \node[state] (P)      [below right=0.7cm and 0.7cm of 1]                {$P$};
  \node[initial,state] (4)  [below of=0]            {$4$};
  \node[state] (5)      [right of=4]                {$5$};  
  \node[state] (6)      [right of=5]                {$6$};
  \node[accepting,state] (7)      [right of=6]                {$7$};

  \path %(I) edge[loop above]              node {$a,b$} (I)
(0) edge      [loop above]        node {$a,b$} (0)
(0) edge      []        node {$a$} (1)
(1) edge      []        node {$a$} (P)
(1) edge      []        node {$b$} (2)
(2) edge      []        node {$a$} (3)
(2) edge      []        node {$b$} (P)
(3) edge      [loop above]        node {$a,b$} (3)
(4) edge      [loop above]        node {$a,b$} (4)
(4) edge      []        node {$b$} (5)
(5) edge      []        node {$b$} (P)
(5) edge      []        node {$a$} (6)
(6) edge      []        node {$a$} (P)
(6) edge      []        node {$b$} (7)
(P) edge      [loop left]        node {$a,b$} (P)
(7) edge      [loop above]        node {$a,b$} (7);

\end{tikzpicture}
\end{figure}
\end{correction*}


\begin{exercice}
Donner la formalisation de la complétion d'un automate non-déterministe.
\end{exercice}

\begin{correction*}

Soit un automate non-déterministe $\big \langle Q,\Sigma,I,F,\delta \big \rangle$, sa version complétée est \newline $\big \langle Q \cup~\{P\},\Sigma,I,F,\delta' \big \rangle$, avec

\[
\begin{cases}
\delta'(q,a) = \delta(q,a) &\text{ si } \delta(q,a) \neq \emptyset,\\[1ex]
\delta'(q,a) = \{P\} &\text{ si } \delta(q,a) = \emptyset,\\[1ex]
\delta'(P,a) = \{P\} &\text{ pour tout } a \in \Sigma\\[1ex]
 \end{cases}
\]


\end{correction*}

\subsection{Déterminisation}
\label{det}

\begin{exercice}
Déterminiser l'automate de l'exercice \ref{ndetcomp}.
\end{exercice}

\begin{correction*}

L'automate à déterminiser a deux états initiaux : $0$ et $4$. On commence donc en créant un état initial représentant $0$ et $4$ :


\begin{figure}[!ht]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.5cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


  \node[initial,state] (04)                    {$0,4$};
\end{tikzpicture}
\end{figure}

La lettre $a$ permet de passer de $0$ à $0$ ou $1$, et fait boucler sur $4$. Au total, quand on est en $0,4$ et qu'on lit un $a$, on a le choix entre $0$, $1$ et $4$. De même, en lisant un $b$, on peut aller en $0$, $4$ ou $5$. On obtient donc les premières transtitions suivantes :



\begin{figure}[!ht]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.5cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


  \node[initial,state] (04)                    {$0,4$};
  \node[state] (014)    [above right of=04]                {$0,1,4$};
  \node[state] (045)    [below right of=04]                {$0,4,5$};
  

  \path %(I) edge[loop above]              node {$a,b$} (I)
(04) edge     []        node {$a$} (014)
(04) edge     []        node {$b$} (045);

\end{tikzpicture}
\end{figure}

On itère : \newpage

\begin{figure}[!ht]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.5cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


  \node[initial,state] (04)                    {$0,4$};
  \node[state] (014)    [above right of=04]                {$0,1,4$};
  \node[state] (045)    [below right of=04]                {$0,4,5$};
  \node[state] (0245)    [right of=014]                {$0,2,4,5$};
  \node[state] (0146)    [right of=045]                {$0,1,4,6$};

  

  \path %(I) edge[loop above]              node {$a,b$} (I)
(04) edge     []        node {$a$} (014)
(04) edge     []        node {$b$} (045)
(014) edge    [loop above]        node {$a$} (014)
(045) edge    [loop below]        node {$b$} (045)
(014) edge     []        node {$b$} (0245)
(045) edge     []        node {$a$} (0146);

\end{tikzpicture}
\end{figure}

Quand on lit un $a$ depuis $0$, $2$, $4$ ou $5$, on peut atteindre $0$, $1$, $3$, $4$ ou $6$, on crée donc l'état correspondant. $3$ étant un état terminal dans l'automate initial, $0,1,3,4,6$ l'est aussi. Un $b$ par contre nous emmène seulement en $0$, $4$ ou $5$. Cette état existant déjà dans notre automate, on pointe dessus. En faisant le même raisonnement avec $0,1,4,6$, on obtient 

\begin{figure}[!ht]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.5cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


  \node[initial,state] (04)                    {$0,4$};
  \node[state] (014)    [above right of=04]                {$0,1,4$};
  \node[state] (045)    [below right of=04]                {$0,4,5$};
  \node[state] (0245)    [right of=014]                {$0,2,4,5$};
  \node[state] (0146)    [right of=045]                {$0,1,4,6$};
  \node[state,accepting] (01346)    [right of=0245]                {$0,1,3,4,6$};
  \node[state,accepting] (02457)    [right of=0146]                {$0,2,4,5,7$};
  

  \path %(I) edge[loop above]              node {$a,b$} (I)
(04) edge     []        node {$a$} (014)
(04) edge     []        node {$b$} (045)
(014) edge    [loop above]        node {$a$} (014)
(045) edge    [loop below]        node {$b$} (045)
(014) edge     []        node {$b$} (0245)
(045) edge     []        node {$a$} (0146)
(0245) edge    []        node [pos=0.7] {$b$} (045)
(0146) edge    []        node [pos=0.7] {$a$} (014)
(0245) edge    []        node {$a$} (01346)
(0146) edge    []        node {$b$} (02457);

\end{tikzpicture}
\end{figure}

En continuant comme ça, on arrive à 


\begin{figure}[!ht]
%	\hspace{-2cm}
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3.4cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


  \node[initial,state] (04)                    {$0,4$};
  \node[state] (014)    [above of=04]                {$0,1,4$};
  \node[state] (045)    [below of=04]                {$0,4,5$};
  \node[state] (0245)    [right of=014]                {$0,2,4,5$};
  \node[state] (0146)    [right of=045]                {$0,1,4,6$};
  \node[state,accepting] (01346)    [right of=0245]                {$0,1,3,4,6$};
  \node[state,accepting] (02457)    [right of=0146]                {$0,2,4,5,7$};
  \node[state,accepting] (0134)    [above left =0.6cm and 1cm of 01346]                {$0,1,3,4$};
  \node[state,accepting] (0457)    [below left=0.6cm and 1cm of 02457]                {$0,4,5,7$};
  \node[state,accepting] (02345)    [above = 0.5cm of 01346]                {$0,2,3,4,5$};
  \node[state,accepting] (01467)    [below = 0.5cm of 02457]                {$0,1,4,6,7$};
  \node[state,accepting] (0345)    [right of=02345]                {$0,3,4,5$};
  \node[state,accepting] (0147)    [right of=01467]                {$0,1,4,7$};
  \node[state,accepting] (023457)    [below left=0.3cm and 0.8cm of 01346]                {$0,2,3,4,5,7$};
  \node[state,accepting] (013467)    [above left=0.3cm and 0.8cm of 02457]                {$0,1,3,4,6,7$};
  \node[state,accepting] (03457)    [right =2cm of 023457]                {$0,3,4,5,7$};
  \node[state,accepting] (01347)    [right =2cm of 013467]                {$0,1,3,4,7$};

  

  \path %(I) edge[loop above]              node {$a,b$} (I)
(04) edge     []        node {$a$} (014)
(04) edge     []        node {$b$} (045)
(014) edge    [loop above]        node {$a$} (014)
(045) edge    [loop below]        node {$b$} (045)
(014) edge     []        node {$b$} (0245)
(045) edge     []        node {$a$} (0146)
(0245) edge    []        node [pos=0.7] {$b$} (045)
(0146) edge    []        node [pos=0.7] {$a$} (014)
(0245) edge    []        node {$a$} (01346)
(0146) edge    []        node {$b$} (02457)
(01346) edge    []        node {$a$} (0134)
(02457) edge    []        node {$b$} (0457)
(01346) edge    []        node {$b$} (023457)
(02457) edge    []        node {$a$} (013467)
(0134) edge    [loop left]        node {$a$} (0134)
(0457) edge    [loop left]        node {$b$} (0457)
(0134) edge    []        node {$b$} (02345)
(0457) edge    []        node {$a$} (01467)
(02345) edge    []        node {$a$} (01346)
(01467) edge    []        node [pos=0.3] {$b$} (02457)
(02345) edge    []        node {$b$} (0345)
(01467) edge    []        node {$a$} (0147)
(01346) edge    []        node {$a$} (0134)
(02457) edge    []        node {$b$} (0457)
(0345) edge    []        node {$a$} (01346)
(0147) edge    []        node {$b$} (02457)
(0345) edge    [loop above]        node {$b$} (0345)
(0147) edge    [loop below]        node {$a$} (0147)
(023457) edge    [bend right=20]        node {$a$} (013467)
(013467) edge    [bend right=20]        node {$b$} (023457)
(023457) edge    []        node {$b$} (03457)
(013467) edge    []        node {$a$} (01347)
(03457) edge    []        node [pos=0.3] {$a$} (013467)
(01347) edge    []        node [pos=0.3] {$b$} (023457)
(03457) edge    [loop right]        node {$b$} (03457)
(01347) edge    [loop right]        node {$a$} (01347);

\end{tikzpicture}
\end{figure}

\end{correction*}
\newpage

\subsection{Minimisation}
\label{minim}


\begin{exercice}
Minimiser (en utilisant l'algorithme) l'automate 


\begin{figure}[!ht]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.9cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


  \node[initial,state] (0)                    {$0$};
  \node[state] (1)      [right of=0]                {$1$};  
  \node[state] (2)      [right of=1]                {$2$};
  \node[accepting,state] (3)      [right of=2]                {$3$};
  \node[accepting,state] (4)      [right of=3]                {$4$};
  \node[accepting,state] (5)      [below of=4]                {$5$};

  \path %(I) edge[loop above]              node {$a,b$} (I)
(0) edge      [loop above]        node {$b$} (0)
(0) edge      []        node {$a$} (1)
(1) edge      [loop above]        node {$a$} (1)
(1) edge      []        node {$b$} (2)
(2) edge      [bend left]        node {$b$} (0)
(2) edge      []        node {$a$} (3)
(3) edge      [loop above]        node {$a$} (3)
(3) edge      []        node {$b$} (4)
(4) edge      [bend left]        node {$a$} (3)
(4) edge      []        node {$b$} (5)
(5) edge      [loop right]        node {$b$} (3)
(5) edge      []        node {$a$} (3);
\end{tikzpicture}
\end{figure}
\end{exercice}

\newpage

\begin{correction*}

On a $N = \{0,1,2\}$ d'un côté, et $F = \{3,4,5\}$ de l'autre. On va d'abord s'intéresser à $N$.

\begin{itemize}
\item 0 vs 1
\begin{itemize}
\item $\delta(0,a) = 1 = \delta(1,a)$
\item $\delta(1,b) = 0 \in N$ et $\delta(1,b) = 2 \in N$
\item[$\Rightarrow$] 0 et 1 sont d'accord
\end{itemize}
\item 0 vs 2
\begin{itemize}
\item $\delta(0,a) = 1 \in N$ et $\delta(2,a) = 3 \in F$
\item[$\Rightarrow$] 0 et 2 ne sont pas d'accord, on va devoir les séparer
\end{itemize}
\item Pas besoin de tester 1 vs 2, puisqu'on sait déjà que 1 va être avec 0, et donc séparé de 2.
\end{itemize}

On peut donc séparer $N$ en $N_1 = \{0,1\}$ et $N_2 = \{2\}$. On a maintenant le choix d'étudier $N_1$ ou $F$. On choisit (un peu bêtement) $F$.

\begin{itemize}
\item 3 vs 4
\begin{itemize}
\item $\delta(3,a) = 3 = \delta(4,a)$
\item $\delta(3,b) = 4 \in F$ et $\delta(4,b) = 5 \in F$
\item[$\Rightarrow$] 3 d'accord avec 4
\end{itemize}
\item 3 vs 5
\begin{itemize}
\item $\delta(3,a) = 3 = \delta(5,a)$
\item $\delta(3,b) = 4 \in F$ et $\delta(5,b) = 5 \in F$
\item[$\Rightarrow$] 3 d'accord avec 5
\end{itemize}
\item Pas besoin de tester 4 vs 5, puisqu'ils sont tous les deux d'accord avec 3.
\end{itemize}

On laisse donc $F$ en l'étant. On s'intéresse maintenant à $N_1$ : 

\begin{itemize}
\item 0 vs 1
\begin{itemize}
\item $\delta(0,a) = 1 = \delta(1,a)$
\item $\delta(0,b) = 0 \in N_1$ et $\delta(1,b) = 2 \in N_1$
\item[$\Rightarrow$] On sépare $0$ et $1$.
\end{itemize}
\end{itemize}

On a donc maintenant $N_3 = \{0\}$, $N_4 = \{1\}$, $N_2 = \{2\}$ et $F = \{3,4,5\}$. Puisqu'on a eu un changement (casser $N_1$ en deux), on devrait refaire la vérification pour $F$ faite plus haut, au cas où le résultat aurait changé. Ceci dit, on peut remarquer qu'aucun état de $F$ n'envoie directement en $0$ ou $1$, et donc que $F$ resterait insécable. On peut donc en fusionner les états et obtenir 


\begin{figure}[!ht]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.9cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


  \node[initial,state] (0)                    {$0$};
  \node[state] (1)      [right of=0]                {$1$};  
  \node[state] (2)      [right of=1]                {$2$};
  \node[accepting,state] (3)      [right of=2]                {$3,4,5$};


  \path %(I) edge[loop above]              node {$a,b$} (I)
(0) edge      [loop above]        node {$b$} (0)
(0) edge      []        node {$a$} (1)
(1) edge      [loop above]        node {$a$} (1)
(1) edge      []        node {$b$} (2)
(2) edge      [bend left]        node {$b$} (0)
(2) edge      []        node {$a$} (3)
(3) edge      [loop above]        node {$a,b$} (3);
\end{tikzpicture}
\end{figure}

\end{correction*}


\begin{exercice}

Minimiser l'automate suivant :

\begin{figure}[!ht]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.9cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


  \node[initial,state] (0)                    {$0$};
  \node[state] (1)      [above right of=0]                {$1$};  
  \node[state] (2)      [below right of=0]                {$2$};   
  \node[state] (3)      [right of=0]                {$3$};    
  \node[state] (4)      [right of=1]                {$4$};  
  \node[state] (5)      [right of=2]                {$5$};   
  \node[state] (6)      [right of=3]                {$6$};   
  \node[state] (8)      [above of=6]                {$8$};   
  \node[state,accepting] (7)      [right of=6]                {$7$}; 

  \path %(I) edge[loop above]              node {$a,b$} (I)
(0) edge      []        node {$a$} (1)
(0) edge      []        node {$b$} (2)
(1) edge      []        node {$b$} (4)
(1) edge      []        node {$a$} (3)
(2) edge      []        node {$a$} (3)
(2) edge      []        node {$b$} (5)
(3) edge      []        node {$a,b$} (6)
(4) edge      []        node {$a$} (8)
(4) edge      []        node {$b$} (6)
(5) edge      []        node {$a,b$} (6)
(6) edge      [loop below]        node {$a$} (6)
(6) edge      []        node {$b$} (7)
(7) edge      [loop right]        node {$b$} (7)
(7) edge      [bend left]        node {$a$} (6)
(8) edge      []        node {$a$} (6)
(8) edge      []        node {$b$} (7);
\end{tikzpicture}
\end{figure}

\end{exercice}

\begin{correction*}


On divise donc notre ensemble d'états en $F = \{7\}$ et $N = \{0,1,2,3,4,5,6,8\}$. On ne va manifestement pas pouvoir affiner $F$, contrairement à $N$. Pour ça, on va regarder toutes les paires d'états de $N$ et, à chaque fois, vérifier si les deux états ont des désaccords en lisant $a$ ou $b$ :

\begin{itemize}
\item 0 vs. 1
\begin{itemize}
\item $\delta(0,a) = 1$ et $\delta(1,a) = 3$. Pour l'instant, $1$ et $3$ appartiennent tous les deux à $3$, ce qui veut dire qu'on suppose que $1$ accepte un mot $w$ ssi. $3$ accepte $w$. On peut donc conclure que, de ce qu'on sait, $0$ accepte un mot $a.w$ ssi. $1$ accepte $a.w$.
\item $\delta(0,b) = 2$ et $\delta(1,b) = 4$. $2$ et $4$ appartiennent à la même classe, on suppose donc pour l'instant que $0$ accepte un mot $b.w$ ssi. $1$ accepte un mot $b.w$.
\item[$\Rightarrow$] Pour l'instant, on conserve notre hypothèse selon laquelle $0$ et $1$ acceptent le même langage. Ils sont donc dans la même classe.
\end{itemize}
\item 0 vs. 2
\begin{itemize}
\item $\delta(0,a) = 1$ et $\delta(2,a) = 3$, $1$ et $3$ sont dans la même classe.
\item $\delta(0,b) = 2$ et $\delta(2,b) = 5$. $2$ et $5$ appartiennent à la même classe.
\item[$\Rightarrow$] Pour l'instant, on conserve notre hypothèse selon laquelle $0$ et $2$ acceptent le même langage. 2 rejoint donc la classe de 0 et 1.
\end{itemize}
\item[] Pour préserver ce qu'il me reste de santé mentale, je ne vais pas détailler tout le reste.
\item 0 vs. 3 : compatibilité. 3 est donc mis avec 0, 1 et 2.
\item 0 vs. 4 : compatibilité. 4 est donc mis avec 0, 1, 2 et 3.
\item 0 vs. 5 : compatibilité. 5 est donc mis avec 0, 1, 2 et 3, 4.
\item 0 vs. 6 : incompatibilité. 6 est mis à part.
\item 0 vs. 8 : incompatibilité. 8 est mis à part.
\item[] On sait ue 6 et 8 ne vont pas dans l'ensemble $0,1,2,3,4,5$, mais il reste à déterminer s'ils vont ensemble ou s'ils restent chacun dans leur coin.
\item 6 vs. 8 : compatibilité, on classe $6$ et $8$ ensemble.
\item[$\Rightarrow$] On sépare $N$ en $N_1 = \{0,1,2,3,4,5\}$ et $N_2 = \{6,8\}$
\end{itemize}

On peut noter que $6$ et $8$ pointent exactement sur les mêmes états pour les deux lettres, on peut donc être sûr qu'on n'arrivera pas à les séparer, quoi qu'il arrive à $N_1$. On s'intéresse donc à ce dernier.

\begin{itemize}

\item Les seuls états qu'on va sortir sont ceux qui pointent vers $N_2$, cad. $\{3,4,5\}$. On peut en effet vérifier qu'ils sont tous incompatibles avec $0$, $1$ et $2$, et qu'ils sont compatibles entre eux.

\end{itemize}


On divise donc $N_1$ en $N_3 = \{0,1,2\}$ et $N_4 = \{3,4,5\}$. On regarde $N_3$ :

\begin{itemize}

\item $1$ et $2$ vont vers $N_4$ avec $b$ alors que $0$ reste en $N_3$. $1$ et $2$ envoient vers le même état avec $a$. 
\end{itemize}

On divise $N_3$ en $N_5 = \{0\}$ et $N_6 = \{1,2\}$. En plus de ces deux ensembles, on a $N_4 = \{3,4,5\}$, $N_2 = \{6,8\}$ et $F = \{7\}$.
En repassant sur chacun de ces ensembles, on se rend compte qu'on ne peut faire aucune séparation. On peut donc fusionner les états de chaque classe et obtenir 


\begin{figure}[!ht]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.9cm,
                    semithick]
  \tikzstyle{every state}=[fill=white,text=black]
  \tikzstyle{place}=[rectangle,draw=black,fill=white, minimum size=7mm]


  \node[initial,state] (0)                    {$0$};
  \node[state] (12)      [right of=0]                {$1,2$};  
  \node[state] (345)      [right of=12]                {$3,4,5$};   
  \node[state] (68)      [right of=345]                {$6,8$};    
  \node[state,accepting] (7)      [right of=68]                {$7$};  

  \path %(I) edge[loop above]              node {$a,b$} (I)
(0) edge      []        node {$a,b$} (12)
(12) edge      []        node {$a,b$} (345)
(345) edge      []        node {$a,b$} (68)
(68) edge      [loop above]        node {$a$} (68)
(68) edge      []        node {$b$} (7)
(7) edge      [loop above]        node {$b$} (7)
(7) edge      [bend left]        node {$a$} (68);
\end{tikzpicture}
\end{figure}

Cad. l'automate acceptant les mots d'au moins 4 lettres terminant par un $b$. La version initiale de l'automate était non-minimale en ce qu'elle distinguait en plusieurs états la lecture de $a$ ou de $b$ alors qu'au fond, on ne s'intéressait qu'à la longueur.

\end{correction*}

\section{Limite de la reconnaissance par automates finis}

\section{Propriétés de clôture}
\label{cloture}
\subsection{Union}

\subsection{Concaténation}

\subsection{Intersection}

\subsection{Itération}

\subsection{Complémentaire}

